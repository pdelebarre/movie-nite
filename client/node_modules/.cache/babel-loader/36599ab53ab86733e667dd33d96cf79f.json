{"ast":null,"code":"var createQueryBuilder = require('../builder-sq');\n\nvar createExpressionBuilder = require('../builder-expression');\n\nvar _require = require('../lib-util'),\n    memoize = _require.memoize,\n    normalKey = _require.normalKey;\n/**\n * Creates a version of EasyQB for the given SQL dialect and database adapter.\n *\n * A dialect is variant of the SQL language,\n * while an adapter is the driver that communicates with the database.\n *\n * This design makes it easy to swap drivers, e.g. mysql vs mysql2 or\n * add new databases just by connecting a new adapter to an existing dialect.\n *\n */\n\n\nvar createSqorn = function createSqorn(_ref) {\n  var dialect = _ref.dialect;\n  return function () {\n    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var query = dialect.query,\n        expression = dialect.expression,\n        parameterize = dialect.parameterize,\n        escape = dialect.escape; // 1. Create default context properties passed through build tree\n\n    var mapKey = memoize(normalKey);\n    var defaultContext = {\n      parameterize: parameterize,\n      escape: escape,\n      mapKey: mapKey,\n      build: build\n    }; // 2. Create Expression Builder\n\n    var e = createExpressionBuilder({\n      defaultContext: defaultContext,\n      expression: expression\n    }); // 3. Create Query Builder\n\n    var sq = createQueryBuilder({\n      defaultContext: defaultContext,\n      query: query,\n      e: e,\n      config: config\n    }); // 4. TODO: Build Executor, Attach e and execute functions\n    // 5. TODO: Return { sq, e, transaction, db }\n\n    return sq;\n  };\n};\n\nfunction build(arg) {\n  if (arg === undefined) throw Error('Error: undefined argument');\n\n  if (typeof arg === 'function') {\n    if (arg._build) {\n      var _arg$_build = arg._build(this),\n          type = _arg$_build.type,\n          text = _arg$_build.text;\n\n      if (type === 'expression') return text;\n      if (type === 'fragment') return text;\n      return \"(\".concat(text, \")\");\n    }\n\n    return arg(this);\n  }\n\n  return this.unparameterized ? this.escape(arg) : this.parameterize(arg);\n}\n\nmodule.exports = createSqorn;","map":{"version":3,"sources":["/Volumes/LaCie/Dev/myProjects/movie-nite/node_modules/EasyQB/src/lib-core/index.js"],"names":["createQueryBuilder","require","createExpressionBuilder","memoize","normalKey","createSqorn","dialect","config","query","expression","parameterize","escape","mapKey","defaultContext","build","e","sq","arg","undefined","Error","_build","type","text","unparameterized","module","exports"],"mappings":"AAAA,IAAMA,kBAAkB,GAAGC,OAAO,CAAC,eAAD,CAAlC;;AACA,IAAMC,uBAAuB,GAAGD,OAAO,CAAC,uBAAD,CAAvC;;eAC+BA,OAAO,CAAC,aAAD,C;IAA9BE,O,YAAAA,O;IAASC,S,YAAAA,S;AAGjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,IAAMC,WAAW,GAAG,SAAdA,WAAc;AAAA,MAAGC,OAAH,QAAGA,OAAH;AAAA,SAAiB,YAAiB;AAAA,QAAhBC,MAAgB,uEAAP,EAAO;AAAA,QAC5CC,KAD4C,GACAF,OADA,CAC5CE,KAD4C;AAAA,QACrCC,UADqC,GACAH,OADA,CACrCG,UADqC;AAAA,QACzBC,YADyB,GACAJ,OADA,CACzBI,YADyB;AAAA,QACXC,MADW,GACAL,OADA,CACXK,MADW,EAGpD;;AACA,QAAMC,MAAM,GAAGT,OAAO,CAACC,SAAD,CAAtB;AACA,QAAMS,cAAc,GAAG;AAAEH,MAAAA,YAAY,EAAZA,YAAF;AAAgBC,MAAAA,MAAM,EAANA,MAAhB;AAAwBC,MAAAA,MAAM,EAANA,MAAxB;AAAgCE,MAAAA,KAAK,EAALA;AAAhC,KAAvB,CALoD,CAOpD;;AACA,QAAMC,CAAC,GAAGb,uBAAuB,CAAC;AAAEW,MAAAA,cAAc,EAAdA,cAAF;AAAkBJ,MAAAA,UAAU,EAAVA;AAAlB,KAAD,CAAjC,CARoD,CAUpD;;AACA,QAAMO,EAAE,GAAGhB,kBAAkB,CAAC;AAAEa,MAAAA,cAAc,EAAdA,cAAF;AAAkBL,MAAAA,KAAK,EAALA,KAAlB;AAAyBO,MAAAA,CAAC,EAADA,CAAzB;AAA4BR,MAAAA,MAAM,EAANA;AAA5B,KAAD,CAA7B,CAXoD,CAapD;AAEA;;AACA,WAAOS,EAAP;AACD,GAjBmB;AAAA,CAApB;;AAmBA,SAASF,KAAT,CAAeG,GAAf,EAAoB;AAClB,MAAIA,GAAG,KAAKC,SAAZ,EAAuB,MAAMC,KAAK,CAAC,2BAAD,CAAX;;AACvB,MAAI,OAAOF,GAAP,KAAe,UAAnB,EAA+B;AAC7B,QAAIA,GAAG,CAACG,MAAR,EAAgB;AAAA,wBACSH,GAAG,CAACG,MAAJ,CAAW,IAAX,CADT;AAAA,UACNC,IADM,eACNA,IADM;AAAA,UACAC,IADA,eACAA,IADA;;AAEd,UAAID,IAAI,KAAK,YAAb,EAA2B,OAAOC,IAAP;AAC3B,UAAID,IAAI,KAAK,UAAb,EAAyB,OAAOC,IAAP;AACzB,wBAAWA,IAAX;AACD;;AACD,WAAOL,GAAG,CAAC,IAAD,CAAV;AACD;;AACD,SAAO,KAAKM,eAAL,GAAuB,KAAKZ,MAAL,CAAYM,GAAZ,CAAvB,GAA0C,KAAKP,YAAL,CAAkBO,GAAlB,CAAjD;AACD;;AAEDO,MAAM,CAACC,OAAP,GAAiBpB,WAAjB","sourcesContent":["const createQueryBuilder = require('../builder-sq')\nconst createExpressionBuilder = require('../builder-expression')\nconst { memoize, normalKey } = require('../lib-util')\n\n\n/**\n * Creates a version of EasyQB for the given SQL dialect and database adapter.\n *\n * A dialect is variant of the SQL language,\n * while an adapter is the driver that communicates with the database.\n *\n * This design makes it easy to swap drivers, e.g. mysql vs mysql2 or\n * add new databases just by connecting a new adapter to an existing dialect.\n *\n */\n\nconst createSqorn = ({ dialect }) => (config = {}) => {\n  const { query, expression, parameterize, escape } = dialect\n\n  // 1. Create default context properties passed through build tree\n  const mapKey = memoize(normalKey)\n  const defaultContext = { parameterize, escape, mapKey, build }\n\n  // 2. Create Expression Builder\n  const e = createExpressionBuilder({ defaultContext, expression })\n\n  // 3. Create Query Builder\n  const sq = createQueryBuilder({ defaultContext, query, e, config })\n\n  // 4. TODO: Build Executor, Attach e and execute functions\n\n  // 5. TODO: Return { sq, e, transaction, db }\n  return sq\n}\n\nfunction build(arg) {\n  if (arg === undefined) throw Error('Error: undefined argument')\n  if (typeof arg === 'function') {\n    if (arg._build) {\n      const { type, text } = arg._build(this)\n      if (type === 'expression') return text\n      if (type === 'fragment') return text\n      return `(${text})`\n    }\n    return arg(this)\n  }\n  return this.unparameterized ? this.escape(arg) : this.parameterize(arg)\n}\n\nmodule.exports = createSqorn"]},"metadata":{},"sourceType":"script"}