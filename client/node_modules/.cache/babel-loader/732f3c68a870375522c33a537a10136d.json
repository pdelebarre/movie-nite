{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport React, { memo, useEffect, useState } from 'react';\nimport PropTypes from 'prop-types';\nimport safeInvoke from '../../lib/safe-invoke';\nimport { Portal } from '../../portal';\nimport { Stack } from '../../stack';\nimport EditableCellField from './EditableCellField';\nimport TableCell from './TableCell';\nimport TextTableCell from './TextTableCell';\nvar emptyProps = {};\nvar EditableCell = /*#__PURE__*/memo(function EditableCell(props) {\n  var children = props.children,\n      _props$size = props.size,\n      size = _props$size === void 0 ? 300 : _props$size,\n      disabled = props.disabled,\n      placeholder = props.placeholder,\n      _props$isSelectable = props.isSelectable,\n      isSelectable = _props$isSelectable === void 0 ? true : _props$isSelectable,\n      _props$textProps = props.textProps,\n      textProps = _props$textProps === void 0 ? emptyProps : _props$textProps,\n      _props$autoFocus = props.autoFocus,\n      autoFocus = _props$autoFocus === void 0 ? false : _props$autoFocus,\n      rest = _objectWithoutProperties(props, [\"children\", \"size\", \"disabled\", \"placeholder\", \"isSelectable\", \"textProps\", \"autoFocus\"]);\n\n  var cursor = 'text';\n\n  var _useState = useState(),\n      _useState2 = _slicedToArray(_useState, 2),\n      mainRef = _useState2[0],\n      setMainRef = _useState2[1];\n\n  var _useState3 = useState(children),\n      _useState4 = _slicedToArray(_useState3, 2),\n      value = _useState4[0],\n      setValue = _useState4[1];\n\n  var _useState5 = useState(autoFocus),\n      _useState6 = _slicedToArray(_useState5, 2),\n      isEditing = _useState6[0],\n      setIsEditing = _useState6[1];\n\n  useEffect(function () {\n    setValue(children);\n  }, [children]);\n\n  var handleDoubleClick = function handleDoubleClick() {\n    if (disabled || !isSelectable) return;\n    setIsEditing(true);\n  };\n\n  var handleKeyDown = function handleKeyDown(e) {\n    if (disabled) return;\n    var key = e.key;\n    /**\n     * When the user presses a character on the keyboard, use that character\n     * as the value in the text field.\n     */\n\n    if (key === 'Enter' || key === 'Shift') {\n      setIsEditing(true);\n    } else if (key.match(/^[a-z]{0,10}$/) && !e.metaKey && !e.ctrlKey && !e.altKey) {\n      setIsEditing(true);\n      setValue(value + key);\n    }\n  };\n\n  var handleFieldChangeComplete = function handleFieldChangeComplete(value) {\n    var onChange = rest.onChange;\n    setIsEditing(false);\n    setValue(value);\n    safeInvoke(onChange, value);\n\n    if (mainRef && isSelectable) {\n      mainRef.focus();\n    }\n  };\n\n  var handleFieldCancel = function handleFieldCancel() {\n    setIsEditing(false);\n  };\n\n  var handleClick = function handleClick() {\n    if (mainRef) mainRef.focus();\n  };\n\n  if (disabled) {\n    cursor = 'not-allowed';\n  } else if (isSelectable) {\n    cursor = 'default';\n  }\n\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(TextTableCell, _extends({\n    ref: setMainRef,\n    isSelectable: isSelectable,\n    onClick: handleClick,\n    onDoubleClick: handleDoubleClick,\n    onKeyDown: handleKeyDown,\n    cursor: cursor,\n    textProps: _objectSpread({\n      size: size,\n      opacity: disabled || !value && placeholder ? 0.5 : 1\n    }, textProps)\n  }, rest), value || placeholder), isEditing && /*#__PURE__*/React.createElement(Portal, null, /*#__PURE__*/React.createElement(Stack, null, function (zIndex) {\n    return /*#__PURE__*/React.createElement(EditableCellField, {\n      zIndex: zIndex,\n      getTargetRef: function getTargetRef() {\n        return mainRef;\n      },\n      value: value,\n      onEscape: handleFieldCancel,\n      onChangeComplete: handleFieldChangeComplete,\n      onCancel: handleFieldCancel,\n      size: size\n    });\n  })));\n});\nEditableCell.propTypes = _objectSpread(_objectSpread({}, TableCell.propTypes), {}, {\n  /*\n   * Makes the TableCell focusable.\n   * Will add tabIndex={-1 || this.props.tabIndex}.\n   */\n  isSelectable: PropTypes.bool,\n\n  /**\n   * When true, the cell can't be edited.\n   */\n  disabled: PropTypes.bool,\n\n  /**\n   * Optional placeholder when children is falsy.\n   */\n  placeholder: PropTypes.node,\n\n  /**\n   * The size used for the TextTableCell and Textarea.\n   */\n  size: PropTypes.oneOf([300, 400]),\n\n  /**\n   * This is the value of the cell.\n   */\n  children: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n\n  /**\n   * Function called when value changes. (value: string) => void.\n   */\n  onChange: PropTypes.func,\n\n  /**\n   * When true, the cell will initialize in the editing state.\n   */\n  autoFocus: PropTypes.bool\n});\nexport default EditableCell;","map":{"version":3,"sources":["../../../src/table/src/EditableCell.js"],"names":["emptyProps","EditableCell","memo","children","size","disabled","placeholder","isSelectable","textProps","autoFocus","rest","props","cursor","mainRef","setMainRef","useState","value","setValue","isEditing","setIsEditing","useEffect","handleDoubleClick","handleKeyDown","key","e","handleFieldChangeComplete","onChange","safeInvoke","handleFieldCancel","handleClick","opacity","TableCell","PropTypes","bool"],"mappings":"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","sourcesContent":["import React, { memo, useEffect, useState } from 'react'\nimport PropTypes from 'prop-types'\nimport safeInvoke from '../../lib/safe-invoke'\nimport { Portal } from '../../portal'\nimport { Stack } from '../../stack'\nimport EditableCellField from './EditableCellField'\nimport TableCell from './TableCell'\nimport TextTableCell from './TextTableCell'\n\nconst emptyProps = {}\n\nconst EditableCell = memo(function EditableCell(props) {\n  const {\n    children,\n    size = 300,\n    disabled,\n    placeholder,\n    isSelectable = true,\n    textProps = emptyProps,\n    autoFocus = false,\n    ...rest\n  } = props\n\n  let cursor = 'text'\n\n  const [mainRef, setMainRef] = useState()\n  const [value, setValue] = useState(children)\n  const [isEditing, setIsEditing] = useState(autoFocus)\n\n  useEffect(() => {\n    setValue(children)\n  }, [children])\n\n  const handleDoubleClick = () => {\n    if (disabled || !isSelectable) return\n\n    setIsEditing(true)\n  }\n\n  const handleKeyDown = e => {\n    if (disabled) return\n    const { key } = e\n\n    /**\n     * When the user presses a character on the keyboard, use that character\n     * as the value in the text field.\n     */\n    if (key === 'Enter' || key === 'Shift') {\n      setIsEditing(true)\n    } else if (key.match(/^[a-z]{0,10}$/) && !e.metaKey && !e.ctrlKey && !e.altKey) {\n      setIsEditing(true)\n      setValue(value + key)\n    }\n  }\n\n  const handleFieldChangeComplete = value => {\n    const { onChange } = rest\n\n    setIsEditing(false)\n    setValue(value)\n\n    safeInvoke(onChange, value)\n\n    if (mainRef && isSelectable) {\n      mainRef.focus()\n    }\n  }\n\n  const handleFieldCancel = () => {\n    setIsEditing(false)\n  }\n\n  const handleClick = () => {\n    if (mainRef) mainRef.focus()\n  }\n\n  if (disabled) {\n    cursor = 'not-allowed'\n  } else if (isSelectable) {\n    cursor = 'default'\n  }\n\n  return (\n    <React.Fragment>\n      <TextTableCell\n        ref={setMainRef}\n        isSelectable={isSelectable}\n        onClick={handleClick}\n        onDoubleClick={handleDoubleClick}\n        onKeyDown={handleKeyDown}\n        cursor={cursor}\n        textProps={{\n          size,\n          opacity: disabled || (!value && placeholder) ? 0.5 : 1,\n          ...textProps\n        }}\n        {...rest}\n      >\n        {value || placeholder}\n      </TextTableCell>\n      {isEditing && (\n        <Portal>\n          <Stack>\n            {zIndex => (\n              <EditableCellField\n                zIndex={zIndex}\n                getTargetRef={() => mainRef}\n                value={value}\n                onEscape={handleFieldCancel}\n                onChangeComplete={handleFieldChangeComplete}\n                onCancel={handleFieldCancel}\n                size={size}\n              />\n            )}\n          </Stack>\n        </Portal>\n      )}\n    </React.Fragment>\n  )\n})\n\nEditableCell.propTypes = {\n  /**\n   * Composes the TableCell component as the base.\n   */\n  ...TableCell.propTypes,\n\n  /*\n   * Makes the TableCell focusable.\n   * Will add tabIndex={-1 || this.props.tabIndex}.\n   */\n  isSelectable: PropTypes.bool,\n\n  /**\n   * When true, the cell can't be edited.\n   */\n  disabled: PropTypes.bool,\n\n  /**\n   * Optional placeholder when children is falsy.\n   */\n  placeholder: PropTypes.node,\n\n  /**\n   * The size used for the TextTableCell and Textarea.\n   */\n  size: PropTypes.oneOf([300, 400]),\n\n  /**\n   * This is the value of the cell.\n   */\n  children: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n\n  /**\n   * Function called when value changes. (value: string) => void.\n   */\n  onChange: PropTypes.func,\n\n  /**\n   * When true, the cell will initialize in the editing state.\n   */\n  autoFocus: PropTypes.bool\n}\n\nexport default EditableCell\n"]},"metadata":{},"sourceType":"module"}