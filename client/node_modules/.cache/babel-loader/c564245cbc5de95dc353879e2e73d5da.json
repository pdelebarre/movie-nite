{"ast":null,"code":"const createQueryBuilder = require('../builder-sq');\n\nconst createExpressionBuilder = require('../builder-expression');\n\nconst {\n  memoize,\n  normalKey\n} = require('../lib-util');\n/**\n * Creates a version of EasyQB for the given SQL dialect and database adapter.\n *\n * A dialect is variant of the SQL language,\n * while an adapter is the driver that communicates with the database.\n *\n * This design makes it easy to swap drivers, e.g. mysql vs mysql2 or\n * add new databases just by connecting a new adapter to an existing dialect.\n *\n */\n\n\nconst createSqorn = ({\n  dialect\n}) => (config = {}) => {\n  const {\n    query,\n    expression,\n    parameterize,\n    escape\n  } = dialect; // 1. Create default context properties passed through build tree\n\n  const mapKey = memoize(normalKey);\n  const defaultContext = {\n    parameterize,\n    escape,\n    mapKey,\n    build\n  }; // 2. Create Expression Builder\n\n  const e = createExpressionBuilder({\n    defaultContext,\n    expression\n  }); // 3. Create Query Builder\n\n  const sq = createQueryBuilder({\n    defaultContext,\n    query,\n    e,\n    config\n  }); // 4. TODO: Build Executor, Attach e and execute functions\n  // 5. TODO: Return { sq, e, transaction, db }\n\n  return sq;\n};\n\nfunction build(arg) {\n  if (arg === undefined) throw Error('Error: undefined argument');\n\n  if (typeof arg === 'function') {\n    if (arg._build) {\n      const {\n        type,\n        text\n      } = arg._build(this);\n\n      if (type === 'expression') return text;\n      if (type === 'fragment') return text;\n      return `(${text})`;\n    }\n\n    return arg(this);\n  }\n\n  return this.unparameterized ? this.escape(arg) : this.parameterize(arg);\n}\n\nmodule.exports = createSqorn;","map":{"version":3,"sources":["/Volumes/LaCie/Dev/myProjects/movie-nite/node_modules/EasyQB/src/lib-core/index.js"],"names":["createQueryBuilder","require","createExpressionBuilder","memoize","normalKey","createSqorn","dialect","config","query","expression","parameterize","escape","mapKey","defaultContext","build","e","sq","arg","undefined","Error","_build","type","text","unparameterized","module","exports"],"mappings":"AAAA,MAAMA,kBAAkB,GAAGC,OAAO,CAAC,eAAD,CAAlC;;AACA,MAAMC,uBAAuB,GAAGD,OAAO,CAAC,uBAAD,CAAvC;;AACA,MAAM;AAAEE,EAAAA,OAAF;AAAWC,EAAAA;AAAX,IAAyBH,OAAO,CAAC,aAAD,CAAtC;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,MAAMI,WAAW,GAAG,CAAC;AAAEC,EAAAA;AAAF,CAAD,KAAiB,CAACC,MAAM,GAAG,EAAV,KAAiB;AACpD,QAAM;AAAEC,IAAAA,KAAF;AAASC,IAAAA,UAAT;AAAqBC,IAAAA,YAArB;AAAmCC,IAAAA;AAAnC,MAA8CL,OAApD,CADoD,CAGpD;;AACA,QAAMM,MAAM,GAAGT,OAAO,CAACC,SAAD,CAAtB;AACA,QAAMS,cAAc,GAAG;AAAEH,IAAAA,YAAF;AAAgBC,IAAAA,MAAhB;AAAwBC,IAAAA,MAAxB;AAAgCE,IAAAA;AAAhC,GAAvB,CALoD,CAOpD;;AACA,QAAMC,CAAC,GAAGb,uBAAuB,CAAC;AAAEW,IAAAA,cAAF;AAAkBJ,IAAAA;AAAlB,GAAD,CAAjC,CARoD,CAUpD;;AACA,QAAMO,EAAE,GAAGhB,kBAAkB,CAAC;AAAEa,IAAAA,cAAF;AAAkBL,IAAAA,KAAlB;AAAyBO,IAAAA,CAAzB;AAA4BR,IAAAA;AAA5B,GAAD,CAA7B,CAXoD,CAapD;AAEA;;AACA,SAAOS,EAAP;AACD,CAjBD;;AAmBA,SAASF,KAAT,CAAeG,GAAf,EAAoB;AAClB,MAAIA,GAAG,KAAKC,SAAZ,EAAuB,MAAMC,KAAK,CAAC,2BAAD,CAAX;;AACvB,MAAI,OAAOF,GAAP,KAAe,UAAnB,EAA+B;AAC7B,QAAIA,GAAG,CAACG,MAAR,EAAgB;AACd,YAAM;AAAEC,QAAAA,IAAF;AAAQC,QAAAA;AAAR,UAAiBL,GAAG,CAACG,MAAJ,CAAW,IAAX,CAAvB;;AACA,UAAIC,IAAI,KAAK,YAAb,EAA2B,OAAOC,IAAP;AAC3B,UAAID,IAAI,KAAK,UAAb,EAAyB,OAAOC,IAAP;AACzB,aAAQ,IAAGA,IAAK,GAAhB;AACD;;AACD,WAAOL,GAAG,CAAC,IAAD,CAAV;AACD;;AACD,SAAO,KAAKM,eAAL,GAAuB,KAAKZ,MAAL,CAAYM,GAAZ,CAAvB,GAA0C,KAAKP,YAAL,CAAkBO,GAAlB,CAAjD;AACD;;AAEDO,MAAM,CAACC,OAAP,GAAiBpB,WAAjB","sourcesContent":["const createQueryBuilder = require('../builder-sq')\nconst createExpressionBuilder = require('../builder-expression')\nconst { memoize, normalKey } = require('../lib-util')\n\n\n/**\n * Creates a version of EasyQB for the given SQL dialect and database adapter.\n *\n * A dialect is variant of the SQL language,\n * while an adapter is the driver that communicates with the database.\n *\n * This design makes it easy to swap drivers, e.g. mysql vs mysql2 or\n * add new databases just by connecting a new adapter to an existing dialect.\n *\n */\n\nconst createSqorn = ({ dialect }) => (config = {}) => {\n  const { query, expression, parameterize, escape } = dialect\n\n  // 1. Create default context properties passed through build tree\n  const mapKey = memoize(normalKey)\n  const defaultContext = { parameterize, escape, mapKey, build }\n\n  // 2. Create Expression Builder\n  const e = createExpressionBuilder({ defaultContext, expression })\n\n  // 3. Create Query Builder\n  const sq = createQueryBuilder({ defaultContext, query, e, config })\n\n  // 4. TODO: Build Executor, Attach e and execute functions\n\n  // 5. TODO: Return { sq, e, transaction, db }\n  return sq\n}\n\nfunction build(arg) {\n  if (arg === undefined) throw Error('Error: undefined argument')\n  if (typeof arg === 'function') {\n    if (arg._build) {\n      const { type, text } = arg._build(this)\n      if (type === 'expression') return text\n      if (type === 'fragment') return text\n      return `(${text})`\n    }\n    return arg(this)\n  }\n  return this.unparameterized ? this.escape(arg) : this.parameterize(arg)\n}\n\nmodule.exports = createSqorn"]},"metadata":{},"sourceType":"script"}