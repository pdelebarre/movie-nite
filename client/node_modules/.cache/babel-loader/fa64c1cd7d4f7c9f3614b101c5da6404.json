{"ast":null,"code":"const {\n  isObject,\n  buildCall,\n  mapJoin,\n  mapJoinWrap\n} = require('../../lib-util');\n\nmodule.exports = ctx => {\n  if (ctx.grp.length === 0) return;\n  const txt = calls(ctx, ctx.grp);\n  return txt && `group by ${txt}`;\n};\n\nconst buildArg = (ctx, arg) => {\n  if (typeof arg === 'string') return arg;\n  if (typeof arg === 'function') return ctx.build(arg);\n  if (Array.isArray(arg)) return buildArrayArg(ctx, arg);\n  if (isObject(arg)) return buildObject(ctx, arg);\n  throw Error('Invalid order by argument:', arg);\n};\n\nconst buildArrayArg = mapJoinWrap(buildArg); // postgres only\n// clone of buildArg() without support for object args\n\nconst buildCubeOrRollupArg = (ctx, arg) => {\n  if (typeof arg === 'string') return arg;\n  if (typeof arg === 'function') return ctx.build(arg);\n  if (Array.isArray(arg)) return buildCubeOrRollupArrayArg(ctx, arg);\n  throw Error('Invalid cube/rollup argument');\n}; // postgres only\n// clone of buildArrayArg() without support for object args\n\n\nconst buildCubeOrRollupArrayArg = mapJoinWrap(buildCubeOrRollupArg); // postgres only\n\nconst buildObject = (ctx, obj) => {\n  const {\n    type,\n    args\n  } = obj;\n\n  if (type === 'rollup') {\n    return `rollup ${buildCubeOrRollupArg(ctx, args)}`;\n  }\n\n  if (type === 'cube') {\n    return `cube ${buildCubeOrRollupArg(ctx, args)}`;\n  }\n\n  if (type === 'grouping sets') {\n    return `grouping sets ${buildArg(ctx, args)}`;\n  }\n\n  throw Error('Invalid group by argument');\n};\n\nconst calls = mapJoin(buildCall(mapJoin(buildArg)));","map":{"version":3,"sources":["/Volumes/LaCie/Dev/myProjects/movie-nite/node_modules/EasyQB/src/lib-sq/clauses/group.js"],"names":["isObject","buildCall","mapJoin","mapJoinWrap","require","module","exports","ctx","grp","length","txt","calls","buildArg","arg","build","Array","isArray","buildArrayArg","buildObject","Error","buildCubeOrRollupArg","buildCubeOrRollupArrayArg","obj","type","args"],"mappings":"AAAA,MAAM;AAAEA,EAAAA,QAAF;AAAYC,EAAAA,SAAZ;AAAuBC,EAAAA,OAAvB;AAAgCC,EAAAA;AAAhC,IAAgDC,OAAO,CAAC,gBAAD,CAA7D;;AAEAC,MAAM,CAACC,OAAP,GAAiBC,GAAG,IAAI;AACtB,MAAIA,GAAG,CAACC,GAAJ,CAAQC,MAAR,KAAmB,CAAvB,EAA0B;AAC1B,QAAMC,GAAG,GAAGC,KAAK,CAACJ,GAAD,EAAMA,GAAG,CAACC,GAAV,CAAjB;AACA,SAAOE,GAAG,IAAK,YAAWA,GAAI,EAA9B;AACD,CAJD;;AAMA,MAAME,QAAQ,GAAG,CAACL,GAAD,EAAMM,GAAN,KAAc;AAC7B,MAAI,OAAOA,GAAP,KAAe,QAAnB,EAA6B,OAAOA,GAAP;AAC7B,MAAI,OAAOA,GAAP,KAAe,UAAnB,EAA+B,OAAON,GAAG,CAACO,KAAJ,CAAUD,GAAV,CAAP;AAC/B,MAAIE,KAAK,CAACC,OAAN,CAAcH,GAAd,CAAJ,EAAwB,OAAOI,aAAa,CAACV,GAAD,EAAMM,GAAN,CAApB;AACxB,MAAIb,QAAQ,CAACa,GAAD,CAAZ,EAAmB,OAAOK,WAAW,CAACX,GAAD,EAAMM,GAAN,CAAlB;AACnB,QAAMM,KAAK,CAAC,4BAAD,EAA+BN,GAA/B,CAAX;AACD,CAND;;AAQA,MAAMI,aAAa,GAAGd,WAAW,CAACS,QAAD,CAAjC,C,CAEA;AACA;;AACA,MAAMQ,oBAAoB,GAAG,CAACb,GAAD,EAAMM,GAAN,KAAc;AACzC,MAAI,OAAOA,GAAP,KAAe,QAAnB,EAA6B,OAAOA,GAAP;AAC7B,MAAI,OAAOA,GAAP,KAAe,UAAnB,EAA+B,OAAON,GAAG,CAACO,KAAJ,CAAUD,GAAV,CAAP;AAC/B,MAAIE,KAAK,CAACC,OAAN,CAAcH,GAAd,CAAJ,EAAwB,OAAOQ,yBAAyB,CAACd,GAAD,EAAMM,GAAN,CAAhC;AACxB,QAAMM,KAAK,CAAC,8BAAD,CAAX;AACD,CALD,C,CAOA;AACA;;;AACA,MAAME,yBAAyB,GAAGlB,WAAW,CAACiB,oBAAD,CAA7C,C,CAEA;;AACA,MAAMF,WAAW,GAAG,CAACX,GAAD,EAAMe,GAAN,KAAc;AAChC,QAAM;AAAEC,IAAAA,IAAF;AAAQC,IAAAA;AAAR,MAAiBF,GAAvB;;AACA,MAAIC,IAAI,KAAK,QAAb,EAAuB;AACrB,WAAQ,UAASH,oBAAoB,CAACb,GAAD,EAAMiB,IAAN,CAAY,EAAjD;AACD;;AACD,MAAID,IAAI,KAAK,MAAb,EAAqB;AACnB,WAAQ,QAAOH,oBAAoB,CAACb,GAAD,EAAMiB,IAAN,CAAY,EAA/C;AACD;;AACD,MAAID,IAAI,KAAK,eAAb,EAA8B;AAC5B,WAAQ,iBAAgBX,QAAQ,CAACL,GAAD,EAAMiB,IAAN,CAAY,EAA5C;AACD;;AACD,QAAML,KAAK,CAAC,2BAAD,CAAX;AACD,CAZD;;AAcA,MAAMR,KAAK,GAAGT,OAAO,CAACD,SAAS,CAACC,OAAO,CAACU,QAAD,CAAR,CAAV,CAArB","sourcesContent":["const { isObject, buildCall, mapJoin, mapJoinWrap } = require('../../lib-util')\n\nmodule.exports = ctx => {\n  if (ctx.grp.length === 0) return\n  const txt = calls(ctx, ctx.grp)\n  return txt && `group by ${txt}`\n}\n\nconst buildArg = (ctx, arg) => {\n  if (typeof arg === 'string') return arg\n  if (typeof arg === 'function') return ctx.build(arg)\n  if (Array.isArray(arg)) return buildArrayArg(ctx, arg)\n  if (isObject(arg)) return buildObject(ctx, arg)\n  throw Error('Invalid order by argument:', arg)\n}\n\nconst buildArrayArg = mapJoinWrap(buildArg)\n\n// postgres only\n// clone of buildArg() without support for object args\nconst buildCubeOrRollupArg = (ctx, arg) => {\n  if (typeof arg === 'string') return arg\n  if (typeof arg === 'function') return ctx.build(arg)\n  if (Array.isArray(arg)) return buildCubeOrRollupArrayArg(ctx, arg)\n  throw Error('Invalid cube/rollup argument')\n}\n\n// postgres only\n// clone of buildArrayArg() without support for object args\nconst buildCubeOrRollupArrayArg = mapJoinWrap(buildCubeOrRollupArg)\n\n// postgres only\nconst buildObject = (ctx, obj) => {\n  const { type, args } = obj\n  if (type === 'rollup') {\n    return `rollup ${buildCubeOrRollupArg(ctx, args)}`\n  }\n  if (type === 'cube') {\n    return `cube ${buildCubeOrRollupArg(ctx, args)}`\n  }\n  if (type === 'grouping sets') {\n    return `grouping sets ${buildArg(ctx, args)}`\n  }\n  throw Error('Invalid group by argument')\n}\n\nconst calls = mapJoin(buildCall(mapJoin(buildArg)))\n"]},"metadata":{},"sourceType":"script"}