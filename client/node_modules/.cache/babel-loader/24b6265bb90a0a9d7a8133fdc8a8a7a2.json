{"ast":null,"code":"const {\n  isTaggedTemplate\n} = require('../lib-util');\n\nconst createExpressionCompiler = expressionTable => {\n  const callsCompiler = createCallsCompiler(expressionTable);\n  return (ctx, current) => {\n    const calls = buildCalls(current);\n    const text = callsCompiler(ctx, calls);\n    return {\n      text,\n      args: ctx.params,\n      type: 'expression'\n    };\n  };\n}; // TODO: Performance optimization:\n// inline expression building with this method so at most only one array\n// is allocated in total, no array of object containing arrays nonsense\n\n\nconst buildCalls = current => {\n  // get call nodes\n  const calls = [];\n\n  for (; current; current = current.prev) calls.push(current);\n\n  if (calls.length === 0) throw Error('Error: Empty expression'); // build expression list\n\n  let expression = {\n    name: 'arg',\n    args: []\n  };\n  const expressions = [expression];\n  const last = calls.length - 1;\n\n  for (let i = last; i >= 0; --i) {\n    const {\n      name,\n      args\n    } = calls[i];\n\n    if (i === last) {\n      if (name) expression.name = name;else pushCall(expression.args, args);\n    } else {\n      if (name) expressions.push(expression = {\n        name,\n        args: [undefined]\n      });else pushCall(expression.args, args);\n    }\n  }\n\n  return expressions;\n};\n\nconst pushCall = (array, args) => {\n  if (isTaggedTemplate(args)) {\n    array.push({\n      tag: args\n    });\n  } else {\n    if (args.length === 0) throw Error('Error: Expression call requires at least one argument');\n\n    for (let i = 0; i < args.length; ++i) {\n      array.push({\n        arg: args[i]\n      });\n    }\n  }\n};\n\nconst createCallsCompiler = expressionTable => (ctx, calls) => {\n  let exp;\n\n  for (let i = 0; i < calls.length; ++i) {\n    const {\n      name,\n      args\n    } = calls[i];\n    const {\n      build,\n      minArgs,\n      maxArgs\n    } = expressionTable[name];\n    if (i !== 0) args[0] = {\n      exp\n    };\n    const numArgs = args.length;\n    if (numArgs < minArgs) throw Error(`Error: ${name} requires at least ${minArgs} arguments`);\n    if (numArgs > maxArgs) throw Error(`Error: ${name} accepts at most ${maxArgs} arguments`);\n    exp = build(ctx, args);\n  }\n\n  return exp;\n};\n\nmodule.exports = createExpressionCompiler;","map":{"version":3,"sources":["/Volumes/LaCie/Dev/myProjects/movie-nite/node_modules/EasyQB/src/builder-expression/compile.js"],"names":["isTaggedTemplate","require","createExpressionCompiler","expressionTable","callsCompiler","createCallsCompiler","ctx","current","calls","buildCalls","text","args","params","type","prev","push","length","Error","expression","name","expressions","last","i","pushCall","undefined","array","tag","arg","exp","build","minArgs","maxArgs","numArgs","module","exports"],"mappings":"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","sourcesContent":["const { isTaggedTemplate } = require('../lib-util')\n\nconst createExpressionCompiler = expressionTable => {\n  const callsCompiler = createCallsCompiler(expressionTable)\n  return (ctx, current) => {\n    const calls = buildCalls(current)\n    const text = callsCompiler(ctx, calls)\n    return {\n      text,\n      args: ctx.params,\n      type: 'expression'\n    }\n  }\n}\n\n// TODO: Performance optimization:\n// inline expression building with this method so at most only one array\n// is allocated in total, no array of object containing arrays nonsense\nconst buildCalls = current => {\n  // get call nodes\n  const calls = []\n  for (; current; current = current.prev) calls.push(current)\n  if (calls.length === 0) throw Error('Error: Empty expression')\n\n  // build expression list\n  let expression = { name: 'arg', args: [] }\n  const expressions = [expression]\n  const last = calls.length - 1\n  for (let i = last; i >= 0; --i) {\n    const { name, args } = calls[i]\n    if (i === last) {\n      if (name) expression.name = name\n      else pushCall(expression.args, args)\n    } else {\n      if (name) expressions.push((expression = { name, args: [undefined] }))\n      else pushCall(expression.args, args)\n    }\n  }\n  return expressions\n}\n\nconst pushCall = (array, args) => {\n  if (isTaggedTemplate(args)) {\n    array.push({ tag: args })\n  } else {\n    if (args.length === 0)\n      throw Error('Error: Expression call requires at least one argument')\n    for (let i = 0; i < args.length; ++i) {\n      array.push({ arg: args[i] })\n    }\n  }\n}\n\nconst createCallsCompiler = expressionTable => (ctx, calls) => {\n  let exp\n  for (let i = 0; i < calls.length; ++i) {\n    const { name, args } = calls[i]\n    const { build, minArgs, maxArgs } = expressionTable[name]\n    if (i !== 0) args[0] = { exp }\n    const numArgs = args.length\n    if (numArgs < minArgs)\n      throw Error(`Error: ${name} requires at least ${minArgs} arguments`)\n    if (numArgs > maxArgs)\n      throw Error(`Error: ${name} accepts at most ${maxArgs} arguments`)\n    exp = build(ctx, args)\n  }\n  return exp\n}\n\nmodule.exports = createExpressionCompiler\n"]},"metadata":{},"sourceType":"script"}