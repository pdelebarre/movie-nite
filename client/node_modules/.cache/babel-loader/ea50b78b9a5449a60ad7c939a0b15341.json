{"ast":null,"code":"import React, { createContext, useState, useRef, Fragment, useEffect, useContext } from 'react';\nimport deepEqual from 'fast-deep-equal';\nimport easyqb from 'EasyQB';\nimport { Observable } from 'object-observer';\nimport Storage from 'react-native-storage';\nimport { callFunction as callFunction$1 } from 'easybasejs';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n} // A type of promise-like that resolves synchronously and supports only one observer\n\n\nconst _iteratorSymbol = /*#__PURE__*/typeof Symbol !== \"undefined\" ? Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\")) : \"@@iterator\";\n\nconst _asyncIteratorSymbol = /*#__PURE__*/typeof Symbol !== \"undefined\" ? Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\")) : \"@@asyncIterator\"; // Asynchronously call a function and send errors to recovery continuation\n\n\nfunction _catch(body, recover) {\n  try {\n    var result = body();\n  } catch (e) {\n    return recover(e);\n  }\n\n  if (result && result.then) {\n    return result.then(void 0, recover);\n  }\n\n  return result;\n}\n\nfunction Frame(index) {\n  return [];\n}\n\nvar c = {\n  configureFrame: function configureFrame(_) {\n    return {};\n  },\n  addRecord: function (_) {\n    return Promise.resolve({});\n  },\n  deleteRecord: function (_) {\n    return Promise.resolve({});\n  },\n  sync: function () {\n    return Promise.resolve({});\n  },\n  updateRecordImage: function (_) {\n    return Promise.resolve({});\n  },\n  updateRecordVideo: function (_) {\n    return Promise.resolve({});\n  },\n  updateRecordFile: function (_) {\n    return Promise.resolve({});\n  },\n  Frame: Frame,\n  useFrameEffect: function useFrameEffect(_) {},\n  fullTableSize: function () {\n    return Promise.resolve(0);\n  },\n  tableTypes: function () {\n    return Promise.resolve({});\n  },\n  currentConfiguration: function currentConfiguration() {\n    return {};\n  },\n  Query: function (_) {\n    return Promise.resolve([]);\n  },\n  getUserAttributes: function () {\n    return Promise.resolve({});\n  },\n  isUserSignedIn: function isUserSignedIn() {\n    return false;\n  },\n  setUserAttribute: function (_, _2) {\n    return Promise.resolve({});\n  },\n  resetUserPassword: function (_) {\n    return Promise.resolve({});\n  },\n  signIn: function (_, _2) {\n    return Promise.resolve({});\n  },\n  signOut: function signOut() {},\n  signUp: function (_, _2, _3) {\n    return Promise.resolve({});\n  },\n  onSignIn: function onSignIn(_) {},\n  db: function db(_) {\n    return {};\n  },\n  dbEventListener: function dbEventListener(_) {\n    return function () {};\n  },\n  useReturn: function useReturn(_) {\n    return {};\n  },\n  e: {}\n};\nvar EasybaseContext = createContext(c);\nvar POST_TYPES;\n\n(function (POST_TYPES) {\n  POST_TYPES[\"UPLOAD_ATTACHMENT\"] = \"upload_attachment\";\n  POST_TYPES[\"HANDSHAKE\"] = \"handshake\";\n  POST_TYPES[\"VALID_TOKEN\"] = \"valid_token\";\n  POST_TYPES[\"GET_FRAME\"] = \"get_frame\";\n  POST_TYPES[\"TABLE_SIZE\"] = \"table_size\";\n  POST_TYPES[\"COLUMN_TYPES\"] = \"column_types\";\n  POST_TYPES[\"SYNC_STACK\"] = \"sync_stack\";\n  POST_TYPES[\"SYNC_DELETE\"] = \"sync_delete\";\n  POST_TYPES[\"SYNC_INSERT\"] = \"sync_insert\";\n  POST_TYPES[\"GET_QUERY\"] = \"get_query\";\n  POST_TYPES[\"USER_ATTRIBUTES\"] = \"user_attributes\";\n  POST_TYPES[\"SET_ATTRIBUTE\"] = \"set_attribute\";\n  POST_TYPES[\"SIGN_UP\"] = \"sign_up\";\n  POST_TYPES[\"REQUEST_TOKEN\"] = \"request_token\";\n  POST_TYPES[\"EASY_QB\"] = \"easyqb\";\n  POST_TYPES[\"RESET_PASSWORD\"] = \"reset_password\";\n})(POST_TYPES || (POST_TYPES = {}));\n\nvar DB_STATUS;\n\n(function (DB_STATUS) {\n  DB_STATUS[\"ERROR\"] = \"error\";\n  DB_STATUS[\"PENDING\"] = \"pending\";\n  DB_STATUS[\"SUCCESS\"] = \"success\";\n})(DB_STATUS || (DB_STATUS = {}));\n\nvar EXECUTE_COUNT;\n\n(function (EXECUTE_COUNT) {\n  EXECUTE_COUNT[\"ALL\"] = \"all\";\n  EXECUTE_COUNT[\"ONE\"] = \"one\";\n})(EXECUTE_COUNT || (EXECUTE_COUNT = {}));\n\nvar imageExtensions = [\"ase\", \"art\", \"bmp\", \"blp\", \"cd5\", \"cit\", \"cpt\", \"cr2\", \"cut\", \"dds\", \"dib\", \"djvu\", \"egt\", \"exif\", \"gif\", \"gpl\", \"grf\", \"icns\", \"ico\", \"iff\", \"jng\", \"jpeg\", \"jpg\", \"jfif\", \"jp2\", \"jps\", \"lbm\", \"max\", \"miff\", \"mng\", \"msp\", \"nitf\", \"ota\", \"pbm\", \"pc1\", \"pc2\", \"pc3\", \"pcf\", \"pcx\", \"pdn\", \"pgm\", \"PI1\", \"PI2\", \"PI3\", \"pict\", \"pct\", \"pnm\", \"pns\", \"ppm\", \"psb\", \"psd\", \"pdd\", \"psp\", \"px\", \"pxm\", \"pxr\", \"qfx\", \"raw\", \"rle\", \"sct\", \"sgi\", \"rgb\", \"int\", \"bw\", \"tga\", \"tiff\", \"tif\", \"vtf\", \"xbm\", \"xcf\", \"xpm\", \"3dv\", \"amf\", \"ai\", \"awg\", \"cgm\", \"cdr\", \"cmx\", \"dxf\", \"e2d\", \"egt\", \"eps\", \"fs\", \"gbr\", \"odg\", \"svg\", \"stl\", \"vrml\", \"x3d\", \"sxd\", \"v2d\", \"vnd\", \"wmf\", \"emf\", \"art\", \"xar\", \"png\", \"webp\", \"jxr\", \"hdp\", \"wdp\", \"cur\", \"ecw\", \"iff\", \"lbm\", \"liff\", \"nrrd\", \"pam\", \"pcx\", \"pgf\", \"sgi\", \"rgb\", \"rgba\", \"bw\", \"int\", \"inta\", \"sid\", \"ras\", \"sun\", \"tga\"];\nvar videoExtensions = [\"3g2\", \"3gp\", \"aaf\", \"asf\", \"avchd\", \"avi\", \"drc\", \"flv\", \"m2v\", \"m4p\", \"m4v\", \"mkv\", \"mng\", \"mov\", \"mp2\", \"mp4\", \"mpe\", \"mpeg\", \"mpg\", \"mpv\", \"mxf\", \"nsv\", \"ogg\", \"ogv\", \"qt\", \"rm\", \"rmvb\", \"roq\", \"svi\", \"vob\", \"webm\", \"wmv\", \"yuv\"];\nvar GlobalNamespace;\n\n(function (GlobalNamespace) {})(GlobalNamespace || (GlobalNamespace = {}));\n\nconst _g = { ...GlobalNamespace\n};\n\nfunction gFactory() {\n  return { ...GlobalNamespace\n  };\n}\n\nfunction utilsFactory(globals) {\n  const g = globals || _g;\n\n  const generateBareUrl = (type, integrationID) => `https://api.easybase.io/${type}/${integrationID}`;\n\n  const generateAuthBody = () => {\n    const stamp = Date.now();\n    return {\n      token: g.token,\n      token_time: ~~(g.session / (stamp % 64)),\n      now: stamp\n    };\n  };\n\n  function log(...params) {\n    if (g.options.logging) {\n      console.log(\"EASYBASE â€” \", ...params);\n    }\n  }\n\n  return {\n    generateAuthBody,\n    generateBareUrl,\n    log\n  };\n}\n\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nfunction unwrapExports(x) {\n  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nfunction createCommonjsModule(fn, module) {\n  return module = {\n    exports: {}\n  }, fn(module, module.exports), module.exports;\n}\n\nvar browserPonyfill = createCommonjsModule(function (module, exports) {\n  var global = typeof self !== 'undefined' ? self : commonjsGlobal;\n\n  var __self__ = function () {\n    function F() {\n      this.fetch = false;\n      this.DOMException = global.DOMException;\n    }\n\n    F.prototype = global;\n    return new F();\n  }();\n\n  (function (self) {\n    var irrelevant = function (exports) {\n      var support = {\n        searchParams: 'URLSearchParams' in self,\n        iterable: 'Symbol' in self && 'iterator' in Symbol,\n        blob: 'FileReader' in self && 'Blob' in self && function () {\n          try {\n            new Blob();\n            return true;\n          } catch (e) {\n            return false;\n          }\n        }(),\n        formData: 'FormData' in self,\n        arrayBuffer: 'ArrayBuffer' in self\n      };\n\n      function isDataView(obj) {\n        return obj && DataView.prototype.isPrototypeOf(obj);\n      }\n\n      if (support.arrayBuffer) {\n        var viewClasses = ['[object Int8Array]', '[object Uint8Array]', '[object Uint8ClampedArray]', '[object Int16Array]', '[object Uint16Array]', '[object Int32Array]', '[object Uint32Array]', '[object Float32Array]', '[object Float64Array]'];\n\n        var isArrayBufferView = ArrayBuffer.isView || function (obj) {\n          return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;\n        };\n      }\n\n      function normalizeName(name) {\n        if (typeof name !== 'string') {\n          name = String(name);\n        }\n\n        if (/[^a-z0-9\\-#$%&'*+.^_`|~]/i.test(name)) {\n          throw new TypeError('Invalid character in header field name');\n        }\n\n        return name.toLowerCase();\n      }\n\n      function normalizeValue(value) {\n        if (typeof value !== 'string') {\n          value = String(value);\n        }\n\n        return value;\n      } // Build a destructive iterator for the value list\n\n\n      function iteratorFor(items) {\n        var iterator = {\n          next: function () {\n            var value = items.shift();\n            return {\n              done: value === undefined,\n              value: value\n            };\n          }\n        };\n\n        if (support.iterable) {\n          iterator[Symbol.iterator] = function () {\n            return iterator;\n          };\n        }\n\n        return iterator;\n      }\n\n      function Headers(headers) {\n        this.map = {};\n\n        if (headers instanceof Headers) {\n          headers.forEach(function (value, name) {\n            this.append(name, value);\n          }, this);\n        } else if (Array.isArray(headers)) {\n          headers.forEach(function (header) {\n            this.append(header[0], header[1]);\n          }, this);\n        } else if (headers) {\n          Object.getOwnPropertyNames(headers).forEach(function (name) {\n            this.append(name, headers[name]);\n          }, this);\n        }\n      }\n\n      Headers.prototype.append = function (name, value) {\n        name = normalizeName(name);\n        value = normalizeValue(value);\n        var oldValue = this.map[name];\n        this.map[name] = oldValue ? oldValue + ', ' + value : value;\n      };\n\n      Headers.prototype['delete'] = function (name) {\n        delete this.map[normalizeName(name)];\n      };\n\n      Headers.prototype.get = function (name) {\n        name = normalizeName(name);\n        return this.has(name) ? this.map[name] : null;\n      };\n\n      Headers.prototype.has = function (name) {\n        return this.map.hasOwnProperty(normalizeName(name));\n      };\n\n      Headers.prototype.set = function (name, value) {\n        this.map[normalizeName(name)] = normalizeValue(value);\n      };\n\n      Headers.prototype.forEach = function (callback, thisArg) {\n        for (var name in this.map) {\n          if (this.map.hasOwnProperty(name)) {\n            callback.call(thisArg, this.map[name], name, this);\n          }\n        }\n      };\n\n      Headers.prototype.keys = function () {\n        var items = [];\n        this.forEach(function (value, name) {\n          items.push(name);\n        });\n        return iteratorFor(items);\n      };\n\n      Headers.prototype.values = function () {\n        var items = [];\n        this.forEach(function (value) {\n          items.push(value);\n        });\n        return iteratorFor(items);\n      };\n\n      Headers.prototype.entries = function () {\n        var items = [];\n        this.forEach(function (value, name) {\n          items.push([name, value]);\n        });\n        return iteratorFor(items);\n      };\n\n      if (support.iterable) {\n        Headers.prototype[Symbol.iterator] = Headers.prototype.entries;\n      }\n\n      function consumed(body) {\n        if (body.bodyUsed) {\n          return Promise.reject(new TypeError('Already read'));\n        }\n\n        body.bodyUsed = true;\n      }\n\n      function fileReaderReady(reader) {\n        return new Promise(function (resolve, reject) {\n          reader.onload = function () {\n            resolve(reader.result);\n          };\n\n          reader.onerror = function () {\n            reject(reader.error);\n          };\n        });\n      }\n\n      function readBlobAsArrayBuffer(blob) {\n        var reader = new FileReader();\n        var promise = fileReaderReady(reader);\n        reader.readAsArrayBuffer(blob);\n        return promise;\n      }\n\n      function readBlobAsText(blob) {\n        var reader = new FileReader();\n        var promise = fileReaderReady(reader);\n        reader.readAsText(blob);\n        return promise;\n      }\n\n      function readArrayBufferAsText(buf) {\n        var view = new Uint8Array(buf);\n        var chars = new Array(view.length);\n\n        for (var i = 0; i < view.length; i++) {\n          chars[i] = String.fromCharCode(view[i]);\n        }\n\n        return chars.join('');\n      }\n\n      function bufferClone(buf) {\n        if (buf.slice) {\n          return buf.slice(0);\n        } else {\n          var view = new Uint8Array(buf.byteLength);\n          view.set(new Uint8Array(buf));\n          return view.buffer;\n        }\n      }\n\n      function Body() {\n        this.bodyUsed = false;\n\n        this._initBody = function (body) {\n          this._bodyInit = body;\n\n          if (!body) {\n            this._bodyText = '';\n          } else if (typeof body === 'string') {\n            this._bodyText = body;\n          } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n            this._bodyBlob = body;\n          } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n            this._bodyFormData = body;\n          } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n            this._bodyText = body.toString();\n          } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n            this._bodyArrayBuffer = bufferClone(body.buffer); // IE 10-11 can't handle a DataView body.\n\n            this._bodyInit = new Blob([this._bodyArrayBuffer]);\n          } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n            this._bodyArrayBuffer = bufferClone(body);\n          } else {\n            this._bodyText = body = Object.prototype.toString.call(body);\n          }\n\n          if (!this.headers.get('content-type')) {\n            if (typeof body === 'string') {\n              this.headers.set('content-type', 'text/plain;charset=UTF-8');\n            } else if (this._bodyBlob && this._bodyBlob.type) {\n              this.headers.set('content-type', this._bodyBlob.type);\n            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n              this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');\n            }\n          }\n        };\n\n        if (support.blob) {\n          this.blob = function () {\n            var rejected = consumed(this);\n\n            if (rejected) {\n              return rejected;\n            }\n\n            if (this._bodyBlob) {\n              return Promise.resolve(this._bodyBlob);\n            } else if (this._bodyArrayBuffer) {\n              return Promise.resolve(new Blob([this._bodyArrayBuffer]));\n            } else if (this._bodyFormData) {\n              throw new Error('could not read FormData body as blob');\n            } else {\n              return Promise.resolve(new Blob([this._bodyText]));\n            }\n          };\n\n          this.arrayBuffer = function () {\n            if (this._bodyArrayBuffer) {\n              return consumed(this) || Promise.resolve(this._bodyArrayBuffer);\n            } else {\n              return this.blob().then(readBlobAsArrayBuffer);\n            }\n          };\n        }\n\n        this.text = function () {\n          var rejected = consumed(this);\n\n          if (rejected) {\n            return rejected;\n          }\n\n          if (this._bodyBlob) {\n            return readBlobAsText(this._bodyBlob);\n          } else if (this._bodyArrayBuffer) {\n            return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));\n          } else if (this._bodyFormData) {\n            throw new Error('could not read FormData body as text');\n          } else {\n            return Promise.resolve(this._bodyText);\n          }\n        };\n\n        if (support.formData) {\n          this.formData = function () {\n            return this.text().then(decode);\n          };\n        }\n\n        this.json = function () {\n          return this.text().then(JSON.parse);\n        };\n\n        return this;\n      } // HTTP methods whose capitalization should be normalized\n\n\n      var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];\n\n      function normalizeMethod(method) {\n        var upcased = method.toUpperCase();\n        return methods.indexOf(upcased) > -1 ? upcased : method;\n      }\n\n      function Request(input, options) {\n        options = options || {};\n        var body = options.body;\n\n        if (input instanceof Request) {\n          if (input.bodyUsed) {\n            throw new TypeError('Already read');\n          }\n\n          this.url = input.url;\n          this.credentials = input.credentials;\n\n          if (!options.headers) {\n            this.headers = new Headers(input.headers);\n          }\n\n          this.method = input.method;\n          this.mode = input.mode;\n          this.signal = input.signal;\n\n          if (!body && input._bodyInit != null) {\n            body = input._bodyInit;\n            input.bodyUsed = true;\n          }\n        } else {\n          this.url = String(input);\n        }\n\n        this.credentials = options.credentials || this.credentials || 'same-origin';\n\n        if (options.headers || !this.headers) {\n          this.headers = new Headers(options.headers);\n        }\n\n        this.method = normalizeMethod(options.method || this.method || 'GET');\n        this.mode = options.mode || this.mode || null;\n        this.signal = options.signal || this.signal;\n        this.referrer = null;\n\n        if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n          throw new TypeError('Body not allowed for GET or HEAD requests');\n        }\n\n        this._initBody(body);\n      }\n\n      Request.prototype.clone = function () {\n        return new Request(this, {\n          body: this._bodyInit\n        });\n      };\n\n      function decode(body) {\n        var form = new FormData();\n        body.trim().split('&').forEach(function (bytes) {\n          if (bytes) {\n            var split = bytes.split('=');\n            var name = split.shift().replace(/\\+/g, ' ');\n            var value = split.join('=').replace(/\\+/g, ' ');\n            form.append(decodeURIComponent(name), decodeURIComponent(value));\n          }\n        });\n        return form;\n      }\n\n      function parseHeaders(rawHeaders) {\n        var headers = new Headers(); // Replace instances of \\r\\n and \\n followed by at least one space or horizontal tab with a space\n        // https://tools.ietf.org/html/rfc7230#section-3.2\n\n        var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, ' ');\n        preProcessedHeaders.split(/\\r?\\n/).forEach(function (line) {\n          var parts = line.split(':');\n          var key = parts.shift().trim();\n\n          if (key) {\n            var value = parts.join(':').trim();\n            headers.append(key, value);\n          }\n        });\n        return headers;\n      }\n\n      Body.call(Request.prototype);\n\n      function Response(bodyInit, options) {\n        if (!options) {\n          options = {};\n        }\n\n        this.type = 'default';\n        this.status = options.status === undefined ? 200 : options.status;\n        this.ok = this.status >= 200 && this.status < 300;\n        this.statusText = 'statusText' in options ? options.statusText : 'OK';\n        this.headers = new Headers(options.headers);\n        this.url = options.url || '';\n\n        this._initBody(bodyInit);\n      }\n\n      Body.call(Response.prototype);\n\n      Response.prototype.clone = function () {\n        return new Response(this._bodyInit, {\n          status: this.status,\n          statusText: this.statusText,\n          headers: new Headers(this.headers),\n          url: this.url\n        });\n      };\n\n      Response.error = function () {\n        var response = new Response(null, {\n          status: 0,\n          statusText: ''\n        });\n        response.type = 'error';\n        return response;\n      };\n\n      var redirectStatuses = [301, 302, 303, 307, 308];\n\n      Response.redirect = function (url, status) {\n        if (redirectStatuses.indexOf(status) === -1) {\n          throw new RangeError('Invalid status code');\n        }\n\n        return new Response(null, {\n          status: status,\n          headers: {\n            location: url\n          }\n        });\n      };\n\n      exports.DOMException = self.DOMException;\n\n      try {\n        new exports.DOMException();\n      } catch (err) {\n        exports.DOMException = function (message, name) {\n          this.message = message;\n          this.name = name;\n          var error = Error(message);\n          this.stack = error.stack;\n        };\n\n        exports.DOMException.prototype = Object.create(Error.prototype);\n        exports.DOMException.prototype.constructor = exports.DOMException;\n      }\n\n      function fetch(input, init) {\n        return new Promise(function (resolve, reject) {\n          var request = new Request(input, init);\n\n          if (request.signal && request.signal.aborted) {\n            return reject(new exports.DOMException('Aborted', 'AbortError'));\n          }\n\n          var xhr = new XMLHttpRequest();\n\n          function abortXhr() {\n            xhr.abort();\n          }\n\n          xhr.onload = function () {\n            var options = {\n              status: xhr.status,\n              statusText: xhr.statusText,\n              headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n            };\n            options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');\n            var body = 'response' in xhr ? xhr.response : xhr.responseText;\n            resolve(new Response(body, options));\n          };\n\n          xhr.onerror = function () {\n            reject(new TypeError('Network request failed'));\n          };\n\n          xhr.ontimeout = function () {\n            reject(new TypeError('Network request failed'));\n          };\n\n          xhr.onabort = function () {\n            reject(new exports.DOMException('Aborted', 'AbortError'));\n          };\n\n          xhr.open(request.method, request.url, true);\n\n          if (request.credentials === 'include') {\n            xhr.withCredentials = true;\n          } else if (request.credentials === 'omit') {\n            xhr.withCredentials = false;\n          }\n\n          if ('responseType' in xhr && support.blob) {\n            xhr.responseType = 'blob';\n          }\n\n          request.headers.forEach(function (value, name) {\n            xhr.setRequestHeader(name, value);\n          });\n\n          if (request.signal) {\n            request.signal.addEventListener('abort', abortXhr);\n\n            xhr.onreadystatechange = function () {\n              // DONE (success or failure)\n              if (xhr.readyState === 4) {\n                request.signal.removeEventListener('abort', abortXhr);\n              }\n            };\n          }\n\n          xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);\n        });\n      }\n\n      fetch.polyfill = true;\n\n      if (!self.fetch) {\n        self.fetch = fetch;\n        self.Headers = Headers;\n        self.Request = Request;\n        self.Response = Response;\n      }\n\n      exports.Headers = Headers;\n      exports.Request = Request;\n      exports.Response = Response;\n      exports.fetch = fetch;\n      Object.defineProperty(exports, '__esModule', {\n        value: true\n      });\n      return exports;\n    }({});\n  })(__self__);\n\n  __self__.fetch.ponyfill = true; // Remove \"polyfill\" property added by whatwg-fetch\n\n  delete __self__.fetch.polyfill; // Choose between native implementation (global) or custom implementation (__self__)\n  // var ctx = global.fetch ? global : __self__;\n\n  var ctx = __self__; // this line disable service worker support temporarily\n\n  exports = ctx.fetch; // To enable: import fetch from 'cross-fetch'\n\n  exports.default = ctx.fetch; // For TypeScript consumers without esModuleInterop.\n\n  exports.fetch = ctx.fetch; // To enable: import {fetch} from 'cross-fetch'\n\n  exports.Headers = ctx.Headers;\n  exports.Request = ctx.Request;\n  exports.Response = ctx.Response;\n  module.exports = exports;\n});\nvar fetch = unwrapExports(browserPonyfill);\n\nfunction authFactory(globals) {\n  const g = globals || _g;\n  const {\n    generateBareUrl,\n    generateAuthBody,\n    log\n  } = utilsFactory(g);\n\n  const getUserAttributes = async () => {\n    try {\n      const attrsRes = await tokenPost(POST_TYPES.USER_ATTRIBUTES);\n      return attrsRes.data;\n    } catch (error) {\n      return error;\n    }\n  };\n\n  const setUserAttribute = async (key, value) => {\n    try {\n      const setAttrsRes = await tokenPost(POST_TYPES.SET_ATTRIBUTE, {\n        key,\n        value\n      });\n      return {\n        success: setAttrsRes.success,\n        message: JSON.stringify(setAttrsRes.data)\n      };\n    } catch (error) {\n      return {\n        success: false,\n        message: \"Error\",\n        error\n      };\n    }\n  };\n\n  const signUp = async (newUserID, password, userAttributes) => {\n    try {\n      const signUpRes = await tokenPost(POST_TYPES.SIGN_UP, {\n        newUserID,\n        password,\n        userAttributes\n      });\n      return {\n        success: signUpRes.success,\n        message: signUpRes.data\n      };\n    } catch (error) {\n      return {\n        success: false,\n        message: \"Error\",\n        error\n      };\n    }\n  };\n\n  const signIn = async (userID, password) => {\n    const t1 = Date.now();\n    g.session = Math.floor(100000000 + Math.random() * 900000000);\n    const integrationType = g.ebconfig.integration.split(\"-\")[0].toUpperCase() === \"PROJECT\" ? \"PROJECT\" : \"REACT\";\n\n    try {\n      const res = await fetch(generateBareUrl(integrationType, g.integrationID), {\n        method: \"POST\",\n        headers: {\n          'Eb-Post-Req': POST_TYPES.HANDSHAKE,\n          'Accept': 'application/json',\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          version: g.ebconfig.version,\n          session: g.session,\n          instance: g.instance,\n          userID,\n          password\n        })\n      });\n      const resData = await res.json();\n\n      if (resData.token) {\n        g.token = resData.token;\n        g.refreshToken = resData.refreshToken;\n        g.newTokenCallback();\n        g.mounted = true;\n        const validTokenRes = await tokenPost(POST_TYPES.VALID_TOKEN);\n        const elapsed = Date.now() - t1;\n\n        if (validTokenRes.success) {\n          log(\"Valid auth initiation in \" + elapsed + \"ms\");\n          return {\n            success: true,\n            message: \"Successfully signed in user\"\n          };\n        } else {\n          return {\n            success: false,\n            message: \"Could not sign in user\"\n          };\n        }\n      } else {\n        return {\n          success: false,\n          message: \"Could not sign in user\"\n        };\n      }\n    } catch (error) {\n      console.error(error);\n      return {\n        success: false,\n        message: error,\n        error\n      };\n    }\n  };\n\n  const resetUserPassword = async newPassword => {\n    if (typeof newPassword !== \"string\" || newPassword.length > 100) {\n      return {\n        success: false,\n        message: \"newPassword must be of type string\"\n      };\n    }\n\n    try {\n      const setAttrsRes = await tokenPost(POST_TYPES.RESET_PASSWORD, {\n        newPassword\n      });\n      return {\n        success: setAttrsRes.success,\n        message: JSON.stringify(setAttrsRes.data)\n      };\n    } catch (error) {\n      return {\n        success: false,\n        message: \"Error\",\n        error\n      };\n    }\n  };\n\n  const isUserSignedIn = () => g.token.length > 0;\n\n  const signOut = () => {\n    g.token = \"\";\n    g.newTokenCallback();\n  };\n\n  const initAuth = async () => {\n    const t1 = Date.now();\n    g.session = Math.floor(100000000 + Math.random() * 900000000);\n    log(`Handshaking on${g.instance} instance`);\n    const integrationType = g.ebconfig.integration.split(\"-\")[0].toUpperCase() === \"PROJECT\" ? \"PROJECT\" : \"REACT\";\n\n    try {\n      const res = await fetch(generateBareUrl(integrationType, g.integrationID), {\n        method: \"POST\",\n        headers: {\n          'Eb-Post-Req': POST_TYPES.HANDSHAKE,\n          'Accept': 'application/json',\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          version: g.ebconfig.version,\n          tt: g.ebconfig.tt,\n          session: g.session,\n          instance: g.instance\n        })\n      });\n      const resData = await res.json();\n\n      if (resData.token) {\n        g.token = resData.token;\n        g.mounted = true;\n        const validTokenRes = await tokenPost(POST_TYPES.VALID_TOKEN);\n        const elapsed = Date.now() - t1;\n\n        if (validTokenRes.success) {\n          log(\"Valid auth initiation in \" + elapsed + \"ms\");\n          return true;\n        } else {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    } catch (error) {\n      console.error(error);\n      return false;\n    }\n  };\n\n  const tokenPost = async (postType, body) => {\n    if (!g.mounted) {\n      await initAuth();\n    }\n\n    const integrationType = g.ebconfig.integration.split(\"-\")[0].toUpperCase() === \"PROJECT\" ? \"PROJECT\" : \"REACT\";\n\n    try {\n      const res = await fetch(generateBareUrl(integrationType, g.integrationID), {\n        method: \"POST\",\n        headers: {\n          'Eb-Post-Req': postType,\n          'Accept': 'application/json',\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          _auth: generateAuthBody(),\n          ...body\n        })\n      });\n      const resData = await res.json();\n\n      if ({}.hasOwnProperty.call(resData, 'ErrorCode') || {}.hasOwnProperty.call(resData, 'code')) {\n        if (resData.code === \"JWT EXPIRED\") {\n          if (integrationType === \"PROJECT\") {\n            const req_res = await tokenPost(POST_TYPES.REQUEST_TOKEN, {\n              refreshToken: g.refreshToken,\n              token: g.token\n            });\n\n            if (req_res.success) {\n              g.token = req_res.data.token;\n              g.newTokenCallback();\n              return tokenPost(postType, body);\n            } else {\n              g.token = \"\";\n              g.refreshToken = \"\";\n              g.newTokenCallback();\n              return {\n                success: false,\n                data: req_res.data\n              };\n            }\n          } else {\n            await initAuth();\n          }\n\n          return tokenPost(postType, body);\n        }\n\n        return {\n          success: false,\n          data: resData.body\n        };\n      } else {\n        return {\n          success: resData.success,\n          data: resData.body\n        };\n      }\n    } catch (error) {\n      return {\n        success: false,\n        data: error\n      };\n    }\n  };\n\n  const tokenPostAttachment = async (formData, customHeaders) => {\n    if (!g.mounted) {\n      await initAuth();\n    }\n\n    const regularAuthbody = generateAuthBody();\n    const attachmentAuth = {\n      'Eb-token': regularAuthbody.token,\n      'Eb-token-time': regularAuthbody.token_time,\n      'Eb-now': regularAuthbody.now\n    };\n    const integrationType = g.ebconfig.integration.split(\"-\")[0].toUpperCase() === \"PROJECT\" ? \"PROJECT\" : \"REACT\";\n\n    try {\n      const res = await fetch(generateBareUrl(integrationType, g.integrationID), {\n        method: \"POST\",\n        headers: {\n          'Eb-Post-Req': POST_TYPES.UPLOAD_ATTACHMENT,\n          ...customHeaders,\n          ...attachmentAuth\n        },\n        body: formData\n      });\n      const resData = await res.json();\n\n      if ({}.hasOwnProperty.call(resData, 'ErrorCode') || {}.hasOwnProperty.call(resData, 'code')) {\n        if (resData.code === \"JWT EXPIRED\") {\n          if (integrationType === \"PROJECT\") {\n            const req_res = await tokenPost(POST_TYPES.REQUEST_TOKEN, {\n              refreshToken: g.refreshToken,\n              token: g.token\n            });\n\n            if (req_res.success) {\n              g.token = req_res.data.token;\n              g.newTokenCallback();\n              return tokenPostAttachment(formData, customHeaders);\n            } else {\n              g.token = \"\";\n              g.refreshToken = \"\";\n              g.newTokenCallback();\n              return {\n                success: false,\n                data: req_res.data\n              };\n            }\n          } else {\n            await initAuth();\n          }\n\n          return tokenPostAttachment(formData, customHeaders);\n        }\n\n        return {\n          success: false,\n          data: resData.body\n        };\n      } else {\n        return {\n          success: resData.success,\n          data: resData.body\n        };\n      }\n    } catch (error) {\n      return {\n        success: false,\n        data: error\n      };\n    }\n  };\n\n  return {\n    initAuth,\n    tokenPost,\n    tokenPostAttachment,\n    signUp,\n    setUserAttribute,\n    getUserAttributes,\n    isUserSignedIn,\n    signIn,\n    signOut,\n    resetUserPassword\n  };\n}\n\nfunction tableFactory(globals) {\n  const g = globals || _g;\n  const {\n    tokenPost\n  } = authFactory(g);\n\n  const Query = async options => {\n    const defaultOptions = {\n      queryName: \"\"\n    };\n    const fullOptions = { ...defaultOptions,\n      ...options\n    };\n\n    try {\n      const res = await tokenPost(POST_TYPES.GET_QUERY, fullOptions);\n      return res.data;\n    } catch (error) {\n      return [];\n    }\n  };\n\n  async function fullTableSize(tableName) {\n    const res = await tokenPost(POST_TYPES.TABLE_SIZE, tableName ? {\n      tableName\n    } : {});\n\n    if (res.success) {\n      return res.data;\n    } else {\n      return 0;\n    }\n  }\n\n  async function tableTypes(tableName) {\n    const res = await tokenPost(POST_TYPES.COLUMN_TYPES, tableName ? {\n      tableName\n    } : {});\n\n    if (res.success) {\n      return res.data;\n    } else {\n      return {};\n    }\n  }\n\n  return {\n    Query,\n    fullTableSize,\n    tableTypes\n  };\n}\n\nfunction dbFactory(globals) {\n  const g = globals || _g;\n  const {\n    tokenPost\n  } = authFactory(g);\n  let _listenerIndex = 0;\n  const _listeners = {};\n\n  function _runListeners(...params) {\n    for (const cb of Object.values(_listeners)) {\n      cb(...params);\n    }\n  }\n\n  const dbEventListener = callback => {\n    const currKey = '' + _listenerIndex++;\n    _listeners[currKey] = callback;\n    return () => {\n      delete _listeners[currKey];\n    };\n  };\n\n  const allCallback = async (trx, tableName, userAssociatedRecordsOnly) => {\n    trx.count = \"all\";\n    trx.tableName = tableName;\n    if (userAssociatedRecordsOnly) trx.userAssociatedRecordsOnly = userAssociatedRecordsOnly;\n\n    _runListeners(DB_STATUS.PENDING, trx.type, EXECUTE_COUNT.ALL, tableName !== \"untable\" ? tableName : null);\n\n    const res = await tokenPost(POST_TYPES.EASY_QB, trx);\n\n    if (res.success) {\n      _runListeners(DB_STATUS.SUCCESS, trx.type, EXECUTE_COUNT.ALL, tableName !== \"untable\" ? tableName : null, res.data);\n\n      return res.data;\n    } else {\n      _runListeners(DB_STATUS.ERROR, trx.type, EXECUTE_COUNT.ALL, tableName !== \"untable\" ? tableName : null);\n\n      return res;\n    }\n  };\n\n  const oneCallback = async (trx, tableName, userAssociatedRecordsOnly) => {\n    trx.count = \"one\";\n    trx.tableName = tableName;\n    if (userAssociatedRecordsOnly) trx.userAssociatedRecordsOnly = userAssociatedRecordsOnly;\n\n    _runListeners(DB_STATUS.PENDING, trx.type, EXECUTE_COUNT.ONE, tableName !== \"untable\" ? tableName : null);\n\n    const res = await tokenPost(POST_TYPES.EASY_QB, trx);\n\n    if (res.success) {\n      _runListeners(DB_STATUS.SUCCESS, trx.type, EXECUTE_COUNT.ONE, tableName !== \"untable\" ? tableName : null, res.data);\n\n      return res.data;\n    } else {\n      _runListeners(DB_STATUS.ERROR, trx.type, EXECUTE_COUNT.ONE, tableName !== \"untable\" ? tableName : null);\n\n      return res;\n    }\n  };\n\n  const db = (tableName, userAssociatedRecordsOnly) => {\n    if (tableName && typeof tableName === \"string\") {\n      return easyqb({\n        allCallback,\n        oneCallback,\n        userAssociatedRecordsOnly,\n        tableName: tableName.toUpperCase()\n      })(tableName.replace(/[^0-9a-zA-Z]/g, '_').toUpperCase());\n    } else {\n      return easyqb({\n        allCallback,\n        oneCallback,\n        userAssociatedRecordsOnly,\n        tableName: \"untable\"\n      })(\"untable\");\n    }\n  };\n\n  return {\n    db,\n    dbEventListener,\n    e: easyqb().e\n  };\n}\n\nvar setCacheTokens = function setCacheTokens(g, cookieName) {\n  try {\n    return Promise.resolve(storage.save({\n      key: cookieName + \"token\",\n      data: g.token,\n      expires: 3600 * 1000 * 24\n    })).then(function () {\n      return Promise.resolve(storage.save({\n        key: cookieName + \"refreshToken\",\n        data: g.refreshToken,\n        expires: 3600 * 1000 * 24\n      })).then(function () {\n        return Promise.resolve(storage.save({\n          key: cookieName + \"session\",\n          data: g.session,\n          expires: null\n        })).then(function () {});\n      });\n    });\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\n\nvar clearCacheTokens = function clearCacheTokens(cookieName) {\n  try {\n    return Promise.resolve(storage.remove({\n      key: cookieName + \"token\"\n    })).then(function () {\n      return Promise.resolve(storage.remove({\n        key: cookieName + \"refreshToken\"\n      })).then(function () {\n        return Promise.resolve(storage.remove({\n          key: cookieName + \"session\"\n        })).then(function () {});\n      });\n    });\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\n\nvar getCacheTokens = function getCacheTokens(cookieName) {\n  try {\n    var _temp7 = function _temp7() {\n      function _temp4() {\n        function _temp2() {\n          return {\n            cacheToken: cacheToken,\n            cacheRefreshToken: cacheRefreshToken,\n            cacheSession: cacheSession\n          };\n        }\n\n        var _temp = _catch(function () {\n          return Promise.resolve(storage.load({\n            key: cookieName + \"session\"\n          })).then(function (_storage$load3) {\n            cacheSession = _storage$load3;\n          });\n        }, function () {});\n\n        return _temp && _temp.then ? _temp.then(_temp2) : _temp2(_temp);\n      }\n\n      var _temp3 = _catch(function () {\n        return Promise.resolve(storage.load({\n          key: cookieName + \"refreshToken\"\n        })).then(function (_storage$load2) {\n          cacheRefreshToken = _storage$load2;\n        });\n      }, function () {});\n\n      return _temp3 && _temp3.then ? _temp3.then(_temp4) : _temp4(_temp3);\n    };\n\n    var cacheToken = false;\n    var cacheRefreshToken = false;\n    var cacheSession = false;\n\n    var _temp8 = _catch(function () {\n      return Promise.resolve(storage.load({\n        key: cookieName + \"token\"\n      })).then(function (_storage$load) {\n        cacheToken = _storage$load;\n      });\n    }, function () {});\n\n    return Promise.resolve(_temp8 && _temp8.then ? _temp8.then(_temp7) : _temp7(_temp8));\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\n\nvar storage;\n\nif (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {\n  import('@react-native-community/async-storage').then(function (AsyncStorage) {\n    storage = new Storage({\n      storageBackend: AsyncStorage[\"default\"]\n    });\n  });\n} else {\n  storage = new Storage({\n    storageBackend: window.localStorage\n  });\n}\n\nvar g = gFactory();\n\nvar _authFactory = authFactory(g),\n    initAuth = _authFactory.initAuth,\n    tokenPost = _authFactory.tokenPost,\n    tokenPostAttachment = _authFactory.tokenPostAttachment,\n    signUp = _authFactory.signUp,\n    setUserAttribute = _authFactory.setUserAttribute,\n    getUserAttributes = _authFactory.getUserAttributes,\n    resetUserPassword = _authFactory.resetUserPassword,\n    signIn = _authFactory.signIn,\n    signOut = _authFactory.signOut;\n\nvar _utilsFactory = utilsFactory(g),\n    log = _utilsFactory.log;\n\nvar _tableFactory = tableFactory(g),\n    Query = _tableFactory.Query,\n    fullTableSize = _tableFactory.fullTableSize,\n    tableTypes = _tableFactory.tableTypes;\n\nvar _dbFactory = dbFactory(g),\n    db = _dbFactory.db,\n    dbEventListener = _dbFactory.dbEventListener,\n    e = _dbFactory.e;\n\nvar _isFrameInitialized = true;\nvar _frameConfiguration = {\n  offset: 0,\n  limit: 0\n};\n\nvar _effect = function _effect() {\n  return function () {};\n};\n\nvar _signInCallback;\n\nvar _observedChangeStack = [];\n\nvar _recordIdMap = new WeakMap();\n\nvar _proxyRecordMap = new WeakMap();\n\nvar EasybaseProvider = function EasybaseProvider(_ref) {\n  var children = _ref.children,\n      ebconfig = _ref.ebconfig,\n      options = _ref.options;\n\n  var _useState = useState(false),\n      mounted = _useState[0],\n      setMounted = _useState[1];\n\n  var _useState2 = useState(false),\n      isSyncing = _useState2[0],\n      setIsSyncing = _useState2[1];\n\n  var _useState3 = useState(false),\n      userSignedIn = _useState3[0],\n      setUserSignedIn = _useState3[1];\n\n  var _useState4 = useState([]),\n      _frame = _useState4[0],\n      _setFrame = _useState4[1];\n\n  var _useState5 = useState({\n    observe: function observe() {},\n    unobserve: function unobserve() {}\n  }),\n      _observableFrame = _useState5[0],\n      _setObservableFrame = _useState5[1];\n\n  var _ranSignInCallback = useRef(false);\n\n  if (typeof ebconfig !== 'object' || ebconfig === null || ebconfig === undefined) {\n    console.error(\"No ebconfig object passed. do `import ebconfig from \\\"ebconfig.json\\\"` and pass it to the Easybase provider\");\n    return React.createElement(Fragment, null, children);\n  } else if (!ebconfig.integration) {\n    console.error(\"Invalid ebconfig object passed. Download ebconfig.json from Easybase.io and try again.\");\n    return React.createElement(Fragment, null, children);\n  }\n\n  useEffect(function () {\n    var mount = function mount() {\n      try {\n        var isIE = typeof document !== 'undefined' && !!document['documentMode'];\n\n        if (isIE) {\n          console.error(\"EASYBASE â€” easybase-react does not support Internet Explorer. Please use a different browser.\");\n        }\n\n        g.instance = typeof navigator !== 'undefined' && navigator.product === 'ReactNative' ? \"React Native\" : \"React\";\n        g.options = _extends({}, options);\n        g.integrationID = ebconfig.integration;\n        g.ebconfig = ebconfig;\n\n        var _temp5 = function () {\n          if (g.ebconfig.tt && g.ebconfig.integration.split(\"-\")[0].toUpperCase() !== \"PROJECT\") {\n            var t1 = Date.now();\n            log(\"mounting...\");\n            return Promise.resolve(initAuth()).then(function () {\n              return Promise.resolve(tokenPost(POST_TYPES.VALID_TOKEN)).then(function (res) {\n                var elapsed = Date.now() - t1;\n\n                if (res.success) {\n                  log(\"Valid auth initiation in \" + elapsed + \"ms\");\n                  setMounted(true);\n                }\n              });\n            });\n          } else {\n            g.mounted = true;\n            var cookieName = g.ebconfig.integration.slice(-10);\n            return Promise.resolve(getCacheTokens(cookieName)).then(function (_ref2) {\n              var cacheToken = _ref2.cacheToken,\n                  cacheRefreshToken = _ref2.cacheRefreshToken,\n                  cacheSession = _ref2.cacheSession;\n\n              function _temp3() {\n                setMounted(true);\n              }\n\n              var _temp2 = function () {\n                if (cacheRefreshToken) {\n                  g.token = cacheToken;\n                  g.refreshToken = cacheRefreshToken;\n                  g.session = +cacheSession;\n                  var fallbackMount = setTimeout(function () {\n                    setMounted(true);\n                  }, 2500);\n                  return Promise.resolve(tokenPost(POST_TYPES.REQUEST_TOKEN, {\n                    refreshToken: g.refreshToken,\n                    token: g.token\n                  })).then(function (refreshTokenRes) {\n                    var _temp = function () {\n                      if (refreshTokenRes.success) {\n                        clearTimeout(fallbackMount);\n                        g.token = refreshTokenRes.data.token;\n                        return Promise.resolve(setCacheTokens(g, cookieName)).then(function () {\n                          setUserSignedIn(true);\n                        });\n                      } else {\n                        clearCacheTokens(cookieName);\n                      }\n                    }();\n\n                    if (_temp && _temp.then) return _temp.then(function () {});\n                  });\n                }\n              }();\n\n              return _temp2 && _temp2.then ? _temp2.then(_temp3) : _temp3(_temp2);\n            });\n          }\n        }();\n\n        return Promise.resolve(_temp5 && _temp5.then ? _temp5.then(function () {}) : void 0);\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    };\n\n    mount();\n  }, []);\n\n  var useFrameEffect = function useFrameEffect(effect) {\n    _effect = effect;\n  };\n\n  useEffect(function () {\n    if (userSignedIn === true && _ranSignInCallback.current === false && _signInCallback !== undefined) {\n      _signInCallback();\n\n      _ranSignInCallback.current = true;\n    }\n  }, [userSignedIn]);\n\n  var onSignIn = function onSignIn(callback) {\n    _signInCallback = callback;\n\n    if (userSignedIn === true && _ranSignInCallback.current === false && _signInCallback !== undefined) {\n      _signInCallback();\n\n      _ranSignInCallback.current = true;\n    }\n  };\n\n  useEffect(function () {\n    _observableFrame.observe(function (allChanges) {\n      allChanges.forEach(function (change) {\n        _observedChangeStack.push({\n          type: change.type,\n          path: change.path,\n          value: change.value,\n          _id: _recordIdMap.get(_frame[Number(change.path[0])])\n        });\n\n        log(JSON.stringify({\n          type: change.type,\n          path: change.path,\n          value: change.value,\n          _id: _recordIdMap.get(_frame[Number(change.path[0])])\n        }));\n      });\n    });\n\n    _proxyRecordMap = new WeakMap();\n\n    _frame.forEach(function (_, i) {\n      return _proxyRecordMap.set(_observableFrame[i], \"\" + i);\n    });\n\n    _effect();\n  }, [_observableFrame]);\n  useEffect(function () {\n    _observableFrame.unobserve();\n\n    _setObservableFrame(Observable.from(_frame));\n  }, [_frame]);\n\n  function Frame(index) {\n    if (typeof index === \"number\") {\n      return _observableFrame[index];\n    } else {\n      return _observableFrame;\n    }\n  }\n\n  var _recordIDExists = function _recordIDExists(record) {\n    return !!_recordIdMap.get(record) || !!_recordIdMap.get(_getRawRecordFromProxy(record) || {});\n  };\n\n  var _getRawRecordFromProxy = function _getRawRecordFromProxy(proxyRecord) {\n    return _proxyRecordMap.get(proxyRecord) ? _frame[+_proxyRecordMap.get(proxyRecord)] : undefined;\n  };\n\n  var configureFrame = function configureFrame(options) {\n    _frameConfiguration = _extends({}, _frameConfiguration);\n    if (options.limit !== undefined) _frameConfiguration.limit = options.limit;\n    if (options.offset !== undefined && options.offset >= 0) _frameConfiguration.offset = options.offset;\n    if (options.tableName !== undefined) _frameConfiguration.tableName = options.tableName;\n    _isFrameInitialized = false;\n    return {\n      message: \"Successfully configured frame. Run sync() for changes to be shown in frame\",\n      success: true\n    };\n  };\n\n  var currentConfiguration = function currentConfiguration() {\n    return _extends({}, _frameConfiguration);\n  };\n\n  var addRecord = function addRecord(options) {\n    try {\n      var defaultValues = {\n        insertAtEnd: false,\n        newRecord: {},\n        tableName: undefined\n      };\n\n      var fullOptions = _extends({}, defaultValues, options);\n\n      return Promise.resolve(_catch(function () {\n        return Promise.resolve(tokenPost(POST_TYPES.SYNC_INSERT, fullOptions)).then(function (res) {\n          return {\n            message: res.data,\n            success: res.success\n          };\n        });\n      }, function (err) {\n        console.error(\"Easybase Error: addRecord failed \", err);\n        return {\n          message: \"Easybase Error: addRecord failed \" + err,\n          success: false,\n          error: err\n        };\n      }));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  var deleteRecord = function deleteRecord(options) {\n    try {\n      var _frameRecord = _getRawRecordFromProxy(options.record) || _frame.find(function (ele) {\n        return deepEqual(ele, options.record);\n      });\n\n      if (_frameRecord && _recordIdMap.get(_frameRecord)) {\n        return Promise.resolve(tokenPost(POST_TYPES.SYNC_DELETE, {\n          _id: _recordIdMap.get(_frameRecord),\n          tableName: options.tableName\n        })).then(function (res) {\n          return {\n            success: res.success,\n            message: res.data\n          };\n        });\n      } else {\n        return Promise.resolve(_catch(function () {\n          return Promise.resolve(tokenPost(POST_TYPES.SYNC_DELETE, {\n            record: options.record,\n            tableName: options.tableName\n          })).then(function (res) {\n            return {\n              success: res.success,\n              message: res.data\n            };\n          });\n        }, function (err) {\n          console.error(\"Easybase Error: deleteRecord failed \", err);\n          return {\n            success: false,\n            message: \"Easybase Error: deleteRecord failed \" + err,\n            error: err\n          };\n        }));\n      }\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  var sync = function sync() {\n    try {\n      var _temp9 = function _temp9() {\n        return _catch(function () {\n          return Promise.resolve(tokenPost(POST_TYPES.GET_FRAME, _frameConfiguration)).then(function (res) {\n            if (res.success === false) {\n              console.error(res.data);\n              setIsSyncing(false);\n              return {\n                success: false,\n                message: \"\" + res.data\n              };\n            } else {\n              _isFrameInitialized = true;\n\n              _realignFrames(res.data);\n\n              setIsSyncing(false);\n              return {\n                message: 'Success. Call frame for data',\n                success: true\n              };\n            }\n          });\n        }, function (err) {\n          console.error(\"Easybase Error: get failed \", err);\n          setIsSyncing(false);\n          return {\n            success: false,\n            message: \"Easybase Error: get failed \" + err,\n            error: err\n          };\n        });\n      };\n\n      var _realignFrames = function _realignFrames(newData) {\n        var isNewDataTheSame = true;\n\n        if (newData.length !== _frame.length) {\n          isNewDataTheSame = false;\n        } else {\n          for (var i = 0; i < newData.length; i++) {\n            var newDataNoId = _extends({}, newData[i]);\n\n            delete newDataNoId._id;\n\n            if (!deepEqual(newDataNoId, _frame[i])) {\n              isNewDataTheSame = false;\n              break;\n            }\n          }\n        }\n\n        if (!isNewDataTheSame) {\n          _recordIdMap = new WeakMap();\n          _frame.length = newData.length;\n          newData.forEach(function (currNewEle, i) {\n            _frame[i] = currNewEle;\n\n            _recordIdMap.set(currNewEle, currNewEle._id);\n\n            delete currNewEle._id;\n          });\n\n          _setFrame([].concat(_frame));\n        }\n      };\n\n      if (isSyncing) {\n        return Promise.resolve({\n          success: false,\n          message: \"Easybase Error: the provider is currently syncing, use 'await sync()' before calling sync() again\"\n        });\n      }\n\n      setIsSyncing(true);\n\n      var _temp10 = function () {\n        if (_isFrameInitialized) {\n          var _temp11 = function () {\n            if (_observedChangeStack.length > 0) {\n              log(\"Stack change: \", _observedChangeStack);\n              return Promise.resolve(tokenPost(POST_TYPES.SYNC_STACK, _extends({\n                stack: _observedChangeStack\n              }, _frameConfiguration))).then(function (res) {\n                if (res.success) {\n                  _observedChangeStack.length = 0;\n                }\n              });\n            }\n          }();\n\n          if (_temp11 && _temp11.then) return _temp11.then(function () {});\n        }\n      }();\n\n      return Promise.resolve(_temp10 && _temp10.then ? _temp10.then(_temp9) : _temp9(_temp10));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  var updateRecordImage = function updateRecordImage(options) {\n    return Promise.resolve(_updateRecordAttachment(options, \"image\"));\n  };\n\n  var updateRecordVideo = function updateRecordVideo(options) {\n    return Promise.resolve(_updateRecordAttachment(options, \"video\"));\n  };\n\n  var updateRecordFile = function updateRecordFile(options) {\n    return Promise.resolve(_updateRecordAttachment(options, \"file\"));\n  };\n\n  var _updateRecordAttachment = function _updateRecordAttachment(options, type) {\n    try {\n      var isFileFromURI = function isFileFromURI(f) {\n        return f.uri !== undefined;\n      };\n\n      var _frameRecord = _getRawRecordFromProxy(options.record) || _frame.find(function (ele) {\n        return deepEqual(ele, options.record);\n      });\n\n      if (_frameRecord === undefined || !_recordIDExists(_frameRecord)) {\n        log(\"Attempting to add attachment to a new record that has not been synced. Please sync() before trying to add attachment.\");\n        return Promise.resolve({\n          success: false,\n          message: \"Attempting to add attachment to a new record that has not been synced. Please sync() before trying to add attachment.\"\n        });\n      }\n\n      var ext = options.attachment.name.split(\".\").pop().toLowerCase();\n      log(ext);\n\n      if (type === \"image\" && !imageExtensions.includes(ext)) {\n        return Promise.resolve({\n          success: false,\n          message: \"Image files must have a proper image extension in the file name\"\n        });\n      }\n\n      if (type === \"video\" && !videoExtensions.includes(ext)) {\n        return Promise.resolve({\n          success: false,\n          message: \"Video files must have a proper video extension in the file name\"\n        });\n      }\n\n      var formData = new FormData();\n\n      if (isFileFromURI(options.attachment)) {\n        formData.append(\"file\", options.attachment);\n        formData.append(\"name\", options.attachment.name);\n      } else {\n        formData.append(\"file\", options.attachment);\n        formData.append(\"name\", options.attachment.name);\n      }\n\n      var customHeaders = {\n        'Eb-upload-type': type,\n        'Eb-column-name': options.columnName,\n        'Eb-record-id': _recordIdMap.get(_frameRecord),\n        'Eb-table-name': options.tableName\n      };\n      return Promise.resolve(tokenPostAttachment(formData, customHeaders)).then(function (res) {\n        return Promise.resolve(sync()).then(function () {\n          return {\n            message: res.data,\n            success: res.success\n          };\n        });\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  var isUserSignedIn = function isUserSignedIn() {\n    return userSignedIn;\n  };\n\n  g.newTokenCallback = function () {\n    var cookieName = g.ebconfig.integration.slice(-10);\n\n    if (!g.token) {\n      clearCacheTokens(cookieName).then(function (_) {\n        setUserSignedIn(false);\n        _ranSignInCallback.current = false;\n      });\n    } else {\n      setCacheTokens(g, cookieName).then(function (_) {\n        setUserSignedIn(true);\n      });\n    }\n  };\n\n  var useReturn = function useReturn(dbInstance, deps) {\n    var _useState6 = useState(function () {\n      return function () {};\n    }),\n        unsubscribe = _useState6[0],\n        setUnsubscribe = _useState6[1];\n\n    var _useState7 = useState([]),\n        frame = _useState7[0],\n        setFrame = _useState7[1];\n\n    var _useState8 = useState(null),\n        error = _useState8[0],\n        setError = _useState8[1];\n\n    var _useState9 = useState(false),\n        loading = _useState9[0],\n        setLoading = _useState9[1];\n\n    var _useState10 = useState(false),\n        dead = _useState10[0],\n        setDead = _useState10[1];\n\n    var doFetch = function doFetch() {\n      try {\n        var _temp14 = function _temp14() {\n          setLoading(false);\n        };\n\n        setLoading(true);\n\n        var _temp15 = _catch(function () {\n          return Promise.resolve(dbInstance().all()).then(function (res) {\n            if (Array.isArray(res)) {\n              setFrame(res);\n            }\n          });\n        }, function (error) {\n          setError(error);\n        });\n\n        return Promise.resolve(_temp15 && _temp15.then ? _temp15.then(_temp14) : _temp14(_temp15));\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    };\n\n    useEffect(function () {\n      var isAlive = true;\n\n      if (!dead) {\n        var _instanceTableName = dbInstance()._tableName;\n\n        unsubscribe(\"true\");\n\n        var _listener = dbEventListener(function (status, queryType, executeCount, tableName, returned) {\n          if (!isAlive) {\n            return;\n          }\n\n          log(_instanceTableName, status, queryType, executeCount, tableName);\n\n          if (tableName === null && _instanceTableName === \"untable\" || tableName === _instanceTableName) {\n            if (status === DB_STATUS.SUCCESS && queryType !== \"select\") {\n              if (typeof returned === \"number\" && returned > 0) {\n                doFetch();\n              } else if (Array.isArray(returned) && typeof returned[0] === \"number\" && returned[0] > 0) {\n                doFetch();\n              }\n            }\n          }\n        });\n\n        setUnsubscribe(function () {\n          return function (stayAlive) {\n            _listener();\n\n            stayAlive !== \"true\" && setDead(true);\n          };\n        });\n        doFetch();\n      }\n\n      return function () {\n        isAlive = false;\n      };\n    }, deps || []);\n    return {\n      frame: frame,\n      unsubscribe: unsubscribe,\n      error: error,\n      manualFetch: doFetch,\n      loading: loading\n    };\n  };\n\n  var c = {\n    configureFrame: configureFrame,\n    addRecord: addRecord,\n    deleteRecord: deleteRecord,\n    sync: sync,\n    updateRecordImage: updateRecordImage,\n    updateRecordVideo: updateRecordVideo,\n    updateRecordFile: updateRecordFile,\n    Frame: Frame,\n    useFrameEffect: useFrameEffect,\n    fullTableSize: fullTableSize,\n    tableTypes: tableTypes,\n    currentConfiguration: currentConfiguration,\n    Query: Query,\n    signIn: signIn,\n    signOut: signOut,\n    isUserSignedIn: isUserSignedIn,\n    signUp: signUp,\n    setUserAttribute: setUserAttribute,\n    getUserAttributes: getUserAttributes,\n    resetUserPassword: resetUserPassword,\n    onSignIn: onSignIn,\n    db: db,\n    dbEventListener: dbEventListener,\n    e: e,\n    useReturn: useReturn\n  };\n  return React.createElement(EasybaseContext.Provider, {\n    value: c\n  }, mounted && children);\n};\n\nvar useEasybase = function useEasybase() {\n  var easybase = useContext(EasybaseContext);\n  return easybase;\n};\n\nvar callFunction = callFunction$1;\nexport { EasybaseProvider, callFunction, useEasybase };","map":{"version":3,"sources":["../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/EasybaseContext.tsx","../node_modules/easybasejs/src/EasybaseProvider/types.ts","../node_modules/easybasejs/src/EasybaseProvider/g.ts","../node_modules/easybasejs/src/EasybaseProvider/utils.ts","../node_modules/cross-fetch/dist/browser-ponyfill.js","../node_modules/easybasejs/src/EasybaseProvider/auth.ts","../node_modules/easybasejs/src/EasybaseProvider/table.ts","../node_modules/easybasejs/src/EasybaseProvider/db.ts","../src/cache.tsx","../src/EasybaseProvider.tsx","../src/useEasybase.tsx","../src/callFunction.tsx"],"names":["c","configureFrame","addRecord","deleteRecord","sync","updateRecordImage","updateRecordVideo","updateRecordFile","Frame","useFrameEffect","fullTableSize","tableTypes","currentConfiguration","Query","getUserAttributes","isUserSignedIn","setUserAttribute","resetUserPassword","signIn","signOut","signUp","onSignIn","db","dbEventListener","useReturn","e","createContext","this","navigator","storage","storageBackend","AsyncStorage","window","localStorage","getCacheTokens","cacheToken","cacheRefreshToken","cacheSession","key","cookieName","clearCacheTokens","setCacheTokens","data","g","expires","gFactory","initAuth","tokenPost","tokenPostAttachment","authFactory","log","utilsFactory","tableFactory","dbFactory","_isFrameInitialized","_frameConfiguration","offset","limit","_effect","_observedChangeStack","_recordIdMap","_proxyRecordMap","EasybaseProvider","children","ebconfig","options","mounted","setMounted","useState","isSyncing","setIsSyncing","userSignedIn","setUserSignedIn","_frame","_setFrame","_observableFrame","_setObservableFrame","observe","unobserve","_ranSignInCallback","useRef","console","React","useEffect","mount","isIE","document","t1","Date","res","POST_TYPES","elapsed","success","cache","fallbackMount","setTimeout","refreshTokenRes","refreshToken","token","clearTimeout","_signInCallback","allChanges","type","change","path","value","_id","Number","Observable","_recordIDExists","_getRawRecordFromProxy","message","defaultValues","insertAtEnd","newRecord","tableName","undefined","fullOptions","err","error","_frameRecord","deepEqual","record","_realignFrames","isNewDataTheSame","newData","i","newDataNoId","currNewEle","stack","_updateRecordAttachment","ext","imageExtensions","videoExtensions","isFileFromURI","f","formData","customHeaders","unsubscribe","setUnsubscribe","frame","setFrame","setError","loading","setLoading","dead","setDead","doFetch","dbInstance","Array","isAlive","_instanceTableName","_listener","status","DB_STATUS","queryType","returned","stayAlive","deps","manualFetch","EasybaseContext","useEasybase","easybase","useContext","callFunction","_callFunction"],"mappings":"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","sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import { createContext } from \"react\";\nimport {\n    ConfigureFrameOptions,\n    StatusResponse,\n    AddRecordOptions,\n    UpdateRecordAttachmentOptions,\n    FrameConfiguration,\n    QueryOptions,\n    ContextValue,\n    UseReturnValue\n} from \"./types\";\nimport { SQW } from \"EasyQB/types/sq\";\nimport { NewExpression } from \"EasyQB/types/expression\";\n\nfunction Frame(): Record<string, any>[];\nfunction Frame(index: number): Record<string, any>;\nfunction Frame(index?: number): Record<string, any>[] | Record<string, any> {\n    return [];\n}\n\nconst c: ContextValue = {\n    configureFrame: (_: ConfigureFrameOptions) => ({}) as StatusResponse,\n    addRecord: async (_: AddRecordOptions) => ({}) as StatusResponse,\n    deleteRecord: async (_: Record<string, any>) => ({}) as StatusResponse,\n    sync: async () => ({}) as StatusResponse,\n    updateRecordImage: async (_: UpdateRecordAttachmentOptions) => ({}) as StatusResponse,\n    updateRecordVideo: async (_: UpdateRecordAttachmentOptions) => ({}) as StatusResponse,\n    updateRecordFile: async (_: UpdateRecordAttachmentOptions) => ({}) as StatusResponse,\n    Frame,\n    useFrameEffect: (_: React.EffectCallback) => {},\n    fullTableSize: async () => 0,\n    tableTypes: async() => ({}) as Record<string, any>,\n    currentConfiguration: () => ({}) as FrameConfiguration,\n    Query: async (_: QueryOptions) => ([]),\n    getUserAttributes: async() => ({}) as Record<string, string>,\n    isUserSignedIn: () => false,\n    setUserAttribute: async (_: string, _2: string) => ({}) as StatusResponse,\n    resetUserPassword: async (_: string) => ({}) as StatusResponse,\n    signIn: async (_: string, _2: string) => ({}) as StatusResponse,\n    signOut: () => {},\n    signUp: async (_: string, _2: string, _3?: Record<string, string>) => ({}) as StatusResponse,\n    onSignIn: (_: () => void) => {},\n    db: (_?: string) => ({}) as SQW,\n    dbEventListener: (_: () => void) => () => {},\n    useReturn: (_: () => SQW) => ({}) as UseReturnValue,\n    e: ({}) as NewExpression\n}\n\nexport default createContext(c);\n","import { SQW } from \"EasyQB/types/sq\";\nimport { NewExpression } from \"EasyQB/types/expression\";\n\nexport interface ConfigureFrameOptions {\n    /** Edit starting index from which records will be retrieved from. Useful for paging. */\n    offset?: number;\n    /** Limit the amount of records to be retrieved. Set to -1 or null to return all records. Can be used in combination with offset. */\n    limit?: number | null;\n    /** Table to sync frame with. (Projects only) */\n    tableName?: string;\n}\n\nexport interface EasybaseProviderPropsOptions {\n    /** Custom authentication string. Can be set in integration menu. If it is set, it is required to access integration. This acts as an extra layer of security and extensibility. */\n    authentication?: string;\n    /** Log Easybase react status and events to console. */\n    logging?: boolean;\n}\n\nexport interface EasybaseProviderProps {\n    /** EasyBase ebconfig object. Can be downloaded in the integration drawer next to 'React Token'. This is automatically generated.  */\n    ebconfig: Ebconfig;\n    /** Optional configuration parameters. */\n    options?: EasybaseProviderPropsOptions\n}\n\nexport interface FrameConfiguration {\n    /** Edit starting index from which records will be retrieved from. Useful for paging. */\n    offset: number;\n    /** Limit the amount of records to be retrieved. Set to -1 or null to return all records. Can be used in combination with offset. */\n    limit: number | null;\n    /** Table to sync frame with. (Projects only) */\n    tableName?: string;\n}\n\nexport interface Ebconfig {\n    tt?: string,\n    integration: string,\n    version: string\n}\n\nexport interface AddRecordOptions {\n    /** If true, record will be inserted at the end of the collection rather than the front. Overwrites absoluteIndex. */\n    insertAtEnd?: boolean;\n    /** Values to post to EasyBase collection. Format is { column name: value } */\n    newRecord: Record<string, any>;\n    /** Table to post new record to. (Projects only) */\n    tableName?: string;\n}\n\nexport interface DeleteRecordOptions {\n    record: Record<string, any>;\n    /** Table to delete record from. (Projects only) */\n    tableName?: string;\n}\n\nexport interface QueryOptions {\n    /** Name of the query saved in Easybase's Visual Query Builder */\n    queryName: string;\n    /** If you would like to sort the order of your query by a column. Pass the name of that column here */\n    sortBy?: string;\n    /** By default, columnToSortBy will sort your query by ascending value (1, 2, 3...). To sort by descending set this to true */\n    descending?: boolean;\n    /** Edit starting index from which records will be retrieved from. Useful for paging. */\n    offset?: number;\n    /** Limit the amount of records to be retrieved. Can be used in combination with offset. */\n    limit?: number;\n    /** This object can be set to overwrite the query values as set in the integration menu. If your query is setup to find records where 'age' >= 0, passing in { age: 50 } will query where 'age' >= 50. Read more: https://easybase.io/about/2020/09/15/Customizing-query-values/ */\n    customQuery?: Record<string, any>;\n    /** Table to query. (Projects only) */\n    tableName?: string;\n}\n\nexport interface FileFromURI {\n    /** Path on local device to the attachment. Usually received from react-native-image-picker or react-native-document-picker */\n    uri: string,\n    /** Name of the file with proper extension */\n    name: string,\n    /** File MIME type */\n    type: string\n}\n\nexport interface UpdateRecordAttachmentOptions {\n    /** EasyBase Record to attach this attachment to */\n    record: Record<string, any>;\n    /** The name of the column that is of type file/image/video */\n    columnName: string;\n    /** Either an HTML File element containing the correct type of attachment or a FileFromURI object for React Native instances.\n     * For React Native use libraries such as react-native-image-picker and react-native-document-picker.\n     * The file name must have a proper file extension corresponding to the attachment. \n     */\n    attachment: File | FileFromURI;\n    /** Table to post attachment to. (Projects only) */\n    tableName?: string;\n}\n\nexport interface StatusResponse {\n    /** Returns true if the operation was successful */\n    success: boolean;\n    /** Readable description of the the operation's status */\n    message: string;\n    /** Will represent a corresponding error if an error was thrown during the operation. */\n    error?: Error;\n}\n\nexport enum POST_TYPES {\n    UPLOAD_ATTACHMENT = \"upload_attachment\",\n    HANDSHAKE = \"handshake\",\n    VALID_TOKEN = \"valid_token\",\n    GET_FRAME = \"get_frame\",\n    TABLE_SIZE = \"table_size\",\n    COLUMN_TYPES = \"column_types\",\n    SYNC_STACK = \"sync_stack\",\n    SYNC_DELETE = \"sync_delete\",\n    SYNC_INSERT = \"sync_insert\",\n    GET_QUERY = \"get_query\",\n    USER_ATTRIBUTES = \"user_attributes\",\n    SET_ATTRIBUTE = \"set_attribute\",\n    SIGN_UP = \"sign_up\",\n    REQUEST_TOKEN = \"request_token\",\n    EASY_QB = \"easyqb\",\n    RESET_PASSWORD = \"reset_password\"\n}\n\nexport enum DB_STATUS {\n    ERROR = \"error\",\n    PENDING = \"pending\",\n    SUCCESS = \"success\"\n}\n\nexport enum EXECUTE_COUNT {\n    ALL = \"all\",\n    ONE = \"one\"\n}\n\nexport interface AuthPostResponse {\n    success: boolean;\n    data: any;\n}\n\nexport interface ContextValue {\n    /**\n     * Check if a user is currently signed in.\n     */\n    isUserSignedIn(): boolean;\n    /**\n     * Signs out the current user.\n     */\n    signOut(): void;\n    /**\n     * Retrieve the currently signed in users attribute object.\n     * @async\n     * @return {Promise<Record<string, string>>} Promise<Record<string, string>>\n     */\n    getUserAttributes(): Promise<Record<string, string>>;\n    /**\n     * Set a single attribute of the currently signed in user. Can also be updated visually in the Easybase 'Users' tab.\n     * @async\n     * @abstract\n     * @param key Object key. Can be a new key or existing key.\n     * @param value attribute value.\n     * @return {Promise<StatusResponse>} Promise<StatusResponse>\n     */\n    setUserAttribute(key: string, value: string): Promise<StatusResponse>;\n    /**\n     * Reset the currently signed-in user's password to a new string.\n     * @async\n     * @param {string} newPassword New user password\n     * @return {Promise<StatusResponse>} Promise<StatusResponse>\n     */\n    resetUserPassword(newPassword: string): Promise<StatusResponse>;\n    /**\n     * Sign in a user that already exists for a project.\n     * @abstract\n     * @async\n     * @param userID unique identifier for new user. Usually an email or phone number.\n     * @param password user password.\n     * @return {Promise<StatusResponse>} Promise<StatusResponse>\n     */\n    signIn(userID: string, password: string): Promise<StatusResponse>;\n    /**\n     * Create a new user for your project. You must still call signIn() after signing up.\n     * @abstract\n     * @async\n     * @param newUserID unique identifier for new user. Usually an email or phone number.\n     * @param password user password. Must be at least 8 characters long.\n     * @param userAttributes Optional object to store user attributes. Can also be edited visually in the Easybase 'Users' tab.\n     * @return {Promise<StatusResponse>} Promise<StatusResponse>\n     */\n    signUp(newUserID: string, password: string, userAttributes?: Record<string, string>): Promise<StatusResponse>;\n    /**\n     * Configure the current frame size. Set the offset and amount of records to retreive assume you don't want to receive\n     * your entire collection. This is useful for paging.\n     * @abstract\n     * @param {ConfigureFrameOptions} options ConfigureFrameOptions\n     * @return {StatusResponse} StatusResponse\n     */\n    configureFrame(options: ConfigureFrameOptions): StatusResponse;\n    /**\n     * Manually add a record to your collection regardless of your current frame. You must call sync() after this to see updated response.\n     * @abstract\n     * @async\n     * @param {AddRecordOptions} options AddRecordOptions\n     * @return {Promise<StatusResponse>} Promise<StatusResponse>\n     */\n    addRecord(options: AddRecordOptions): Promise<StatusResponse>;\n    /**\n     * Manually delete a record from your collection regardless of your current frame. You must call sync() after this to see updated response.\n     * @abstract\n     * @async\n     * @param {Record<string, any>} record \n     * @return {Promise<StatusResponse>} Promise<StatusResponse>\n     */\n    deleteRecord(options: DeleteRecordOptions): Promise<StatusResponse>;\n    /**\n     * Call this method to syncronize your current changes with your database. Delections, additions, and changes will all be reflected by your \n     * backend after calling this method. Call Frame() after this to get a normalized array of the freshest data.\n     * @abstract\n     * @async\n     * @return {Promise<StatusResponse>} Promise<StatusResponse>\n     */\n    sync(): Promise<StatusResponse>;\n    /**\n     * Upload an image to your backend and attach it to a specific record. columnName must reference a column of type 'image'.\n     * The file must have an extension of an image. \n     * Call sync() for fresh data with propery attachment links to cloud hosting.\n     * @abstract\n     * @async\n     * @param {UpdateRecordAttachmentOptions} options UpdateRecordAttachmentOptions\n     * @return {Promise<StatusResponse>} Promise<StatusResponse>\n     */\n    updateRecordImage(options: UpdateRecordAttachmentOptions): Promise<StatusResponse>;\n    /**\n     * Upload a video to your backend and attach it to a specific record. columnName must reference a column of type 'video'. \n     * The file must have an extension of a video.\n     * Call sync() for fresh data with propery attachment links to cloud hosting.\n     * @abstract\n     * @async\n     * @param {UpdateRecordAttachmentOptions} options UpdateRecordAttachmentOptions\n     * @return {Promise<StatusResponse>} Promise<StatusResponse>\n     */\n    updateRecordVideo(options: UpdateRecordAttachmentOptions): Promise<StatusResponse>;\n    /**\n     * Upload a file to your backend and attach it to a specific record. columnName must reference a column of type 'file'. \n     * Call sync() for fresh data with propery attachment links to cloud hosting.\n     * @abstract\n     * @async\n     * @param {UpdateRecordAttachmentOptions} options UpdateRecordAttachmentOptions\n     * @return {Promise<StatusResponse>} Promise<StatusResponse>\n     */\n    updateRecordFile(options: UpdateRecordAttachmentOptions): Promise<StatusResponse>;\n    /**\n     * This function is how you access your current frame. This function does not get new data or push changes to EasyBase. If you \n     * want to syncronize your frame and EasyBase, call sync() then Frame().\n     * @abstract\n     * @return {Record<string, any>[]} Array of records corresponding to the current frame. Call sync() to push changes that you have made to this array.\n     * \n     */\n    Frame(): Record<string, any>[];\n    /**\n     * This function is how you access a single object your current frame. This function does not get new data or push changes to EasyBase. If you \n     * want to syncronize your frame and EasyBase, call sync() then Frame().\n     * @abstract\n     * @param {number} [index] Passing an index will only return the object at that index in your Frame, rather than the entire array. This is useful for editing single objects based on an index.\n     * @return {Record<string, any>} Single record corresponding to that object within the current frame. Call sync() to push changes that you have made to this object.\n     * \n     */\n    Frame(index: number): Record<string, any>;\n    /**\n     * Gets the number of records in your table.\n     * @async\n     * @returns {Promise<number>} The the number of records in your table.\n     */\n    fullTableSize(): Promise<number>;\n    /**\n     * Gets the number of records in your table.\n     * @async\n     * @param {string} [tableName] Name of table to get the sizes of. (Projects only)\n     * @returns {Promise<number>} The the number of records in your table.\n     */\n    fullTableSize(tableName: string): Promise<number>;\n    /**\n     * Retrieve an object detailing the columns in your table mapped to their corresponding type.\n     * @async\n     * @returns {Promise<Record<string, any>>} Object detailing the columns in your table mapped to their corresponding type.\n     */\n    tableTypes(): Promise<Record<string, any>>;\n    /**\n     * Retrieve an object detailing the columns in your table mapped to their corresponding type.\n     * @async\n     * @param {string} [tableName] Name of table to get the types of. (Projects only)\n     * @returns {Promise<Record<string, any>>} Object detailing the columns in your table mapped to their corresponding type.\n     */\n    tableTypes(tableName: string): Promise<Record<string, any>>;\n    /**\n     * View your frames current configuration\n     * @returns {Record<string, any>} Object contains the `offset` and `length` of your current frame.\n     */\n    currentConfiguration(): FrameConfiguration;\n    /**\n     * @async\n     * View a query by name. This returns an isolated array that has no effect on your frame or frame configuration. sync() and Frame() have no \n     * relationship with a Query(). An edited Query cannot be synced with your database, use Frame() for realtime \n     * database array features.\n     * @param {QueryOptions} options QueryOptions\n     * @return {Promise<Record<string, any>[]>} Isolated array of records in the same form as Frame(). Editing this array has no effect and cannot be synced with your database. Use Frame() for realtime database features.\n     */\n    Query(options: QueryOptions): Promise<Record<string, any>[]>;\n    /**\n     * Instantiate EasyQB instance for dynamic CRUD query building: https://easybase.github.io/EasyQB/\n     * @param {string} [tableName] Name of your table.\n     * @param {boolean} [userAssociatedRecordsOnly] **PROJECTS ONLY** Operations will only be performed on records already associated to the currently signed-in user. Inserted records will automatically be associate to the user.\n     * @returns {SQW} EasyQB object for dynamic querying: https://easybase.github.io/EasyQB/\n     */\n    db(tableName?: string, userAssociatedRecordsOnly?: boolean): SQW;\n    /**\n     * Subscribe to db events, invoked by calling `.all` or `.one`: https://easybase.github.io/EasyQB/\n     * @param {function(status?: DB_STATUS, queryType?: string, executeCount?: EXECUTE_COUNT, tableName?: string | null, returned?: any):void} [callback] Callback function to execute on db operations.\n     * @returns {function():void} Calling this function unsubscribes your callback function from events.\n     */\n    dbEventListener(callback: (status?: DB_STATUS, queryType?: string, executeCount?: EXECUTE_COUNT, tableName?: string | null, returned?: any) => void): () => void;\n    /**\n     * Expressions and operations builder for `.db()`, used to create complex conditions, aggregators, and clauses. https://easybase.github.io/EasyQB/docs/operations.html\n     */\n    e: NewExpression;\n}\n\nexport interface Globals {\n    ebconfig: Ebconfig;\n    token: string;\n    refreshToken: string;\n    integrationID: string;\n    session: number;\n    options: EasybaseProviderPropsOptions;\n    instance: string;\n    mounted: boolean;\n    newTokenCallback(): void;\n}\n","import { Ebconfig, EasybaseProviderPropsOptions, Globals } from \"./types\";\n\nnamespace GlobalNamespace {\n    export let ebconfig: Ebconfig;\n    export let token: string;\n    export let refreshToken: string;\n    export let integrationID: string;\n    export let session: number;\n    export let options: EasybaseProviderPropsOptions;\n    export let instance: string;\n    export let mounted: boolean;\n    export let newTokenCallback: () => {};\n}\n\nconst _g: Globals = { ...GlobalNamespace };\n\nexport default _g;\n \nexport function gFactory(): Globals {\n    return { ...GlobalNamespace } as Globals;\n}\n","import _g from \"./g\";\nimport { Globals } from \"./types\";\n\nexport default function utilsFactory(globals?: Globals): any {\n    const g = globals || _g;\n\n    const generateBareUrl = (type: string, integrationID: string): string => `https://api.easybase.io/${type}/${integrationID}`;\n\n    const generateAuthBody = (): any => {\n        const stamp = Date.now();\n        return {\n            token: g.token,\n            token_time: ~~(g.session / (stamp % 64)),\n            now: stamp\n        }\n    }\n    \n    function log(...params: any): void {\n        if (g.options.logging) {\n            console.log(\"EASYBASE â€” \", ...params);\n        }\n    }\n\n    return {\n        generateAuthBody,\n        generateBareUrl,\n        log\n    }\n}\n","var global = typeof self !== 'undefined' ? self : this;\nvar __self__ = (function () {\nfunction F() {\nthis.fetch = false;\nthis.DOMException = global.DOMException\n}\nF.prototype = global;\nreturn new F();\n})();\n(function(self) {\n\nvar irrelevant = (function (exports) {\n\n  var support = {\n    searchParams: 'URLSearchParams' in self,\n    iterable: 'Symbol' in self && 'iterator' in Symbol,\n    blob:\n      'FileReader' in self &&\n      'Blob' in self &&\n      (function() {\n        try {\n          new Blob();\n          return true\n        } catch (e) {\n          return false\n        }\n      })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  };\n\n  function isDataView(obj) {\n    return obj && DataView.prototype.isPrototypeOf(obj)\n  }\n\n  if (support.arrayBuffer) {\n    var viewClasses = [\n      '[object Int8Array]',\n      '[object Uint8Array]',\n      '[object Uint8ClampedArray]',\n      '[object Int16Array]',\n      '[object Uint16Array]',\n      '[object Int32Array]',\n      '[object Uint32Array]',\n      '[object Float32Array]',\n      '[object Float64Array]'\n    ];\n\n    var isArrayBufferView =\n      ArrayBuffer.isView ||\n      function(obj) {\n        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n      };\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name);\n    }\n    if (/[^a-z0-9\\-#$%&'*+.^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value);\n    }\n    return value\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function() {\n        var value = items.shift();\n        return {done: value === undefined, value: value}\n      }\n    };\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function() {\n        return iterator\n      };\n    }\n\n    return iterator\n  }\n\n  function Headers(headers) {\n    this.map = {};\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value);\n      }, this);\n    } else if (Array.isArray(headers)) {\n      headers.forEach(function(header) {\n        this.append(header[0], header[1]);\n      }, this);\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name]);\n      }, this);\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name);\n    value = normalizeValue(value);\n    var oldValue = this.map[name];\n    this.map[name] = oldValue ? oldValue + ', ' + value : value;\n  };\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)];\n  };\n\n  Headers.prototype.get = function(name) {\n    name = normalizeName(name);\n    return this.has(name) ? this.map[name] : null\n  };\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  };\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = normalizeValue(value);\n  };\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    for (var name in this.map) {\n      if (this.map.hasOwnProperty(name)) {\n        callback.call(thisArg, this.map[name], name, this);\n      }\n    }\n  };\n\n  Headers.prototype.keys = function() {\n    var items = [];\n    this.forEach(function(value, name) {\n      items.push(name);\n    });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.values = function() {\n    var items = [];\n    this.forEach(function(value) {\n      items.push(value);\n    });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.entries = function() {\n    var items = [];\n    this.forEach(function(value, name) {\n      items.push([name, value]);\n    });\n    return iteratorFor(items)\n  };\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true;\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result);\n      };\n      reader.onerror = function() {\n        reject(reader.error);\n      };\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsArrayBuffer(blob);\n    return promise\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsText(blob);\n    return promise\n  }\n\n  function readArrayBufferAsText(buf) {\n    var view = new Uint8Array(buf);\n    var chars = new Array(view.length);\n\n    for (var i = 0; i < view.length; i++) {\n      chars[i] = String.fromCharCode(view[i]);\n    }\n    return chars.join('')\n  }\n\n  function bufferClone(buf) {\n    if (buf.slice) {\n      return buf.slice(0)\n    } else {\n      var view = new Uint8Array(buf.byteLength);\n      view.set(new Uint8Array(buf));\n      return view.buffer\n    }\n  }\n\n  function Body() {\n    this.bodyUsed = false;\n\n    this._initBody = function(body) {\n      this._bodyInit = body;\n      if (!body) {\n        this._bodyText = '';\n      } else if (typeof body === 'string') {\n        this._bodyText = body;\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body;\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body;\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString();\n      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n        this._bodyArrayBuffer = bufferClone(body.buffer);\n        // IE 10-11 can't handle a DataView body.\n        this._bodyInit = new Blob([this._bodyArrayBuffer]);\n      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n        this._bodyArrayBuffer = bufferClone(body);\n      } else {\n        this._bodyText = body = Object.prototype.toString.call(body);\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8');\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type);\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');\n        }\n      }\n    };\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this);\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyArrayBuffer) {\n          return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      };\n\n      this.arrayBuffer = function() {\n        if (this._bodyArrayBuffer) {\n          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\n        } else {\n          return this.blob().then(readBlobAsArrayBuffer)\n        }\n      };\n    }\n\n    this.text = function() {\n      var rejected = consumed(this);\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return readBlobAsText(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as text')\n      } else {\n        return Promise.resolve(this._bodyText)\n      }\n    };\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      };\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    };\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase();\n    return methods.indexOf(upcased) > -1 ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {};\n    var body = options.body;\n\n    if (input instanceof Request) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url;\n      this.credentials = input.credentials;\n      if (!options.headers) {\n        this.headers = new Headers(input.headers);\n      }\n      this.method = input.method;\n      this.mode = input.mode;\n      this.signal = input.signal;\n      if (!body && input._bodyInit != null) {\n        body = input._bodyInit;\n        input.bodyUsed = true;\n      }\n    } else {\n      this.url = String(input);\n    }\n\n    this.credentials = options.credentials || this.credentials || 'same-origin';\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers);\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET');\n    this.mode = options.mode || this.mode || null;\n    this.signal = options.signal || this.signal;\n    this.referrer = null;\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body);\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this, {body: this._bodyInit})\n  };\n\n  function decode(body) {\n    var form = new FormData();\n    body\n      .trim()\n      .split('&')\n      .forEach(function(bytes) {\n        if (bytes) {\n          var split = bytes.split('=');\n          var name = split.shift().replace(/\\+/g, ' ');\n          var value = split.join('=').replace(/\\+/g, ' ');\n          form.append(decodeURIComponent(name), decodeURIComponent(value));\n        }\n      });\n    return form\n  }\n\n  function parseHeaders(rawHeaders) {\n    var headers = new Headers();\n    // Replace instances of \\r\\n and \\n followed by at least one space or horizontal tab with a space\n    // https://tools.ietf.org/html/rfc7230#section-3.2\n    var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, ' ');\n    preProcessedHeaders.split(/\\r?\\n/).forEach(function(line) {\n      var parts = line.split(':');\n      var key = parts.shift().trim();\n      if (key) {\n        var value = parts.join(':').trim();\n        headers.append(key, value);\n      }\n    });\n    return headers\n  }\n\n  Body.call(Request.prototype);\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {};\n    }\n\n    this.type = 'default';\n    this.status = options.status === undefined ? 200 : options.status;\n    this.ok = this.status >= 200 && this.status < 300;\n    this.statusText = 'statusText' in options ? options.statusText : 'OK';\n    this.headers = new Headers(options.headers);\n    this.url = options.url || '';\n    this._initBody(bodyInit);\n  }\n\n  Body.call(Response.prototype);\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  };\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''});\n    response.type = 'error';\n    return response\n  };\n\n  var redirectStatuses = [301, 302, 303, 307, 308];\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  };\n\n  exports.DOMException = self.DOMException;\n  try {\n    new exports.DOMException();\n  } catch (err) {\n    exports.DOMException = function(message, name) {\n      this.message = message;\n      this.name = name;\n      var error = Error(message);\n      this.stack = error.stack;\n    };\n    exports.DOMException.prototype = Object.create(Error.prototype);\n    exports.DOMException.prototype.constructor = exports.DOMException;\n  }\n\n  function fetch(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request = new Request(input, init);\n\n      if (request.signal && request.signal.aborted) {\n        return reject(new exports.DOMException('Aborted', 'AbortError'))\n      }\n\n      var xhr = new XMLHttpRequest();\n\n      function abortXhr() {\n        xhr.abort();\n      }\n\n      xhr.onload = function() {\n        var options = {\n          status: xhr.status,\n          statusText: xhr.statusText,\n          headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n        };\n        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');\n        var body = 'response' in xhr ? xhr.response : xhr.responseText;\n        resolve(new Response(body, options));\n      };\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.ontimeout = function() {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.onabort = function() {\n        reject(new exports.DOMException('Aborted', 'AbortError'));\n      };\n\n      xhr.open(request.method, request.url, true);\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true;\n      } else if (request.credentials === 'omit') {\n        xhr.withCredentials = false;\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob';\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value);\n      });\n\n      if (request.signal) {\n        request.signal.addEventListener('abort', abortXhr);\n\n        xhr.onreadystatechange = function() {\n          // DONE (success or failure)\n          if (xhr.readyState === 4) {\n            request.signal.removeEventListener('abort', abortXhr);\n          }\n        };\n      }\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);\n    })\n  }\n\n  fetch.polyfill = true;\n\n  if (!self.fetch) {\n    self.fetch = fetch;\n    self.Headers = Headers;\n    self.Request = Request;\n    self.Response = Response;\n  }\n\n  exports.Headers = Headers;\n  exports.Request = Request;\n  exports.Response = Response;\n  exports.fetch = fetch;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n  return exports;\n\n}({}));\n})(__self__);\n__self__.fetch.ponyfill = true;\n// Remove \"polyfill\" property added by whatwg-fetch\ndelete __self__.fetch.polyfill;\n// Choose between native implementation (global) or custom implementation (__self__)\n// var ctx = global.fetch ? global : __self__;\nvar ctx = __self__; // this line disable service worker support temporarily\nexports = ctx.fetch // To enable: import fetch from 'cross-fetch'\nexports.default = ctx.fetch // For TypeScript consumers without esModuleInterop.\nexports.fetch = ctx.fetch // To enable: import {fetch} from 'cross-fetch'\nexports.Headers = ctx.Headers\nexports.Request = ctx.Request\nexports.Response = ctx.Response\nmodule.exports = exports\n","import { POST_TYPES, AuthPostResponse, Globals, StatusResponse } from \"./types\";\nimport _g from \"./g\";\nimport utilsFactory from \"./utils\";\nimport fetch from 'cross-fetch';\n\nexport default function authFactory(globals?: Globals): any {\n    const g = globals || _g;\n\n    const { generateBareUrl, generateAuthBody, log } = utilsFactory(g);\n\n    const getUserAttributes = async (): Promise<Record<string, string>> => {\n        try {\n            const attrsRes = await tokenPost(POST_TYPES.USER_ATTRIBUTES);\n            return attrsRes.data;   \n        } catch (error) {\n            return error;\n        }\n    }\n\n    const setUserAttribute = async (key: string, value: string): Promise<StatusResponse> => {\n        try {\n            const setAttrsRes = await tokenPost(POST_TYPES.SET_ATTRIBUTE, {\n                key,\n                value\n            });\n\n            return {\n                success: setAttrsRes.success,\n                message: JSON.stringify(setAttrsRes.data)\n            };\n        } catch (error) {\n            return {\n                success: false,\n                message: \"Error\",\n                error\n            };\n        }\n    }\n\n    const signUp = async (newUserID: string, password: string, userAttributes?: Record<string, string>): Promise<StatusResponse> => {\n        try {\n            const signUpRes = await tokenPost(POST_TYPES.SIGN_UP, {\n                newUserID,\n                password,\n                userAttributes\n            });\n            return {\n                success: signUpRes.success,\n                message: signUpRes.data\n            }   \n        } catch (error) {\n            return {\n                success: false,\n                message: \"Error\",\n                error\n            }\n        }\n    }\n\n    const signIn = async (userID: string, password: string): Promise<StatusResponse> => {\n        const t1 = Date.now();\n        g.session = Math.floor(100000000 + Math.random() * 900000000);\n    \n        const integrationType = g.ebconfig.integration.split(\"-\")[0].toUpperCase() === \"PROJECT\" ? \"PROJECT\" : \"REACT\";\n\n        try {\n            const res = await fetch(generateBareUrl(integrationType, g.integrationID), {\n                method: \"POST\",\n                headers: {\n                    'Eb-Post-Req': POST_TYPES.HANDSHAKE,\n                    'Accept': 'application/json',\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                    version: g.ebconfig.version,\n                    session: g.session,\n                    instance: g.instance,\n                    userID,\n                    password\n                })\n            });\n\n            const resData = await res.json();\n    \n            if (resData.token) {\n                g.token = resData.token;\n                g.refreshToken = resData.refreshToken;\n                g.newTokenCallback();\n                g.mounted = true;\n                const validTokenRes = await tokenPost(POST_TYPES.VALID_TOKEN);\n                const elapsed = Date.now() - t1;\n                if (validTokenRes.success) {\n                    log(\"Valid auth initiation in \" + elapsed + \"ms\");\n                    return {\n                        success: true,\n                        message: \"Successfully signed in user\"\n                    };\n                } else {\n                    return {\n                        success: false,\n                        message: \"Could not sign in user\"\n                    };\n                }\n            } else {\n                return {\n                    success: false,\n                    message: \"Could not sign in user\"\n                };\n            }\n        } catch (error) {\n            console.error(error);\n            return {\n                success: false,\n                message: error,\n                error\n            };\n        }\n    }\n\n    const resetUserPassword = async (newPassword: string): Promise<StatusResponse> => {\n        if (typeof newPassword !== \"string\" || newPassword.length > 100) {\n            return {\n                success: false,\n                message: \"newPassword must be of type string\"\n            };\n        }\n        \n        try {\n            const setAttrsRes = await tokenPost(POST_TYPES.RESET_PASSWORD, { newPassword });\n\n            return {\n                success: setAttrsRes.success,\n                message: JSON.stringify(setAttrsRes.data)\n            };\n        } catch (error) {\n            return {\n                success: false,\n                message: \"Error\",\n                error\n            };\n        }\n    }\n    \n    const isUserSignedIn = (): boolean => g.token.length > 0;\n\n    const signOut = (): void => {\n        g.token = \"\";\n        g.newTokenCallback();\n    }\n\n    const initAuth = async (): Promise<boolean> => {\n        const t1 = Date.now();\n        g.session = Math.floor(100000000 + Math.random() * 900000000);\n    \n        log(`Handshaking on${g.instance} instance`);\n    \n        const integrationType = g.ebconfig.integration.split(\"-\")[0].toUpperCase() === \"PROJECT\" ? \"PROJECT\" : \"REACT\";\n\n        try {\n\n            const res = await fetch(generateBareUrl(integrationType, g.integrationID), {\n                method: \"POST\",\n                headers: {\n                    'Eb-Post-Req': POST_TYPES.HANDSHAKE,\n                    'Accept': 'application/json',\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                    version: g.ebconfig.version,\n                    tt: g.ebconfig.tt,\n                    session: g.session,\n                    instance: g.instance\n                })\n            });\n\n            const resData = await res.json();\n    \n            if (resData.token) {\n                g.token = resData.token;\n                g.mounted = true;\n                const validTokenRes = await tokenPost(POST_TYPES.VALID_TOKEN);\n                const elapsed = Date.now() - t1;\n                if (validTokenRes.success) {\n                    log(\"Valid auth initiation in \" + elapsed + \"ms\");\n                    return true;\n                } else {\n                    return false;\n                }\n            } else {\n                return false;\n            }\n        } catch (error) {\n            console.error(error);\n            return false;\n        }\n    }\n    \n    const tokenPost = async (postType: POST_TYPES, body?: {}): Promise<AuthPostResponse> => {\n        if (!g.mounted) {\n            await initAuth();\n        }\n\n        const integrationType = g.ebconfig.integration.split(\"-\")[0].toUpperCase() === \"PROJECT\" ? \"PROJECT\" : \"REACT\";\n\n        try {\n            const res = await fetch(generateBareUrl(integrationType, g.integrationID), {\n                method: \"POST\",\n                headers: {\n                    'Eb-Post-Req': postType,\n                    'Accept': 'application/json',\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                    _auth: generateAuthBody(),\n                    ...body\n                })\n            });\n\n            const resData = await res.json();\n\n            if ({}.hasOwnProperty.call(resData, 'ErrorCode') || {}.hasOwnProperty.call(resData, 'code')) {\n                if (resData.code === \"JWT EXPIRED\") {\n                    if (integrationType === \"PROJECT\") {\n                        const req_res = await tokenPost(POST_TYPES.REQUEST_TOKEN, {\n                            refreshToken: g.refreshToken,\n                            token: g.token\n                        });\n\n                        if (req_res.success) {\n                            g.token = req_res.data.token\n                            g.newTokenCallback();\n                            return tokenPost(postType, body);\n                        } else {\n                            g.token = \"\";\n                            g.refreshToken = \"\";\n                            g.newTokenCallback();\n                            return {\n                                success: false,\n                                data: req_res.data\n                            }\n                        }\n                    } else {\n                        await initAuth();\n                    }\n                    return tokenPost(postType, body);\n                }\n    \n                return {\n                    success: false,\n                    data: resData.body\n                }\n            } else {\n                return {\n                    success: resData.success,\n                    data: resData.body\n                }\n            }\n        } catch (error) {\n            return {\n                success: false,\n                data: error\n            }\n        }\n    }\n    \n    const tokenPostAttachment = async (formData: FormData, customHeaders: {}): Promise<AuthPostResponse> => {\n\n        if (!g.mounted) {\n            await initAuth();\n        }\n\n        const regularAuthbody = generateAuthBody();\n    \n        const attachmentAuth = {\n            'Eb-token': regularAuthbody.token,\n            'Eb-token-time': regularAuthbody.token_time,\n            'Eb-now': regularAuthbody.now\n        };\n    \n        const integrationType = g.ebconfig.integration.split(\"-\")[0].toUpperCase() === \"PROJECT\" ? \"PROJECT\" : \"REACT\";\n\n        try {\n            const res = await fetch(generateBareUrl(integrationType, g.integrationID), {\n                method: \"POST\",\n                headers: {\n                    'Eb-Post-Req': POST_TYPES.UPLOAD_ATTACHMENT,\n                    ...customHeaders,\n                    ...attachmentAuth\n                },\n                body: formData\n            });\n\n            const resData = await res.json();\n\n            if ({}.hasOwnProperty.call(resData, 'ErrorCode') || {}.hasOwnProperty.call(resData, 'code')) {\n                if (resData.code === \"JWT EXPIRED\") {\n                    if (integrationType === \"PROJECT\") {\n                        const req_res = await tokenPost(POST_TYPES.REQUEST_TOKEN, {\n                            refreshToken: g.refreshToken,\n                            token: g.token\n                        });\n\n                        if (req_res.success) {\n                            g.token = req_res.data.token\n                            g.newTokenCallback();\n                            return tokenPostAttachment(formData, customHeaders);\n                        } else {\n                            g.token = \"\";\n                            g.refreshToken = \"\";\n                            g.newTokenCallback();\n                            return {\n                                success: false,\n                                data: req_res.data\n                            }\n                        }\n                    } else {\n                        await initAuth();\n                    }\n                    return tokenPostAttachment(formData, customHeaders);\n                }\n    \n                return {\n                    success: false,\n                    data: resData.body\n                }\n            } else {\n                return {\n                    success: resData.success,\n                    data: resData.body\n                }\n            }\n        } catch (error) {\n            return {\n                success: false,\n                data: error\n            }\n        }\n    }\n    \n    return {\n        initAuth,\n        tokenPost,\n        tokenPostAttachment,\n        signUp,\n        setUserAttribute,\n        getUserAttributes,\n        isUserSignedIn,\n        signIn,\n        signOut,\n        resetUserPassword\n    }\n}\n","import {\n    POST_TYPES,\n    QueryOptions,\n    Globals\n} from \"./types\";\nimport _g from \"./g\";\n\nimport authFactory from \"./auth\";\n\nexport default function tableFactory(globals?: Globals): any {\n\n    const g = globals || _g;\n\n    const { tokenPost } = authFactory(g);\n\n    const Query = async (options: QueryOptions): Promise<Record<string, any>[]> => {\n        const defaultOptions: QueryOptions = {\n            queryName: \"\"\n        }\n    \n        const fullOptions: QueryOptions = { ...defaultOptions, ...options };\n    \n        try {\n            const res = await tokenPost(POST_TYPES.GET_QUERY, fullOptions);\n            return res.data\n        } catch (error) {\n            return [];\n        }\n    }\n\n    async function fullTableSize(): Promise<number>;\n    async function fullTableSize(tableName: string): Promise<number>;\n    async function fullTableSize(tableName?: string): Promise<number> {\n        const res = await tokenPost(POST_TYPES.TABLE_SIZE, tableName ? { tableName } : {});\n        if (res.success) {\n            return res.data;\n        } else {\n            return 0;\n        }\n    }\n\n    async function tableTypes(): Promise<Record<string, any>>;\n    async function tableTypes(tableName: string): Promise<Record<string, any>>\n    async function tableTypes(tableName?: string): Promise<Record<string, any>> {\n        const res = await tokenPost(POST_TYPES.COLUMN_TYPES, tableName ? { tableName } : {});\n        if (res.success) {\n            return res.data;\n        } else {\n            return {};\n        }\n    }\n\n    return {\n        Query,\n        fullTableSize,\n        tableTypes\n    };\n}","import _g from \"./g\";\nimport easyqb from 'EasyQB';\nimport { SQW } from \"EasyQB/types/sq\";\nimport { NewExpression } from \"EasyQB/types/expression\";\nimport authFactory from \"./auth\";\nimport { POST_TYPES, DB_STATUS, Globals, EXECUTE_COUNT } from \"./types\";\n\ninterface IdbFactory {\n    db: (tableName?: string, userAssociatedRecordsOnly?: boolean) => SQW;\n    dbEventListener: (callback: (status?: DB_STATUS, queryType?: string, executeCount?: EXECUTE_COUNT, tableName?: string | null, returned?: any) => void) => () => void;\n    e: NewExpression;\n}\n\nexport default function dbFactory(globals?: Globals): IdbFactory {\n    const g = globals || _g;\n    const { tokenPost } = authFactory(g);\n    let _listenerIndex = 0;\n\n    const _listeners: Record<string, (status?: DB_STATUS, queryType?: string, executeCount?: EXECUTE_COUNT, tableName?: string | null, returned?: any) => void> = {};\n\n    function _runListeners(...params: any[]) {\n        for (const cb of Object.values(_listeners)) {\n            cb(...params)\n        }\n    }\n\n    const dbEventListener = (callback: (status?: DB_STATUS, queryType?: string, executeCount?: EXECUTE_COUNT, tableName?: string | null, returned?: any) => void): () => void => {\n        const currKey = '' + _listenerIndex++;\n        _listeners[currKey] = callback;\n        return () => {\n            delete _listeners[currKey]\n        }\n    }\n\n    const allCallback = async (trx: any, tableName: string, userAssociatedRecordsOnly?: boolean): Promise<Record<string, any>[] | number[]> => {\n        trx.count = \"all\";\n        trx.tableName = tableName;\n        if (userAssociatedRecordsOnly) trx.userAssociatedRecordsOnly = userAssociatedRecordsOnly;\n        _runListeners(DB_STATUS.PENDING, trx.type, EXECUTE_COUNT.ALL, tableName !== \"untable\" ? tableName : null);\n        const res = await tokenPost(POST_TYPES.EASY_QB, trx);\n        if (res.success) {\n            _runListeners(DB_STATUS.SUCCESS, trx.type, EXECUTE_COUNT.ALL, tableName !== \"untable\" ? tableName : null, res.data);\n            return res.data;\n        } else {\n            _runListeners(DB_STATUS.ERROR, trx.type, EXECUTE_COUNT.ALL, tableName !== \"untable\" ? tableName : null);\n            return res;\n        }\n    }\n\n    const oneCallback = async (trx: any, tableName: string, userAssociatedRecordsOnly?: boolean): Promise<Record<string, any> | number> => {\n        trx.count = \"one\";\n        trx.tableName = tableName;\n        if (userAssociatedRecordsOnly) trx.userAssociatedRecordsOnly = userAssociatedRecordsOnly;\n        _runListeners(DB_STATUS.PENDING, trx.type, EXECUTE_COUNT.ONE, tableName !== \"untable\" ? tableName : null);\n        const res = await tokenPost(POST_TYPES.EASY_QB, trx);\n        if (res.success) {\n            _runListeners(DB_STATUS.SUCCESS, trx.type, EXECUTE_COUNT.ONE, tableName !== \"untable\" ? tableName : null, res.data);\n            return res.data;\n        } else {\n            _runListeners(DB_STATUS.ERROR, trx.type, EXECUTE_COUNT.ONE, tableName !== \"untable\" ? tableName : null);\n            return res;\n        }\n    }\n\n    const db = (tableName?: string, userAssociatedRecordsOnly?: boolean) => {\n        if (tableName && typeof tableName === \"string\") {\n            return easyqb({ allCallback, oneCallback, userAssociatedRecordsOnly, tableName: tableName.toUpperCase() })(tableName.replace(/[^0-9a-zA-Z]/g, '_').toUpperCase());\n        } else {\n            return easyqb({ allCallback, oneCallback, userAssociatedRecordsOnly, tableName: \"untable\" })(\"untable\");\n        }\n    }\n    \n    return {\n        db,\n        dbEventListener,\n        e: easyqb().e\n    }\n}\n","import { Globals } from \"./types\";\nimport Storage from 'react-native-storage';\n\nlet storage: Storage;\n\nif ((typeof navigator !== 'undefined' && navigator.product === 'ReactNative')) {\n    import('@react-native-community/async-storage').then(AsyncStorage => {\n        storage = new Storage({ storageBackend: AsyncStorage.default });\n    })\n} else {\n    storage = new Storage({ storageBackend: window.localStorage });\n}\n\n// https://github.com/sunnylqm/react-native-storage\nexport async function getCacheTokens(cookieName: string): Promise<Record<string, any>> {\n    let cacheToken = false;\n    let cacheRefreshToken = false;\n    let cacheSession = false;\n\n    try {\n        cacheToken = await storage.load({ key: cookieName + \"token\" });\n    } catch (_) {}\n\n    try {\n        cacheRefreshToken = await storage.load({ key: cookieName + \"refreshToken\" });\n    } catch (_) {}\n\n    try {\n        cacheSession = await storage.load({ key: cookieName + \"session\" });\n    } catch (_) {}\n\n    return {\n        cacheToken,\n        cacheRefreshToken,\n        cacheSession\n    }\n}\n\nexport async function clearCacheTokens(cookieName: string) {\n    await storage.remove({ key: cookieName + \"token\" });\n    await storage.remove({ key: cookieName + \"refreshToken\" });\n    await storage.remove({ key: cookieName + \"session\" });\n}\n\nexport async function setCacheTokens(g: Globals, cookieName: string) {\n    await storage.save({\n        key: cookieName + \"token\",\n        data: g.token,\n        expires: 3600 * 1000 * 24\n    });\n\n    await storage.save({\n        key: cookieName + \"refreshToken\",\n        data: g.refreshToken,\n        expires: 3600 * 1000 * 24\n    });\n\n    await storage.save({\n        key: cookieName + \"session\",\n        data: g.session,\n        expires: null\n    });\n}\n","import React, { useState, useEffect, Fragment, useRef } from \"react\";\nimport EasybaseContext from \"./EasybaseContext\";\nimport deepEqual from \"fast-deep-equal\";\nimport {\n    POST_TYPES,\n    FrameConfiguration,\n    FileFromURI,\n    AddRecordOptions,\n    UpdateRecordAttachmentOptions,\n    StatusResponse,\n    ConfigureFrameOptions,\n    DeleteRecordOptions,\n    EasybaseProviderProps,\n    ContextValue,\n    DB_STATUS,\n    EXECUTE_COUNT,\n    UseReturnValue\n} from \"./types\";\nimport imageExtensions from \"./assets/image-extensions.json\";\nimport videoExtensions from \"./assets/video-extensions.json\";\nimport utilsFactory from \"../node_modules/easybasejs/src/EasybaseProvider/utils\";\nimport tableFactory from \"../node_modules/easybasejs/src/EasybaseProvider/table\";\nimport authFactory from \"../node_modules/easybasejs/src/EasybaseProvider/auth\";\nimport dbFactory from \"../node_modules/easybasejs/src/EasybaseProvider/db\";\nimport { gFactory } from \"../node_modules/easybasejs/src/EasybaseProvider/g\";\nimport { Observable } from \"object-observer\";\nimport * as cache from \"./cache\";\nimport { SQW } from \"EasyQB/types/sq\";\n\nconst g = gFactory();\n\nconst {\n    initAuth,\n    tokenPost,\n    tokenPostAttachment,\n    signUp,\n    setUserAttribute,\n    getUserAttributes,\n    resetUserPassword,\n    signIn,\n    signOut\n} = authFactory(g);\n\nconst { log } = utilsFactory(g);\n\nconst {\n    Query,\n    fullTableSize,\n    tableTypes\n} = tableFactory(g);\n\nconst {\n    db,\n    dbEventListener,\n    e\n} = dbFactory(g);\n\nlet _isFrameInitialized: boolean = true;\n\nlet _frameConfiguration: FrameConfiguration = {\n    offset: 0,\n    limit: 0\n};\n\nlet _effect: React.EffectCallback = () => () => { };\nlet _signInCallback: () => void;\n\nconst _observedChangeStack: Record<string, any>[] = [];\nlet _recordIdMap: WeakMap<Record<string, any>, \"string\"> = new WeakMap();\nlet _proxyRecordMap: WeakMap<Record<string, any>, \"string\"> = new WeakMap();\n\nconst EasybaseProvider = ({ children, ebconfig, options }: EasybaseProviderProps) => {\n    const [mounted, setMounted] = useState<boolean>(false);\n    const [isSyncing, setIsSyncing] = useState<boolean>(false);\n    const [userSignedIn, setUserSignedIn] = useState<boolean>(false);\n\n    const [_frame, _setFrame] = useState<Record<string, any>[]>([]);\n    const [_observableFrame, _setObservableFrame] = useState<any>({\n        observe: () => { },\n        unobserve: () => { }\n    });\n\n    const _ranSignInCallback = useRef<boolean>(false);\n\n    if (typeof ebconfig !== 'object' || ebconfig === null || ebconfig === undefined) {\n        console.error(\"No ebconfig object passed. do `import ebconfig from \\\"ebconfig.json\\\"` and pass it to the Easybase provider\");\n        return (\n            <Fragment>\n                {children}\n            </Fragment>\n        );\n    } else if (!ebconfig.integration) {\n        console.error(\"Invalid ebconfig object passed. Download ebconfig.json from Easybase.io and try again.\");\n        return (\n            <Fragment>\n                {children}\n            </Fragment>\n        );\n    }\n\n    useEffect(() => {\n        const mount = async () => {\n            // eslint-disable-next-line dot-notation\n            const isIE = typeof document !== 'undefined' && !!document['documentMode'];\n\n            if (isIE) {\n                console.error(\"EASYBASE â€” easybase-react does not support Internet Explorer. Please use a different browser.\");\n            }\n\n            g.instance = (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') ? \"React Native\" : \"React\";\n            g.options = { ...options };\n            g.integrationID = ebconfig.integration;\n            g.ebconfig = ebconfig;\n\n            if (g.ebconfig.tt && g.ebconfig.integration.split(\"-\")[0].toUpperCase() !== \"PROJECT\") {\n                const t1 = Date.now();\n                log(\"mounting...\");\n                await initAuth();\n                const res = await tokenPost(POST_TYPES.VALID_TOKEN);\n                const elapsed = Date.now() - t1;\n                if (res.success) {\n                    log(\"Valid auth initiation in \" + elapsed + \"ms\");\n                    setMounted(true);\n                }\n            } else {\n                g.mounted = true; // Bypass initAuth()\n\n                const cookieName = g.ebconfig.integration.slice(-10);\n\n                const {\n                    cacheToken,\n                    cacheRefreshToken,\n                    cacheSession\n                } = await cache.getCacheTokens(cookieName);\n\n                if (cacheRefreshToken) {\n                    g.token = cacheToken;\n                    g.refreshToken = cacheRefreshToken;\n                    g.session = +cacheSession;\n\n                    const fallbackMount = setTimeout(() => { setMounted(true) }, 2500);\n\n                    const refreshTokenRes = await tokenPost(POST_TYPES.REQUEST_TOKEN, {\n                        refreshToken: g.refreshToken,\n                        token: g.token\n                    });\n\n                    if (refreshTokenRes.success) {\n                        clearTimeout(fallbackMount);\n                        g.token = refreshTokenRes.data.token;\n                        await cache.setCacheTokens(g, cookieName);\n                        setUserSignedIn(true);\n                    } else {\n                        cache.clearCacheTokens(cookieName);\n                    }\n                }\n\n                setMounted(true);\n            }\n        }\n\n        mount();\n    }, []);\n\n    const useFrameEffect = (effect: React.EffectCallback) => {\n        _effect = effect;\n    };\n\n    useEffect(() => {\n        if (userSignedIn === true && _ranSignInCallback.current === false && _signInCallback !== undefined) {\n            _signInCallback();\n            _ranSignInCallback.current = true;\n        }\n    }, [userSignedIn])\n\n    const onSignIn = (callback: () => void) => {\n        _signInCallback = callback;\n\n        if (userSignedIn === true && _ranSignInCallback.current === false && _signInCallback !== undefined) {\n            _signInCallback();\n            _ranSignInCallback.current = true;\n        }\n    }\n\n    useEffect(() => {\n        _observableFrame.observe((allChanges: any[]) => {\n            allChanges.forEach((change: any) => {\n                _observedChangeStack.push({\n                    type: change.type,\n                    path: change.path,\n                    value: change.value,\n                    _id: _recordIdMap.get(_frame[Number(change.path[0])])\n                    // Not bringing change.object or change.oldValue\n                });\n                log(JSON.stringify({\n                    type: change.type,\n                    path: change.path,\n                    value: change.value,\n                    _id: _recordIdMap.get(_frame[Number(change.path[0])])\n                    // Not bringing change.object or change.oldValue\n                }))\n            });\n        });\n\n        _proxyRecordMap = new WeakMap();\n        _frame.forEach((_: any, i: number) => _proxyRecordMap.set(_observableFrame[i], \"\" + i as any))\n\n        _effect(); // call useFrameEffect\n    }, [_observableFrame]);\n\n    useEffect(() => {\n        _observableFrame.unobserve();\n        _setObservableFrame(Observable.from(_frame));\n    }, [_frame]);\n\n    function Frame(): Record<string, any>[];\n    function Frame(index: number): Record<string, any>;\n    function Frame(index?: number): Record<string, any>[] | Record<string, any> {\n        if (typeof index === \"number\") {\n            return _observableFrame[index];\n        } else {\n            return _observableFrame;\n        }\n    }\n\n    const _recordIDExists = (record: Record<string, any>): Boolean => !!_recordIdMap.get(record) || !!_recordIdMap.get(_getRawRecordFromProxy(record) || {});\n    const _getRawRecordFromProxy = (proxyRecord: Record<string, any>): Record<string, any> | undefined => _proxyRecordMap.get(proxyRecord) ? _frame[+_proxyRecordMap.get(proxyRecord)!] : undefined\n\n    const configureFrame = (options: ConfigureFrameOptions): StatusResponse => {\n        _frameConfiguration = { ..._frameConfiguration };\n\n        if (options.limit !== undefined) _frameConfiguration.limit = options.limit;\n        if (options.offset !== undefined && options.offset >= 0) _frameConfiguration.offset = options.offset;\n        if (options.tableName !== undefined) _frameConfiguration.tableName = options.tableName;\n\n        _isFrameInitialized = false;\n        return {\n            message: \"Successfully configured frame. Run sync() for changes to be shown in frame\",\n            success: true\n        }\n    }\n\n    const currentConfiguration = (): FrameConfiguration => ({ ..._frameConfiguration });\n\n    const addRecord = async (options: AddRecordOptions): Promise<StatusResponse> => {\n        const defaultValues: AddRecordOptions = {\n            insertAtEnd: false,\n            newRecord: {},\n            tableName: undefined\n        }\n\n        const fullOptions: AddRecordOptions = { ...defaultValues, ...options };\n\n        try {\n            const res = await tokenPost(POST_TYPES.SYNC_INSERT, fullOptions);\n            return {\n                message: res.data,\n                success: res.success\n            }\n        } catch (err) {\n            console.error(\"Easybase Error: addRecord failed \", err);\n            return {\n                message: \"Easybase Error: addRecord failed \" + err,\n                success: false,\n                error: err\n            }\n        }\n    }\n\n    const deleteRecord = async (options: DeleteRecordOptions): Promise<StatusResponse> => {\n        const _frameRecord = _getRawRecordFromProxy(options.record) || _frame.find(ele => deepEqual(ele, options.record));\n\n        if (_frameRecord && _recordIdMap.get(_frameRecord)) {\n            const res = await tokenPost(POST_TYPES.SYNC_DELETE, {\n                _id: _recordIdMap.get(_frameRecord),\n                tableName: options.tableName\n            });\n            return {\n                success: res.success,\n                message: res.data\n            }\n        } else {\n            try {\n                const res = await tokenPost(POST_TYPES.SYNC_DELETE, {\n                    record: options.record,\n                    tableName: options.tableName\n                });\n                return {\n                    success: res.success,\n                    message: res.data\n                }\n            } catch (err) {\n                console.error(\"Easybase Error: deleteRecord failed \", err);\n                return {\n                    success: false,\n                    message: \"Easybase Error: deleteRecord failed \" + err,\n                    error: err\n                }\n            }\n        }\n    }\n\n    // Only allow the deletion of one element at a time\n    // First handle shifting of the array size. Then iterate\n    const sync = async (): Promise<StatusResponse> => {\n        const _realignFrames = (newData: Record<string, any>[]) => {\n            let isNewDataTheSame = true;\n\n            if (newData.length !== _frame.length) {\n                isNewDataTheSame = false;\n            } else {\n                for (let i = 0; i < newData.length; i++) {\n                    const newDataNoId = { ...newData[i] };\n                    delete newDataNoId._id;\n                    if (!deepEqual(newDataNoId, _frame[i])) {\n                        isNewDataTheSame = false;\n                        break;\n                    }\n                }\n            }\n\n            if (!isNewDataTheSame) {\n                _recordIdMap = new WeakMap();\n                _frame.length = newData.length;\n\n                newData.forEach((currNewEle, i) => {\n                    _frame[i] = currNewEle;\n                    _recordIdMap.set(currNewEle, currNewEle._id);\n                    delete currNewEle._id;\n                });\n                _setFrame([..._frame]);\n            }\n        }\n\n        if (isSyncing) {\n            return {\n                success: false,\n                message: \"Easybase Error: the provider is currently syncing, use 'await sync()' before calling sync() again\"\n            };\n        }\n        setIsSyncing(true);\n\n        if (_isFrameInitialized) {\n            if (_observedChangeStack.length > 0) {\n                log(\"Stack change: \", _observedChangeStack);\n                const res = await tokenPost(POST_TYPES.SYNC_STACK, {\n                    stack: _observedChangeStack,\n                    ..._frameConfiguration\n                });\n                if (res.success) {\n                    _observedChangeStack.length = 0;\n                }\n            }\n        }\n\n        try {\n            const res = await tokenPost(POST_TYPES.GET_FRAME, _frameConfiguration);\n\n            // Check if the array received from db is the same as frame\n            // If not, update it and send useFrameEffect\n\n            if (res.success === false) {\n                console.error(res.data);\n                setIsSyncing(false);\n                return {\n                    success: false,\n                    message: \"\" + res.data\n                }\n            } else {\n                _isFrameInitialized = true;\n                _realignFrames(res.data);\n                setIsSyncing(false);\n                return {\n                    message: 'Success. Call frame for data',\n                    success: true\n                }\n            }\n        } catch (err) {\n            console.error(\"Easybase Error: get failed \", err);\n            setIsSyncing(false);\n            return {\n                success: false,\n                message: \"Easybase Error: get failed \" + err,\n                error: err\n            }\n        }\n    }\n\n    const updateRecordImage = async (options: UpdateRecordAttachmentOptions): Promise<StatusResponse> => {\n        const res = await _updateRecordAttachment(options, \"image\");\n        return res;\n    }\n    const updateRecordVideo = async (options: UpdateRecordAttachmentOptions): Promise<StatusResponse> => {\n        const res = await _updateRecordAttachment(options, \"video\");\n        return res;\n    }\n    const updateRecordFile = async (options: UpdateRecordAttachmentOptions): Promise<StatusResponse> => {\n        const res = await _updateRecordAttachment(options, \"file\");\n        return res;\n    }\n\n    const _updateRecordAttachment = async (options: UpdateRecordAttachmentOptions, type: string): Promise<StatusResponse> => {\n        const _frameRecord: Record<string, any> | undefined = _getRawRecordFromProxy(options.record) || _frame.find(ele => deepEqual(ele, options.record));\n\n        if (_frameRecord === undefined || !_recordIDExists(_frameRecord)) {\n            log(\"Attempting to add attachment to a new record that has not been synced. Please sync() before trying to add attachment.\");\n            return {\n                success: false,\n                message: \"Attempting to add attachment to a new record that has not been synced. Please sync() before trying to add attachment.\"\n            }\n        }\n\n        const ext: string = options.attachment.name.split(\".\").pop()!.toLowerCase();\n\n        log(ext);\n\n        if (type === \"image\" && !imageExtensions.includes(ext)) {\n            return {\n                success: false,\n                message: \"Image files must have a proper image extension in the file name\"\n            };\n        }\n\n        if (type === \"video\" && !videoExtensions.includes(ext)) {\n            return {\n                success: false,\n                message: \"Video files must have a proper video extension in the file name\"\n            };\n        }\n\n        function isFileFromURI(f: File | FileFromURI): f is FileFromURI {\n            return (f as FileFromURI).uri !== undefined;\n        }\n\n        const formData = new FormData();\n\n        if (isFileFromURI(options.attachment)) {\n            formData.append(\"file\", options.attachment as any);\n            formData.append(\"name\", options.attachment.name);\n        } else {\n            formData.append(\"file\", options.attachment);\n            formData.append(\"name\", options.attachment.name);\n        }\n\n        const customHeaders = {\n            'Eb-upload-type': type,\n            'Eb-column-name': options.columnName,\n            'Eb-record-id': _recordIdMap.get(_frameRecord),\n            'Eb-table-name': options.tableName\n        }\n\n        const res = await tokenPostAttachment(formData, customHeaders);\n\n        await sync();\n\n        return {\n            message: res.data,\n            success: res.success\n        };\n    }\n\n    const isUserSignedIn = (): boolean => userSignedIn;\n\n    g.newTokenCallback = () => {\n        const cookieName = g.ebconfig.integration.slice(-10);\n\n        if (!g.token) {\n            // User signed out\n            cache.clearCacheTokens(cookieName).then(_ => {\n                setUserSignedIn(false);\n                _ranSignInCallback.current = false;\n            });\n        } else {\n            // User signed in or refreshed token\n            cache.setCacheTokens(g, cookieName).then(_ => {\n                setUserSignedIn(true);\n            });\n        }\n    }\n\n    const useReturn = (dbInstance: () => SQW, deps?: React.DependencyList): UseReturnValue => {\n        // eslint-disable-next-line no-extra-parens\n        const [unsubscribe, setUnsubscribe] = useState<() => void>(() => () => { });\n        const [frame, setFrame] = useState<Record<string, any>[]>([]);\n        const [error, setError] = useState<any>(null);\n        const [loading, setLoading] = useState<boolean>(false);\n        const [dead, setDead] = useState<boolean>(false);\n\n        const doFetch = async (): Promise<void> => {\n            setLoading(true);\n            try {\n                const res = await dbInstance().all();\n                if (Array.isArray(res)) {\n                    setFrame(res as Record<string, any>[]);\n                }\n            } catch (error) {\n                setError(error);\n            }\n            setLoading(false);\n        }\n\n        useEffect(() => {\n            let isAlive = true;\n            if (!dead) {\n                const _instanceTableName: string = (dbInstance() as any)._tableName;\n                (unsubscribe as any)(\"true\");\n\n                const _listener = dbEventListener((status?: DB_STATUS, queryType?: string, executeCount?: EXECUTE_COUNT, tableName?: string | null, returned?: any) => {\n                    if (!isAlive) {\n                        return;\n                    }\n                    log(_instanceTableName, status, queryType, executeCount, tableName)\n                    if ((tableName === null && _instanceTableName === \"untable\") || tableName === _instanceTableName) {\n                        if (status === DB_STATUS.SUCCESS && queryType !== \"select\") {\n                            if (typeof returned === \"number\" && returned > 0) {\n                                doFetch();\n                            } else if (Array.isArray(returned) && typeof returned[0] === \"number\" && returned[0] > 0) {\n                                doFetch();\n                            }\n                        }\n                    }\n                });\n                \n                setUnsubscribe(() => (stayAlive?: string) => {\n                    _listener();\n                    stayAlive !== \"true\" && setDead(true);\n                });\n\n                doFetch();\n            }\n            return () => { isAlive = false; }\n        }, deps || []);\n\n        return {\n            frame,\n            unsubscribe,\n            error,\n            manualFetch: doFetch,\n            loading\n        };\n    };\n\n    const c: ContextValue = {\n        configureFrame,\n        addRecord,\n        deleteRecord,\n        sync,\n        updateRecordImage,\n        updateRecordVideo,\n        updateRecordFile,\n        Frame,\n        useFrameEffect,\n        fullTableSize,\n        tableTypes,\n        currentConfiguration,\n        Query,\n        signIn,\n        signOut,\n        isUserSignedIn,\n        signUp,\n        setUserAttribute,\n        getUserAttributes,\n        resetUserPassword,\n        onSignIn,\n        db,\n        dbEventListener,\n        e,\n        useReturn\n    }\n\n    return (\n        <EasybaseContext.Provider value={c}>\n            {mounted && children}\n        </EasybaseContext.Provider>\n    )\n}\n\nexport default EasybaseProvider;\n","import { useContext } from \"react\";\nimport EasybaseContext from \"./EasybaseContext\";\n\nconst useEasybase = () => {\n    const easybase = useContext(EasybaseContext);\n    return easybase;\n}\n\nexport default useEasybase;\n","import { callFunction as _callFunction } from 'easybasejs';\n\n/**\n * @async\n * Call a cloud function, created in Easybase interface.\n * @param {string} route Route as detailed in Easybase. Found under 'Deploy'. Will be in the form of ####...####-function-name.\n * @param {Record<string, any>} postBody Optional object to pass as the body of the POST request. This object will available in your cloud function's event.body.\n * @return {Promise<string>} Response from your cloud function. Detailed with a call to 'return context.succeed(\"RESPONSE\")'.\n */\nexport const callFunction = _callFunction;\n"]},"metadata":{},"sourceType":"module"}