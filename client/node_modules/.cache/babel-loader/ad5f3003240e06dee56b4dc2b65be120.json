{"ast":null,"code":"////////////////////////////////////////////////////////////////////////////\n//\n// Copyright 2020 Realm Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n////////////////////////////////////////////////////////////////////////////\n\n/**\n * TODO: Determine if the shape of an error response is specific to each service or widely used\n */\nclass MongoDBRealmError extends Error {\n  constructor(method, url, statusCode, statusText, response) {\n    if (typeof response === \"object\" && typeof response.error === \"string\") {\n      const statusSummary = statusText ? `status ${statusCode} ${statusText}` : `status ${statusCode}`;\n      super(`Request failed (${method} ${url}): ${response.error} (${statusSummary})`);\n      this.method = method;\n      this.url = url;\n      this.statusText = statusText;\n      this.statusCode = statusCode;\n      this.errorCode = response.error_code;\n      this.link = response.link;\n    } else {\n      throw new Error(\"Unexpected error response format\");\n    }\n  }\n\n} ////////////////////////////////////////////////////////////////////////////\n\n\nclass DefaultNetworkTransport {\n  constructor() {\n    if (!DefaultNetworkTransport.fetch) {\n      throw new Error(\"DefaultNetworkTransport.fetch must be set before it's used\");\n    }\n\n    if (!DefaultNetworkTransport.AbortController) {\n      throw new Error(\"DefaultNetworkTransport.AbortController must be set before it's used\");\n    }\n  }\n\n  async fetchAndParse(request) {\n    try {\n      const response = await this.fetch(request);\n      const contentType = response.headers.get(\"content-type\");\n\n      if (response.ok) {\n        if (contentType === null) {\n          return null;\n        } else if (contentType.startsWith(\"application/json\")) {\n          // Awaiting the response to ensure we'll throw our own error\n          return await response.json();\n        } else {\n          throw new Error(\"Expected an empty or a JSON response\");\n        }\n      } else if (contentType && contentType.startsWith(\"application/json\")) {\n        throw new MongoDBRealmError(request.method, request.url, response.status, response.statusText, await response.json());\n      } else {\n        throw new Error(`Unexpected status code (${response.status} ${response.statusText})`);\n      }\n    } catch (err) {\n      if (err instanceof MongoDBRealmError) {\n        throw err;\n      } else {\n        throw new Error(`Request failed (${request.method} ${request.url}): ${err.message}`);\n      }\n    }\n  }\n\n  fetchWithCallbacks(request, handler) {\n    // tslint:disable-next-line: no-console\n    this.fetch(request).then(async response => {\n      const decodedBody = await response.text(); // Pull out the headers of the response\n\n      const responseHeaders = {};\n      response.headers.forEach((value, key) => {\n        responseHeaders[key] = value;\n      });\n      return {\n        statusCode: response.status,\n        headers: responseHeaders,\n        body: decodedBody\n      };\n    }).then(r => handler.onSuccess(r)).catch(e => handler.onError(e));\n  }\n\n  async fetch(request) {\n    const {\n      method,\n      url,\n      body,\n      timeoutMs,\n      headers = DefaultNetworkTransport.DEFAULT_HEADERS\n    } = request;\n    const {\n      signal,\n      cancelTimeout\n    } = this.createTimeoutSignal(timeoutMs);\n\n    try {\n      // We'll await the response to catch throw our own error\n      return await DefaultNetworkTransport.fetch(url, {\n        method,\n        headers,\n        body: typeof body === \"string\" ? body : JSON.stringify(body),\n        signal\n      });\n    } finally {\n      // Whatever happens, cancel any timeout\n      cancelTimeout();\n    }\n  }\n\n  createTimeoutSignal(timeoutMs) {\n    if (typeof timeoutMs === \"number\") {\n      const controller = new DefaultNetworkTransport.AbortController(); // Call abort after a specific number of milliseconds\n\n      const timeout = setTimeout(() => {\n        controller.abort();\n      }, timeoutMs);\n      return {\n        signal: controller.signal,\n        cancelTimeout: () => {\n          clearTimeout(timeout);\n        }\n      };\n    } else {\n      return {\n        signal: undefined,\n        cancelTimeout: () => {\n          /* No-op */\n        }\n      };\n    }\n  }\n\n}\n\nDefaultNetworkTransport.DEFAULT_HEADERS = {\n  Accept: \"application/json\",\n  \"Content-Type\": \"application/json\"\n}; ////////////////////////////////////////////////////////////////////////////\n\nDefaultNetworkTransport.fetch = window.fetch.bind(window);\nDefaultNetworkTransport.AbortController = window.AbortController;\nexport { DefaultNetworkTransport, MongoDBRealmError };","map":{"version":3,"sources":["/Volumes/LaCie/Dev/myProjects/movie-nite/node_modules/realm-network-transport/dist/bundle.dom.es.js"],"names":["MongoDBRealmError","Error","constructor","method","url","statusCode","statusText","response","error","statusSummary","errorCode","error_code","link","DefaultNetworkTransport","fetch","AbortController","fetchAndParse","request","contentType","headers","get","ok","startsWith","json","status","err","message","fetchWithCallbacks","handler","then","decodedBody","text","responseHeaders","forEach","value","key","body","r","onSuccess","catch","e","onError","timeoutMs","DEFAULT_HEADERS","signal","cancelTimeout","createTimeoutSignal","JSON","stringify","controller","timeout","setTimeout","abort","clearTimeout","undefined","Accept","window","bind"],"mappings":"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","sourcesContent":["////////////////////////////////////////////////////////////////////////////\n//\n// Copyright 2020 Realm Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n////////////////////////////////////////////////////////////////////////////\n/**\n * TODO: Determine if the shape of an error response is specific to each service or widely used\n */\nclass MongoDBRealmError extends Error {\n    constructor(method, url, statusCode, statusText, response) {\n        if (typeof response === \"object\" &&\n            typeof response.error === \"string\") {\n            const statusSummary = statusText\n                ? `status ${statusCode} ${statusText}`\n                : `status ${statusCode}`;\n            super(`Request failed (${method} ${url}): ${response.error} (${statusSummary})`);\n            this.method = method;\n            this.url = url;\n            this.statusText = statusText;\n            this.statusCode = statusCode;\n            this.errorCode = response.error_code;\n            this.link = response.link;\n        }\n        else {\n            throw new Error(\"Unexpected error response format\");\n        }\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////\nclass DefaultNetworkTransport {\n    constructor() {\n        if (!DefaultNetworkTransport.fetch) {\n            throw new Error(\"DefaultNetworkTransport.fetch must be set before it's used\");\n        }\n        if (!DefaultNetworkTransport.AbortController) {\n            throw new Error(\"DefaultNetworkTransport.AbortController must be set before it's used\");\n        }\n    }\n    async fetchAndParse(request) {\n        try {\n            const response = await this.fetch(request);\n            const contentType = response.headers.get(\"content-type\");\n            if (response.ok) {\n                if (contentType === null) {\n                    return null;\n                }\n                else if (contentType.startsWith(\"application/json\")) {\n                    // Awaiting the response to ensure we'll throw our own error\n                    return await response.json();\n                }\n                else {\n                    throw new Error(\"Expected an empty or a JSON response\");\n                }\n            }\n            else if (contentType &&\n                contentType.startsWith(\"application/json\")) {\n                throw new MongoDBRealmError(request.method, request.url, response.status, response.statusText, await response.json());\n            }\n            else {\n                throw new Error(`Unexpected status code (${response.status} ${response.statusText})`);\n            }\n        }\n        catch (err) {\n            if (err instanceof MongoDBRealmError) {\n                throw err;\n            }\n            else {\n                throw new Error(`Request failed (${request.method} ${request.url}): ${err.message}`);\n            }\n        }\n    }\n    fetchWithCallbacks(request, handler) {\n        // tslint:disable-next-line: no-console\n        this.fetch(request)\n            .then(async (response) => {\n            const decodedBody = await response.text();\n            // Pull out the headers of the response\n            const responseHeaders = {};\n            response.headers.forEach((value, key) => {\n                responseHeaders[key] = value;\n            });\n            return {\n                statusCode: response.status,\n                headers: responseHeaders,\n                body: decodedBody,\n            };\n        })\n            .then(r => handler.onSuccess(r))\n            .catch(e => handler.onError(e));\n    }\n    async fetch(request) {\n        const { method, url, body, timeoutMs, headers = DefaultNetworkTransport.DEFAULT_HEADERS, } = request;\n        const { signal, cancelTimeout } = this.createTimeoutSignal(timeoutMs);\n        try {\n            // We'll await the response to catch throw our own error\n            return await DefaultNetworkTransport.fetch(url, {\n                method,\n                headers,\n                body: typeof body === \"string\" ? body : JSON.stringify(body),\n                signal,\n            });\n        }\n        finally {\n            // Whatever happens, cancel any timeout\n            cancelTimeout();\n        }\n    }\n    createTimeoutSignal(timeoutMs) {\n        if (typeof timeoutMs === \"number\") {\n            const controller = new DefaultNetworkTransport.AbortController();\n            // Call abort after a specific number of milliseconds\n            const timeout = setTimeout(() => {\n                controller.abort();\n            }, timeoutMs);\n            return {\n                signal: controller.signal,\n                cancelTimeout: () => {\n                    clearTimeout(timeout);\n                },\n            };\n        }\n        else {\n            return {\n                signal: undefined,\n                cancelTimeout: () => {\n                    /* No-op */\n                },\n            };\n        }\n    }\n}\nDefaultNetworkTransport.DEFAULT_HEADERS = {\n    Accept: \"application/json\",\n    \"Content-Type\": \"application/json\",\n};\n\n////////////////////////////////////////////////////////////////////////////\nDefaultNetworkTransport.fetch = window.fetch.bind(window);\nDefaultNetworkTransport.AbortController = window.AbortController;\n\nexport { DefaultNetworkTransport, MongoDBRealmError };\n"]},"metadata":{},"sourceType":"module"}