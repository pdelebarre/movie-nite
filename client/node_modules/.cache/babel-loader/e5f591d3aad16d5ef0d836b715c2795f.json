{"ast":null,"code":"import fetch from 'cross-fetch';\nimport deepEqual from 'fast-deep-equal';\nimport easyqb from 'EasyQB';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nvar POST_TYPES;\n\n(function (POST_TYPES) {\n  POST_TYPES[\"UPLOAD_ATTACHMENT\"] = \"upload_attachment\";\n  POST_TYPES[\"HANDSHAKE\"] = \"handshake\";\n  POST_TYPES[\"VALID_TOKEN\"] = \"valid_token\";\n  POST_TYPES[\"GET_FRAME\"] = \"get_frame\";\n  POST_TYPES[\"TABLE_SIZE\"] = \"table_size\";\n  POST_TYPES[\"COLUMN_TYPES\"] = \"column_types\";\n  POST_TYPES[\"SYNC_STACK\"] = \"sync_stack\";\n  POST_TYPES[\"SYNC_DELETE\"] = \"sync_delete\";\n  POST_TYPES[\"SYNC_INSERT\"] = \"sync_insert\";\n  POST_TYPES[\"GET_QUERY\"] = \"get_query\";\n  POST_TYPES[\"USER_ATTRIBUTES\"] = \"user_attributes\";\n  POST_TYPES[\"SET_ATTRIBUTE\"] = \"set_attribute\";\n  POST_TYPES[\"SIGN_UP\"] = \"sign_up\";\n  POST_TYPES[\"REQUEST_TOKEN\"] = \"request_token\";\n  POST_TYPES[\"EASY_QB\"] = \"easyqb\";\n  POST_TYPES[\"RESET_PASSWORD\"] = \"reset_password\";\n})(POST_TYPES || (POST_TYPES = {}));\n\nvar DB_STATUS;\n\n(function (DB_STATUS) {\n  DB_STATUS[\"ERROR\"] = \"error\";\n  DB_STATUS[\"PENDING\"] = \"pending\";\n  DB_STATUS[\"SUCCESS\"] = \"success\";\n})(DB_STATUS || (DB_STATUS = {}));\n\nvar EXECUTE_COUNT;\n\n(function (EXECUTE_COUNT) {\n  EXECUTE_COUNT[\"ALL\"] = \"all\";\n  EXECUTE_COUNT[\"ONE\"] = \"one\";\n})(EXECUTE_COUNT || (EXECUTE_COUNT = {}));\n\nvar GlobalNamespace;\n\n(function (GlobalNamespace) {})(GlobalNamespace || (GlobalNamespace = {}));\n\nconst _g = _extends({}, GlobalNamespace);\n\nfunction gFactory() {\n  return _extends({}, GlobalNamespace);\n}\n\nconst INSERT = 'insert',\n      UPDATE = 'update',\n      DELETE = 'delete',\n      REVERSE = 'reverse',\n      SHUFFLE = 'shuffle',\n      oMetaKey = Symbol('observable-meta-key'),\n      validObservableOptionKeys = {\n  async: 1\n},\n      validObserverOptionKeys = {\n  path: 1,\n  pathsOf: 1,\n  pathsFrom: 1\n},\n      processObserveOptions = function processObserveOptions(options) {\n  const result = {};\n\n  if (options.path !== undefined) {\n    if (typeof options.path !== 'string' || options.path === '') {\n      throw new Error('\"path\" option, if/when provided, MUST be a non-empty string');\n    }\n\n    result.path = options.path;\n  }\n\n  if (options.pathsOf !== undefined) {\n    if (options.path) {\n      throw new Error('\"pathsOf\" option MAY NOT be specified together with \"path\" option');\n    }\n\n    if (typeof options.pathsOf !== 'string') {\n      throw new Error('\"pathsOf\" option, if/when provided, MUST be a string (MAY be empty)');\n    }\n\n    result.pathsOf = options.pathsOf.split('.').filter(n => n);\n  }\n\n  if (options.pathsFrom !== undefined) {\n    if (options.path || options.pathsOf) {\n      throw new Error('\"pathsFrom\" option MAY NOT be specified together with \"path\"/\"pathsOf\"  option/s');\n    }\n\n    if (typeof options.pathsFrom !== 'string' || options.pathsFrom === '') {\n      throw new Error('\"pathsFrom\" option, if/when provided, MUST be a non-empty string');\n    }\n\n    result.pathsFrom = options.pathsFrom;\n  }\n\n  const invalidOptions = Object.keys(options).filter(option => !validObserverOptionKeys.hasOwnProperty(option));\n\n  if (invalidOptions.length) {\n    throw new Error(`'${invalidOptions.join(', ')}' is/are not a valid observer option/s`);\n  }\n\n  return result;\n},\n      observe = function observe(observer, options) {\n  if (typeof observer !== 'function') {\n    throw new Error(`observer MUST be a function, got '${observer}'`);\n  }\n\n  const oMeta = this[oMetaKey],\n        observers = oMeta.observers;\n\n  if (!observers.some(o => o[0] === observer)) {\n    let opts;\n\n    if (options) {\n      opts = processObserveOptions(options);\n    } else {\n      opts = {};\n    }\n\n    observers.push([observer, opts]);\n  } else {\n    console.warn('observer may be bound to an observable only once; will NOT rebind');\n  }\n},\n      unobserve = function unobserve() {\n  const oMeta = this[oMetaKey];\n  const observers = oMeta.observers;\n  let ol = observers.length;\n\n  if (ol) {\n    let al = arguments.length;\n\n    if (al) {\n      while (al--) {\n        let i = ol;\n\n        while (i--) {\n          if (observers[i][0] === arguments[al]) {\n            observers.splice(i, 1);\n            ol--;\n          }\n        }\n      }\n    } else {\n      observers.splice(0);\n    }\n  }\n},\n      propertiesBluePrint = {\n  [oMetaKey]: {\n    value: null\n  },\n  observe: {\n    value: observe\n  },\n  unobserve: {\n    value: unobserve\n  }\n},\n      prepareObject = function prepareObject(source, oMeta) {\n  propertiesBluePrint[oMetaKey].value = oMeta;\n  const target = Object.defineProperties({}, propertiesBluePrint);\n\n  for (const key of Object.keys(source)) {\n    target[key] = getObservedOf(source[key], key, oMeta);\n  }\n\n  return target;\n},\n      prepareArray = function prepareArray(source, oMeta) {\n  let i = 0,\n      l = source.length;\n  propertiesBluePrint[oMetaKey].value = oMeta;\n  const target = Object.defineProperties(new Array(l), propertiesBluePrint);\n\n  for (; i < l; i++) {\n    target[i] = getObservedOf(source[i], i, oMeta);\n  }\n\n  return target;\n},\n      prepareTypedArray = function prepareTypedArray(source, oMeta) {\n  propertiesBluePrint[oMetaKey].value = oMeta;\n  Object.defineProperties(source, propertiesBluePrint);\n  return source;\n},\n      filterChanges = function filterChanges(options, changes) {\n  let result = changes;\n\n  if (options.path) {\n    const oPath = options.path;\n    result = changes.filter(change => change.path.join('.') === oPath);\n  } else if (options.pathsOf) {\n    const oPathsOf = options.pathsOf;\n    result = changes.filter(change => change.path.length === oPathsOf.length + 1 || change.path.length === oPathsOf.length && (change.type === REVERSE || change.type === SHUFFLE));\n  } else if (options.pathsFrom) {\n    const oPathsFrom = options.pathsFrom;\n    result = changes.filter(change => change.path.join('.').startsWith(oPathsFrom));\n  }\n\n  return result;\n},\n      callObserverSafe = function callObserverSafe(listener, changes) {\n  try {\n    listener(changes);\n  } catch (e) {\n    console.error(`failed to notify listener ${listener} with ${changes}`, e);\n  }\n},\n      callObserversFromMT = function callObserversFromMT() {\n  const batches = this.batches;\n  this.batches = null;\n\n  for (const [listener, options] of batches) {\n    callObserverSafe(listener, options);\n  }\n},\n      callObservers = function callObservers(oMeta, changes) {\n  let currentObservable = oMeta;\n  let observers, target, options, relevantChanges, i, newPath, tmp;\n  const l = changes.length;\n\n  do {\n    observers = currentObservable.observers;\n    i = observers.length;\n\n    while (i--) {\n      [target, options] = observers[i];\n      relevantChanges = filterChanges(options, changes);\n\n      if (relevantChanges.length) {\n        if (currentObservable.options.async) {\n          //\tthis is the async dispatch handling\n          if (!currentObservable.batches) {\n            currentObservable.batches = [];\n            queueMicrotask(callObserversFromMT.bind(currentObservable));\n          }\n\n          let rb = currentObservable.batches.find(b => b[0] === target);\n\n          if (!rb) {\n            rb = [target, []];\n            currentObservable.batches.push(rb);\n          }\n\n          Array.prototype.push.apply(rb[1], relevantChanges);\n        } else {\n          //\tthis is the naive straight forward synchronous dispatch\n          callObserverSafe(target, relevantChanges);\n        }\n      }\n    }\n\n    let tmpa;\n\n    if (currentObservable.parent) {\n      tmpa = new Array(l);\n\n      for (let _i = 0; _i < l; _i++) {\n        tmp = changes[_i];\n        newPath = [currentObservable.ownKey, ...tmp.path];\n        tmpa[_i] = {\n          type: tmp.type,\n          path: newPath,\n          value: tmp.value,\n          oldValue: tmp.oldValue,\n          object: tmp.object\n        };\n      }\n\n      changes = tmpa;\n      currentObservable = currentObservable.parent;\n    } else {\n      currentObservable = null;\n    }\n  } while (currentObservable);\n},\n      getObservedOf = function getObservedOf(item, key, parent) {\n  if (!item || typeof item !== 'object') {\n    return item;\n  } else if (Array.isArray(item)) {\n    return new ArrayOMeta({\n      target: item,\n      ownKey: key,\n      parent: parent\n    }).proxy;\n  } else if (ArrayBuffer.isView(item)) {\n    return new TypedArrayOMeta({\n      target: item,\n      ownKey: key,\n      parent: parent\n    }).proxy;\n  } else if (item instanceof Date || item instanceof Error) {\n    return item;\n  } else {\n    return new ObjectOMeta({\n      target: item,\n      ownKey: key,\n      parent: parent\n    }).proxy;\n  }\n},\n      proxiedPop = function proxiedPop() {\n  const oMeta = this[oMetaKey],\n        target = oMeta.target,\n        poppedIndex = target.length - 1;\n  let popResult = target.pop();\n\n  if (popResult && typeof popResult === 'object') {\n    const tmpObserved = popResult[oMetaKey];\n\n    if (tmpObserved) {\n      popResult = tmpObserved.detach();\n    }\n  }\n\n  const changes = [{\n    type: DELETE,\n    path: [poppedIndex],\n    oldValue: popResult,\n    object: this\n  }];\n  callObservers(oMeta, changes);\n  return popResult;\n},\n      proxiedPush = function proxiedPush() {\n  const oMeta = this[oMetaKey],\n        target = oMeta.target,\n        l = arguments.length,\n        pushContent = new Array(l),\n        initialLength = target.length;\n\n  for (let i = 0; i < l; i++) {\n    pushContent[i] = getObservedOf(arguments[i], initialLength + i, oMeta);\n  }\n\n  const pushResult = Reflect.apply(target.push, target, pushContent);\n  const changes = [];\n\n  for (let i = initialLength, _l = target.length; i < _l; i++) {\n    changes[i - initialLength] = {\n      type: INSERT,\n      path: [i],\n      value: target[i],\n      object: this\n    };\n  }\n\n  callObservers(oMeta, changes);\n  return pushResult;\n},\n      proxiedShift = function proxiedShift() {\n  const oMeta = this[oMetaKey],\n        target = oMeta.target;\n  let shiftResult, i, l, item, tmpObserved;\n  shiftResult = target.shift();\n\n  if (shiftResult && typeof shiftResult === 'object') {\n    tmpObserved = shiftResult[oMetaKey];\n\n    if (tmpObserved) {\n      shiftResult = tmpObserved.detach();\n    }\n  } //\tupdate indices of the remaining items\n\n\n  for (i = 0, l = target.length; i < l; i++) {\n    item = target[i];\n\n    if (item && typeof item === 'object') {\n      tmpObserved = item[oMetaKey];\n\n      if (tmpObserved) {\n        tmpObserved.ownKey = i;\n      }\n    }\n  }\n\n  const changes = [{\n    type: DELETE,\n    path: [0],\n    oldValue: shiftResult,\n    object: this\n  }];\n  callObservers(oMeta, changes);\n  return shiftResult;\n},\n      proxiedUnshift = function proxiedUnshift() {\n  const oMeta = this[oMetaKey],\n        target = oMeta.target,\n        al = arguments.length,\n        unshiftContent = new Array(al);\n\n  for (let i = 0; i < al; i++) {\n    unshiftContent[i] = getObservedOf(arguments[i], i, oMeta);\n  }\n\n  const unshiftResult = Reflect.apply(target.unshift, target, unshiftContent);\n\n  for (let i = 0, _l2 = target.length, item; i < _l2; i++) {\n    item = target[i];\n\n    if (item && typeof item === 'object') {\n      const tmpObserved = item[oMetaKey];\n\n      if (tmpObserved) {\n        tmpObserved.ownKey = i;\n      }\n    }\n  } //\tpublish changes\n\n\n  const l = unshiftContent.length;\n  const changes = new Array(l);\n\n  for (let i = 0; i < l; i++) {\n    changes[i] = {\n      type: INSERT,\n      path: [i],\n      value: target[i],\n      object: this\n    };\n  }\n\n  callObservers(oMeta, changes);\n  return unshiftResult;\n},\n      proxiedReverse = function proxiedReverse() {\n  const oMeta = this[oMetaKey],\n        target = oMeta.target;\n  let i, l, item;\n  target.reverse();\n\n  for (i = 0, l = target.length; i < l; i++) {\n    item = target[i];\n\n    if (item && typeof item === 'object') {\n      const tmpObserved = item[oMetaKey];\n\n      if (tmpObserved) {\n        tmpObserved.ownKey = i;\n      }\n    }\n  }\n\n  const changes = [{\n    type: REVERSE,\n    path: [],\n    object: this\n  }];\n  callObservers(oMeta, changes);\n  return this;\n},\n      proxiedSort = function proxiedSort(comparator) {\n  const oMeta = this[oMetaKey],\n        target = oMeta.target;\n  let i, l, item;\n  target.sort(comparator);\n\n  for (i = 0, l = target.length; i < l; i++) {\n    item = target[i];\n\n    if (item && typeof item === 'object') {\n      const tmpObserved = item[oMetaKey];\n\n      if (tmpObserved) {\n        tmpObserved.ownKey = i;\n      }\n    }\n  }\n\n  const changes = [{\n    type: SHUFFLE,\n    path: [],\n    object: this\n  }];\n  callObservers(oMeta, changes);\n  return this;\n},\n      proxiedFill = function proxiedFill(filVal, start, end) {\n  const oMeta = this[oMetaKey],\n        target = oMeta.target,\n        changes = [],\n        tarLen = target.length,\n        prev = target.slice(0);\n  start = start === undefined ? 0 : start < 0 ? Math.max(tarLen + start, 0) : Math.min(start, tarLen);\n  end = end === undefined ? tarLen : end < 0 ? Math.max(tarLen + end, 0) : Math.min(end, tarLen);\n\n  if (start < tarLen && end > start) {\n    target.fill(filVal, start, end);\n    let tmpObserved;\n\n    for (let i = start, item, tmpTarget; i < end; i++) {\n      item = target[i];\n      target[i] = getObservedOf(item, i, oMeta);\n\n      if (prev.hasOwnProperty(i)) {\n        tmpTarget = prev[i];\n\n        if (tmpTarget && typeof tmpTarget === 'object') {\n          tmpObserved = tmpTarget[oMetaKey];\n\n          if (tmpObserved) {\n            tmpTarget = tmpObserved.detach();\n          }\n        }\n\n        changes.push({\n          type: UPDATE,\n          path: [i],\n          value: target[i],\n          oldValue: tmpTarget,\n          object: this\n        });\n      } else {\n        changes.push({\n          type: INSERT,\n          path: [i],\n          value: target[i],\n          object: this\n        });\n      }\n    }\n\n    callObservers(oMeta, changes);\n  }\n\n  return this;\n},\n      proxiedCopyWithin = function proxiedCopyWithin(dest, start, end) {\n  const oMeta = this[oMetaKey],\n        target = oMeta.target,\n        tarLen = target.length;\n  dest = dest < 0 ? Math.max(tarLen + dest, 0) : dest;\n  start = start === undefined ? 0 : start < 0 ? Math.max(tarLen + start, 0) : Math.min(start, tarLen);\n  end = end === undefined ? tarLen : end < 0 ? Math.max(tarLen + end, 0) : Math.min(end, tarLen);\n  const len = Math.min(end - start, tarLen - dest);\n\n  if (dest < tarLen && dest !== start && len > 0) {\n    const prev = target.slice(0),\n          changes = [];\n    target.copyWithin(dest, start, end);\n\n    for (let i = dest, nItem, oItem, tmpObserved; i < dest + len; i++) {\n      //\tupdate newly placed observables, if any\n      nItem = target[i];\n\n      if (nItem && typeof nItem === 'object') {\n        nItem = getObservedOf(nItem, i, oMeta);\n        target[i] = nItem;\n      } //\tdetach overridden observables, if any\n\n\n      oItem = prev[i];\n\n      if (oItem && typeof oItem === 'object') {\n        tmpObserved = oItem[oMetaKey];\n\n        if (tmpObserved) {\n          oItem = tmpObserved.detach();\n        }\n      }\n\n      if (typeof nItem !== 'object' && nItem === oItem) {\n        continue;\n      }\n\n      changes.push({\n        type: UPDATE,\n        path: [i],\n        value: nItem,\n        oldValue: oItem,\n        object: this\n      });\n    }\n\n    callObservers(oMeta, changes);\n  }\n\n  return this;\n},\n      proxiedSplice = function proxiedSplice() {\n  const oMeta = this[oMetaKey],\n        target = oMeta.target,\n        splLen = arguments.length,\n        spliceContent = new Array(splLen),\n        tarLen = target.length; //\tobservify the newcomers\n\n  for (let _i2 = 0; _i2 < splLen; _i2++) {\n    spliceContent[_i2] = getObservedOf(arguments[_i2], _i2, oMeta);\n  } //\tcalculate pointers\n\n\n  const startIndex = splLen === 0 ? 0 : spliceContent[0] < 0 ? tarLen + spliceContent[0] : spliceContent[0],\n        removed = splLen < 2 ? tarLen - startIndex : spliceContent[1],\n        inserted = Math.max(splLen - 2, 0),\n        spliceResult = Reflect.apply(target.splice, target, spliceContent),\n        newTarLen = target.length; //\treindex the paths\n\n  let tmpObserved;\n\n  for (let _i3 = 0, _item; _i3 < newTarLen; _i3++) {\n    _item = target[_i3];\n\n    if (_item && typeof _item === 'object') {\n      tmpObserved = _item[oMetaKey];\n\n      if (tmpObserved) {\n        tmpObserved.ownKey = _i3;\n      }\n    }\n  } //\tdetach removed objects\n\n\n  let i, l, item;\n\n  for (i = 0, l = spliceResult.length; i < l; i++) {\n    item = spliceResult[i];\n\n    if (item && typeof item === 'object') {\n      tmpObserved = item[oMetaKey];\n\n      if (tmpObserved) {\n        spliceResult[i] = tmpObserved.detach();\n      }\n    }\n  }\n\n  const changes = [];\n  let index;\n\n  for (index = 0; index < removed; index++) {\n    if (index < inserted) {\n      changes.push({\n        type: UPDATE,\n        path: [startIndex + index],\n        value: target[startIndex + index],\n        oldValue: spliceResult[index],\n        object: this\n      });\n    } else {\n      changes.push({\n        type: DELETE,\n        path: [startIndex + index],\n        oldValue: spliceResult[index],\n        object: this\n      });\n    }\n  }\n\n  for (; index < inserted; index++) {\n    changes.push({\n      type: INSERT,\n      path: [startIndex + index],\n      value: target[startIndex + index],\n      object: this\n    });\n  }\n\n  callObservers(oMeta, changes);\n  return spliceResult;\n},\n      proxiedTypedArraySet = function proxiedTypedArraySet(source, offset) {\n  const oMeta = this[oMetaKey],\n        target = oMeta.target,\n        souLen = source.length,\n        prev = target.slice(0);\n  offset = offset || 0;\n  target.set(source, offset);\n  const changes = new Array(souLen);\n\n  for (let i = offset; i < souLen + offset; i++) {\n    changes[i - offset] = {\n      type: UPDATE,\n      path: [i],\n      value: target[i],\n      oldValue: prev[i],\n      object: this\n    };\n  }\n\n  callObservers(oMeta, changes);\n},\n      proxiedArrayMethods = {\n  pop: proxiedPop,\n  push: proxiedPush,\n  shift: proxiedShift,\n  unshift: proxiedUnshift,\n  reverse: proxiedReverse,\n  sort: proxiedSort,\n  fill: proxiedFill,\n  copyWithin: proxiedCopyWithin,\n  splice: proxiedSplice\n},\n      proxiedTypedArrayMethods = {\n  reverse: proxiedReverse,\n  sort: proxiedSort,\n  fill: proxiedFill,\n  copyWithin: proxiedCopyWithin,\n  set: proxiedTypedArraySet\n};\n\nclass OMetaBase {\n  constructor(properties, cloningFunction) {\n    const {\n      target,\n      parent,\n      ownKey\n    } = properties;\n\n    if (parent && ownKey !== undefined) {\n      this.parent = parent;\n      this.ownKey = ownKey;\n    } else {\n      this.parent = null;\n      this.ownKey = null;\n    }\n\n    const targetClone = cloningFunction(target, this);\n    this.observers = [];\n    this.revocable = Proxy.revocable(targetClone, this);\n    this.proxy = this.revocable.proxy;\n    this.target = targetClone;\n    this.options = this.processOptions(properties.options);\n  }\n\n  processOptions(options) {\n    if (options) {\n      if (typeof options !== 'object') {\n        throw new Error(`Observable options if/when provided, MAY only be an object, got '${options}'`);\n      }\n\n      const invalidOptions = Object.keys(options).filter(option => !validObservableOptionKeys.hasOwnProperty(option));\n\n      if (invalidOptions.length) {\n        throw new Error(`'${invalidOptions.join(', ')}' is/are not a valid Observable option/s`);\n      }\n\n      return Object.assign({}, options);\n    } else {\n      return {};\n    }\n  }\n\n  detach() {\n    this.parent = null;\n    return this.target;\n  }\n\n  set(target, key, value) {\n    let oldValue = target[key];\n\n    if (value !== oldValue) {\n      const newValue = getObservedOf(value, key, this);\n      target[key] = newValue;\n\n      if (oldValue && typeof oldValue === 'object') {\n        const tmpObserved = oldValue[oMetaKey];\n\n        if (tmpObserved) {\n          oldValue = tmpObserved.detach();\n        }\n      }\n\n      const changes = oldValue === undefined ? [{\n        type: INSERT,\n        path: [key],\n        value: newValue,\n        object: this.proxy\n      }] : [{\n        type: UPDATE,\n        path: [key],\n        value: newValue,\n        oldValue: oldValue,\n        object: this.proxy\n      }];\n      callObservers(this, changes);\n    }\n\n    return true;\n  }\n\n  deleteProperty(target, key) {\n    let oldValue = target[key];\n    delete target[key];\n\n    if (oldValue && typeof oldValue === 'object') {\n      const tmpObserved = oldValue[oMetaKey];\n\n      if (tmpObserved) {\n        oldValue = tmpObserved.detach();\n      }\n    }\n\n    const changes = [{\n      type: DELETE,\n      path: [key],\n      oldValue: oldValue,\n      object: this.proxy\n    }];\n    callObservers(this, changes);\n    return true;\n  }\n\n}\n\nclass ObjectOMeta extends OMetaBase {\n  constructor(properties) {\n    super(properties, prepareObject);\n  }\n\n}\n\nclass ArrayOMeta extends OMetaBase {\n  constructor(properties) {\n    super(properties, prepareArray);\n  }\n\n  get(target, key) {\n    if (proxiedArrayMethods.hasOwnProperty(key)) {\n      return proxiedArrayMethods[key];\n    } else {\n      return target[key];\n    }\n  }\n\n}\n\nclass TypedArrayOMeta extends OMetaBase {\n  constructor(properties) {\n    super(properties, prepareTypedArray);\n  }\n\n  get(target, key) {\n    if (proxiedTypedArrayMethods.hasOwnProperty(key)) {\n      return proxiedTypedArrayMethods[key];\n    } else {\n      return target[key];\n    }\n  }\n\n}\n\nclass Observable {\n  constructor() {\n    throw new Error('Observable MAY NOT be created via constructor, see \"Observable.from\" API');\n  }\n\n  static from(target, options) {\n    if (!target || typeof target !== 'object') {\n      throw new Error('observable MAY ONLY be created from a non-null object');\n    } else if (target[oMetaKey]) {\n      return target;\n    } else if (Array.isArray(target)) {\n      return new ArrayOMeta({\n        target: target,\n        ownKey: null,\n        parent: null,\n        options: options\n      }).proxy;\n    } else if (ArrayBuffer.isView(target)) {\n      return new TypedArrayOMeta({\n        target: target,\n        ownKey: null,\n        parent: null,\n        options: options\n      }).proxy;\n    } else if (target instanceof Date || target instanceof Error) {\n      throw new Error(`${target} found to be one of a on-observable types`);\n    } else {\n      return new ObjectOMeta({\n        target: target,\n        ownKey: null,\n        parent: null,\n        options: options\n      }).proxy;\n    }\n  }\n\n  static isObservable(input) {\n    return !!(input && input[oMetaKey]);\n  }\n\n}\n\nObject.freeze(Observable);\nvar imageExtensions = [\"ase\", \"art\", \"bmp\", \"blp\", \"cd5\", \"cit\", \"cpt\", \"cr2\", \"cut\", \"dds\", \"dib\", \"djvu\", \"egt\", \"exif\", \"gif\", \"gpl\", \"grf\", \"icns\", \"ico\", \"iff\", \"jng\", \"jpeg\", \"jpg\", \"jfif\", \"jp2\", \"jps\", \"lbm\", \"max\", \"miff\", \"mng\", \"msp\", \"nitf\", \"ota\", \"pbm\", \"pc1\", \"pc2\", \"pc3\", \"pcf\", \"pcx\", \"pdn\", \"pgm\", \"PI1\", \"PI2\", \"PI3\", \"pict\", \"pct\", \"pnm\", \"pns\", \"ppm\", \"psb\", \"psd\", \"pdd\", \"psp\", \"px\", \"pxm\", \"pxr\", \"qfx\", \"raw\", \"rle\", \"sct\", \"sgi\", \"rgb\", \"int\", \"bw\", \"tga\", \"tiff\", \"tif\", \"vtf\", \"xbm\", \"xcf\", \"xpm\", \"3dv\", \"amf\", \"ai\", \"awg\", \"cgm\", \"cdr\", \"cmx\", \"dxf\", \"e2d\", \"egt\", \"eps\", \"fs\", \"gbr\", \"odg\", \"svg\", \"stl\", \"vrml\", \"x3d\", \"sxd\", \"v2d\", \"vnd\", \"wmf\", \"emf\", \"art\", \"xar\", \"png\", \"webp\", \"jxr\", \"hdp\", \"wdp\", \"cur\", \"ecw\", \"iff\", \"lbm\", \"liff\", \"nrrd\", \"pam\", \"pcx\", \"pgf\", \"sgi\", \"rgb\", \"rgba\", \"bw\", \"int\", \"inta\", \"sid\", \"ras\", \"sun\", \"tga\"];\nvar videoExtensions = [\"3g2\", \"3gp\", \"aaf\", \"asf\", \"avchd\", \"avi\", \"drc\", \"flv\", \"m2v\", \"m4p\", \"m4v\", \"mkv\", \"mng\", \"mov\", \"mp2\", \"mp4\", \"mpe\", \"mpeg\", \"mpg\", \"mpv\", \"mxf\", \"nsv\", \"ogg\", \"ogv\", \"qt\", \"rm\", \"rmvb\", \"roq\", \"svi\", \"vob\", \"webm\", \"wmv\", \"yuv\"];\n\nfunction utilsFactory(globals) {\n  const g = globals || _g;\n\n  const generateBareUrl = (type, integrationID) => `https://api.easybase.io/${type}/${integrationID}`;\n\n  const generateAuthBody = () => {\n    const stamp = Date.now();\n    return {\n      token: g.token,\n      token_time: ~~(g.session / (stamp % 64)),\n      now: stamp\n    };\n  };\n\n  function log(...params) {\n    if (g.options.logging) {\n      console.log(\"EASYBASE — \", ...params);\n    }\n  }\n\n  return {\n    generateAuthBody,\n    generateBareUrl,\n    log\n  };\n}\n\nfunction authFactory(globals) {\n  const g = globals || _g;\n  const {\n    generateBareUrl,\n    generateAuthBody,\n    log\n  } = utilsFactory(g);\n\n  const getUserAttributes = async () => {\n    try {\n      const attrsRes = await tokenPost(POST_TYPES.USER_ATTRIBUTES);\n      return attrsRes.data;\n    } catch (error) {\n      return error;\n    }\n  };\n\n  const setUserAttribute = async (key, value) => {\n    try {\n      const setAttrsRes = await tokenPost(POST_TYPES.SET_ATTRIBUTE, {\n        key,\n        value\n      });\n      return {\n        success: setAttrsRes.success,\n        message: JSON.stringify(setAttrsRes.data)\n      };\n    } catch (error) {\n      return {\n        success: false,\n        message: \"Error\",\n        error\n      };\n    }\n  };\n\n  const signUp = async (newUserID, password, userAttributes) => {\n    try {\n      const signUpRes = await tokenPost(POST_TYPES.SIGN_UP, {\n        newUserID,\n        password,\n        userAttributes\n      });\n      return {\n        success: signUpRes.success,\n        message: signUpRes.data\n      };\n    } catch (error) {\n      return {\n        success: false,\n        message: \"Error\",\n        error\n      };\n    }\n  };\n\n  const signIn = async (userID, password) => {\n    const t1 = Date.now();\n    g.session = Math.floor(100000000 + Math.random() * 900000000);\n    const integrationType = g.ebconfig.integration.split(\"-\")[0].toUpperCase() === \"PROJECT\" ? \"PROJECT\" : \"REACT\";\n\n    try {\n      const res = await fetch(generateBareUrl(integrationType, g.integrationID), {\n        method: \"POST\",\n        headers: {\n          'Eb-Post-Req': POST_TYPES.HANDSHAKE,\n          'Accept': 'application/json',\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          version: g.ebconfig.version,\n          session: g.session,\n          instance: g.instance,\n          userID,\n          password\n        })\n      });\n      const resData = await res.json();\n\n      if (resData.token) {\n        g.token = resData.token;\n        g.refreshToken = resData.refreshToken;\n        g.newTokenCallback();\n        g.mounted = true;\n        const validTokenRes = await tokenPost(POST_TYPES.VALID_TOKEN);\n        const elapsed = Date.now() - t1;\n\n        if (validTokenRes.success) {\n          log(\"Valid auth initiation in \" + elapsed + \"ms\");\n          return {\n            success: true,\n            message: \"Successfully signed in user\"\n          };\n        } else {\n          return {\n            success: false,\n            message: \"Could not sign in user\"\n          };\n        }\n      } else {\n        return {\n          success: false,\n          message: \"Could not sign in user\"\n        };\n      }\n    } catch (error) {\n      console.error(error);\n      return {\n        success: false,\n        message: error,\n        error\n      };\n    }\n  };\n\n  const resetUserPassword = async newPassword => {\n    if (typeof newPassword !== \"string\" || newPassword.length < 100) {\n      return {\n        success: false,\n        message: \"newPassword must be of type string\"\n      };\n    }\n\n    try {\n      const setAttrsRes = await tokenPost(POST_TYPES.RESET_PASSWORD, {\n        newPassword\n      });\n      return {\n        success: setAttrsRes.success,\n        message: JSON.stringify(setAttrsRes.data)\n      };\n    } catch (error) {\n      return {\n        success: false,\n        message: \"Error\",\n        error\n      };\n    }\n  };\n\n  const isUserSignedIn = () => g.token.length > 0;\n\n  const signOut = () => {\n    g.token = \"\";\n    g.newTokenCallback();\n  };\n\n  const initAuth = async () => {\n    const t1 = Date.now();\n    g.session = Math.floor(100000000 + Math.random() * 900000000);\n    log(`Handshaking on${g.instance} instance`);\n    const integrationType = g.ebconfig.integration.split(\"-\")[0].toUpperCase() === \"PROJECT\" ? \"PROJECT\" : \"REACT\";\n\n    try {\n      const res = await fetch(generateBareUrl(integrationType, g.integrationID), {\n        method: \"POST\",\n        headers: {\n          'Eb-Post-Req': POST_TYPES.HANDSHAKE,\n          'Accept': 'application/json',\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          version: g.ebconfig.version,\n          tt: g.ebconfig.tt,\n          session: g.session,\n          instance: g.instance\n        })\n      });\n      const resData = await res.json();\n\n      if (resData.token) {\n        g.token = resData.token;\n        g.mounted = true;\n        const validTokenRes = await tokenPost(POST_TYPES.VALID_TOKEN);\n        const elapsed = Date.now() - t1;\n\n        if (validTokenRes.success) {\n          log(\"Valid auth initiation in \" + elapsed + \"ms\");\n          return true;\n        } else {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    } catch (error) {\n      console.error(error);\n      return false;\n    }\n  };\n\n  const tokenPost = async (postType, body) => {\n    if (!g.mounted) {\n      await initAuth();\n    }\n\n    const integrationType = g.ebconfig.integration.split(\"-\")[0].toUpperCase() === \"PROJECT\" ? \"PROJECT\" : \"REACT\";\n\n    try {\n      const res = await fetch(generateBareUrl(integrationType, g.integrationID), {\n        method: \"POST\",\n        headers: {\n          'Eb-Post-Req': postType,\n          'Accept': 'application/json',\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(_extends({\n          _auth: generateAuthBody()\n        }, body))\n      });\n      const resData = await res.json();\n\n      if ({}.hasOwnProperty.call(resData, 'ErrorCode') || {}.hasOwnProperty.call(resData, 'code')) {\n        if (resData.code === \"JWT EXPIRED\") {\n          if (integrationType === \"PROJECT\") {\n            const req_res = await tokenPost(POST_TYPES.REQUEST_TOKEN, {\n              refreshToken: g.refreshToken,\n              token: g.token\n            });\n\n            if (req_res.success) {\n              g.token = req_res.data.token;\n              g.newTokenCallback();\n              return tokenPost(postType, body);\n            } else {\n              g.token = \"\";\n              g.refreshToken = \"\";\n              g.newTokenCallback();\n              return {\n                success: false,\n                data: req_res.data\n              };\n            }\n          } else {\n            await initAuth();\n          }\n\n          return tokenPost(postType, body);\n        }\n\n        return {\n          success: false,\n          data: resData.body\n        };\n      } else {\n        return {\n          success: resData.success,\n          data: resData.body\n        };\n      }\n    } catch (error) {\n      return {\n        success: false,\n        data: error\n      };\n    }\n  };\n\n  const tokenPostAttachment = async (formData, customHeaders) => {\n    if (!g.mounted) {\n      await initAuth();\n    }\n\n    const regularAuthbody = generateAuthBody();\n    const attachmentAuth = {\n      'Eb-token': regularAuthbody.token,\n      'Eb-token-time': regularAuthbody.token_time,\n      'Eb-now': regularAuthbody.now\n    };\n    const integrationType = g.ebconfig.integration.split(\"-\")[0].toUpperCase() === \"PROJECT\" ? \"PROJECT\" : \"REACT\";\n\n    try {\n      const res = await fetch(generateBareUrl(integrationType, g.integrationID), {\n        method: \"POST\",\n        headers: _extends({\n          'Eb-Post-Req': POST_TYPES.UPLOAD_ATTACHMENT\n        }, customHeaders, attachmentAuth),\n        body: formData\n      });\n      const resData = await res.json();\n\n      if ({}.hasOwnProperty.call(resData, 'ErrorCode') || {}.hasOwnProperty.call(resData, 'code')) {\n        if (resData.code === \"JWT EXPIRED\") {\n          if (integrationType === \"PROJECT\") {\n            const req_res = await tokenPost(POST_TYPES.REQUEST_TOKEN, {\n              refreshToken: g.refreshToken,\n              token: g.token\n            });\n\n            if (req_res.success) {\n              g.token = req_res.data.token;\n              g.newTokenCallback();\n              return tokenPostAttachment(formData, customHeaders);\n            } else {\n              g.token = \"\";\n              g.refreshToken = \"\";\n              g.newTokenCallback();\n              return {\n                success: false,\n                data: req_res.data\n              };\n            }\n          } else {\n            await initAuth();\n          }\n\n          return tokenPostAttachment(formData, customHeaders);\n        }\n\n        return {\n          success: false,\n          data: resData.body\n        };\n      } else {\n        return {\n          success: resData.success,\n          data: resData.body\n        };\n      }\n    } catch (error) {\n      return {\n        success: false,\n        data: error\n      };\n    }\n  };\n\n  return {\n    initAuth,\n    tokenPost,\n    tokenPostAttachment,\n    signUp,\n    setUserAttribute,\n    getUserAttributes,\n    isUserSignedIn,\n    signIn,\n    signOut,\n    resetUserPassword\n  };\n}\n\nfunction tableFactory(globals) {\n  const g = globals || _g;\n  const {\n    tokenPost\n  } = authFactory(g);\n\n  const Query = async options => {\n    const defaultOptions = {\n      queryName: \"\"\n    };\n\n    const fullOptions = _extends({}, defaultOptions, options);\n\n    try {\n      const res = await tokenPost(POST_TYPES.GET_QUERY, fullOptions);\n      return res.data;\n    } catch (error) {\n      return [];\n    }\n  };\n\n  async function fullTableSize(tableName) {\n    const res = await tokenPost(POST_TYPES.TABLE_SIZE, tableName ? {\n      tableName\n    } : {});\n\n    if (res.success) {\n      return res.data;\n    } else {\n      return 0;\n    }\n  }\n\n  async function tableTypes(tableName) {\n    const res = await tokenPost(POST_TYPES.COLUMN_TYPES, tableName ? {\n      tableName\n    } : {});\n\n    if (res.success) {\n      return res.data;\n    } else {\n      return {};\n    }\n  }\n\n  return {\n    Query,\n    fullTableSize,\n    tableTypes\n  };\n}\n\nfunction dbFactory(globals) {\n  const g = globals || _g;\n  const {\n    tokenPost\n  } = authFactory(g);\n  let _listenerIndex = 0;\n  const _listeners = {};\n\n  function _runListeners(...params) {\n    for (const cb of Object.values(_listeners)) {\n      cb(...params);\n    }\n  }\n\n  const dbEventListener = callback => {\n    const currKey = '' + _listenerIndex++;\n    _listeners[currKey] = callback;\n    return () => {\n      delete _listeners[currKey];\n    };\n  };\n\n  const allCallback = async (trx, tableName, userAssociatedRecordsOnly) => {\n    trx.count = \"all\";\n    trx.tableName = tableName;\n    if (userAssociatedRecordsOnly) trx.userAssociatedRecordsOnly = userAssociatedRecordsOnly;\n\n    _runListeners(DB_STATUS.PENDING, trx.type, EXECUTE_COUNT.ALL, tableName !== \"untable\" ? tableName : null);\n\n    const res = await tokenPost(POST_TYPES.EASY_QB, trx);\n\n    if (res.success) {\n      _runListeners(DB_STATUS.SUCCESS, trx.type, EXECUTE_COUNT.ALL, tableName !== \"untable\" ? tableName : null, res.data);\n\n      return res.data;\n    } else {\n      _runListeners(DB_STATUS.ERROR, trx.type, EXECUTE_COUNT.ALL, tableName !== \"untable\" ? tableName : null);\n\n      return res;\n    }\n  };\n\n  const oneCallback = async (trx, tableName, userAssociatedRecordsOnly) => {\n    trx.count = \"one\";\n    trx.tableName = tableName;\n    if (userAssociatedRecordsOnly) trx.userAssociatedRecordsOnly = userAssociatedRecordsOnly;\n\n    _runListeners(DB_STATUS.PENDING, trx.type, EXECUTE_COUNT.ONE, tableName !== \"untable\" ? tableName : null);\n\n    const res = await tokenPost(POST_TYPES.EASY_QB, trx);\n\n    if (res.success) {\n      _runListeners(DB_STATUS.SUCCESS, trx.type, EXECUTE_COUNT.ONE, tableName !== \"untable\" ? tableName : null, res.data);\n\n      return res.data;\n    } else {\n      _runListeners(DB_STATUS.ERROR, trx.type, EXECUTE_COUNT.ONE, tableName !== \"untable\" ? tableName : null);\n\n      return res;\n    }\n  };\n\n  const db = (tableName, userAssociatedRecordsOnly) => {\n    if (tableName && typeof tableName === \"string\") {\n      return easyqb({\n        allCallback,\n        oneCallback,\n        userAssociatedRecordsOnly,\n        tableName: tableName.toUpperCase()\n      })(tableName.replace(/[^0-9a-zA-Z]/g, '_').toUpperCase());\n    } else {\n      return easyqb({\n        allCallback,\n        oneCallback,\n        userAssociatedRecordsOnly,\n        tableName: \"untable\"\n      })(\"untable\");\n    }\n  };\n\n  return {\n    db,\n    dbEventListener,\n    e: easyqb().e\n  };\n}\n\nfunction EasybaseProvider({\n  ebconfig,\n  options\n}) {\n  const g = gFactory();\n  const {\n    tokenPost,\n    tokenPostAttachment,\n    signUp,\n    setUserAttribute,\n    getUserAttributes,\n    isUserSignedIn,\n    signIn,\n    signOut,\n    resetUserPassword\n  } = authFactory(g);\n  const {\n    Query,\n    fullTableSize,\n    tableTypes\n  } = tableFactory(g);\n  const {\n    db,\n    dbEventListener,\n    e\n  } = dbFactory(g);\n  const {\n    log\n  } = utilsFactory(g);\n\n  if (typeof ebconfig !== 'object' || ebconfig === null || ebconfig === undefined) {\n    console.error(\"No ebconfig object passed. do `import ebconfig from \\\"ebconfig.js\\\"` and pass it to the Easybase provider\");\n    return;\n  } else if (!ebconfig.integration) {\n    console.error(\"Invalid ebconfig object passed. Download ebconfig.js from Easybase.io and try again.\");\n    return;\n  } // eslint-disable-next-line dot-notation\n\n\n  const isIE = typeof document !== 'undefined' && !!document['documentMode'];\n\n  if (isIE) {\n    console.error(\"EASYBASE — easybasejs does not support Internet Explorer. Please use a different browser.\");\n  }\n\n  g.options = _extends({}, options);\n  g.integrationID = ebconfig.integration;\n  g.ebconfig = ebconfig;\n\n  if (g.ebconfig.tt && g.ebconfig.integration.split(\"-\")[0].toUpperCase() !== \"PROJECT\") {\n    g.mounted = false;\n  } else {\n    g.mounted = true;\n  }\n\n  g.instance = \"Node\";\n  let _isFrameInitialized = true;\n  let _frameConfiguration = {\n    offset: 0,\n    limit: 0\n  };\n  const _observedChangeStack = [];\n\n  let _recordIdMap = new WeakMap();\n\n  let _observableFrame = {\n    observe: _ => {},\n    unobserve: () => {}\n  };\n  let _frame = [];\n  let isSyncing = false;\n\n  function Frame(index) {\n    if (typeof index === \"number\") {\n      return _observableFrame[index];\n    } else {\n      return _observableFrame;\n    }\n  }\n\n  const _recordIDExists = record => !!_recordIdMap.get(record);\n\n  const configureFrame = options => {\n    _frameConfiguration = _extends({}, _frameConfiguration);\n    if (options.limit !== undefined) _frameConfiguration.limit = options.limit;\n    if (options.offset !== undefined && options.offset >= 0) _frameConfiguration.offset = options.offset;\n    if (options.tableName !== undefined) _frameConfiguration.tableName = options.tableName;\n    _isFrameInitialized = false;\n    return {\n      message: \"Successfully configured frame. Run sync() for changes to be shown in frame\",\n      success: true\n    };\n  };\n\n  const currentConfiguration = () => _extends({}, _frameConfiguration);\n\n  const deleteRecord = async options => {\n    const _frameRecord = _frame.find(ele => deepEqual(ele, options.record));\n\n    if (_frameRecord && _recordIdMap.get(_frameRecord)) {\n      const res = await tokenPost(POST_TYPES.SYNC_DELETE, {\n        _id: _recordIdMap.get(_frameRecord),\n        tableName: options.tableName\n      });\n      return {\n        success: res.success,\n        message: res.data\n      };\n    } else {\n      try {\n        const res = await tokenPost(POST_TYPES.SYNC_DELETE, {\n          record: options.record,\n          tableName: options.tableName\n        });\n        return {\n          success: res.success,\n          message: res.data\n        };\n      } catch (err) {\n        console.error(\"Easybase Error: deleteRecord failed \", err);\n        return {\n          success: false,\n          message: \"Easybase Error: deleteRecord failed \" + err,\n          error: err\n        };\n      }\n    }\n  };\n\n  const addRecord = async options => {\n    const defaultValues = {\n      insertAtEnd: false,\n      newRecord: {},\n      tableName: undefined\n    };\n\n    const fullOptions = _extends({}, defaultValues, options);\n\n    try {\n      const res = await tokenPost(POST_TYPES.SYNC_INSERT, fullOptions);\n      return {\n        message: res.data,\n        success: res.success\n      };\n    } catch (err) {\n      console.error(\"Easybase Error: addRecord failed \", err);\n      return {\n        message: \"Easybase Error: addRecord failed \" + err,\n        success: false,\n        error: err\n      };\n    }\n  }; // Only allow the deletion of one element at a time\n  // First handle shifting of the array size. Then iterate\n\n\n  const sync = async () => {\n    const _realignFrames = newData => {\n      let isNewDataTheSame = true;\n\n      if (newData.length !== _frame.length) {\n        isNewDataTheSame = false;\n      } else {\n        for (let i = 0; i < newData.length; i++) {\n          const newDataNoId = _extends({}, newData[i]);\n\n          delete newDataNoId._id;\n\n          if (!deepEqual(newDataNoId, _frame[i])) {\n            isNewDataTheSame = false;\n            break;\n          }\n        }\n      }\n\n      if (!isNewDataTheSame) {\n        const oldframe = [..._frame];\n        oldframe.length = newData.length;\n        _recordIdMap = new WeakMap();\n\n        for (let i = 0; i < newData.length; i++) {\n          const currNewEle = newData[i];\n\n          _recordIdMap.set(currNewEle, currNewEle._id);\n\n          delete currNewEle._id;\n          oldframe[i] = currNewEle;\n        }\n\n        _frame = oldframe;\n\n        _observableFrame.unobserve();\n\n        _observableFrame = Observable.from(_frame);\n\n        _observableFrame.observe(allChanges => {\n          allChanges.forEach(change => {\n            _observedChangeStack.push({\n              type: change.type,\n              path: change.path,\n              value: change.value,\n              _id: _recordIdMap.get(_frame[Number(change.path[0])]) // Not bringing change.object or change.oldValue\n\n            });\n\n            log(JSON.stringify({\n              type: change.type,\n              path: change.path,\n              value: change.value,\n              _id: _recordIdMap.get(_frame[Number(change.path[0])]) // Not bringing change.object or change.oldValue\n\n            }));\n          });\n        });\n      }\n    };\n\n    if (isSyncing) {\n      return {\n        success: false,\n        message: \"Easybase Error: the provider is currently syncing, use 'await sync()' before calling sync() again\"\n      };\n    }\n\n    isSyncing = true;\n\n    if (_isFrameInitialized) {\n      if (_observedChangeStack.length > 0) {\n        log(\"Stack change: \", _observedChangeStack);\n        const res = await tokenPost(POST_TYPES.SYNC_STACK, _extends({\n          stack: _observedChangeStack\n        }, _frameConfiguration));\n\n        if (res.success) {\n          _observedChangeStack.length = 0;\n        }\n      }\n    }\n\n    try {\n      const res = await tokenPost(POST_TYPES.GET_FRAME, _frameConfiguration); // Check if the array recieved from db is the same as frame\n      // If not, update it and send useFrameEffect\n\n      if (res.success === false) {\n        console.error(res.data);\n        isSyncing = false;\n        return {\n          success: false,\n          message: \"\" + res.data\n        };\n      } else {\n        _isFrameInitialized = true;\n\n        _realignFrames(res.data);\n\n        isSyncing = false;\n        return {\n          message: 'Success. Call frame for data',\n          success: true\n        };\n      }\n    } catch (err) {\n      console.error(\"Easybase Error: get failed \", err);\n      isSyncing = false;\n      return {\n        success: false,\n        message: \"Easybase Error: get failed \" + err,\n        error: err\n      };\n    }\n  };\n\n  const updateRecordImage = async options => {\n    const res = await _updateRecordAttachment(options, \"image\");\n    return res;\n  };\n\n  const updateRecordVideo = async options => {\n    const res = await _updateRecordAttachment(options, \"video\");\n    return res;\n  };\n\n  const updateRecordFile = async options => {\n    const res = await _updateRecordAttachment(options, \"file\");\n    return res;\n  };\n\n  const _updateRecordAttachment = async (options, type) => {\n    const _frameRecord = _frame.find(ele => deepEqual(ele, options.record));\n\n    if (_frameRecord === undefined || !_recordIDExists(_frameRecord)) {\n      log(\"Attempting to add attachment to a new record that has not been synced. Please sync() before trying to add attachment.\");\n      return {\n        success: false,\n        message: \"Attempting to add attachment to a new record that has not been synced. Please sync() before trying to add attachment.\"\n      };\n    }\n\n    const ext = options.attachment.name.split(\".\").pop().toLowerCase();\n    log(ext);\n\n    if (type === \"image\" && !imageExtensions.includes(ext)) {\n      return {\n        success: false,\n        message: \"Image files must have a proper image extension in the file name\"\n      };\n    }\n\n    if (type === \"video\" && !videoExtensions.includes(ext)) {\n      return {\n        success: false,\n        message: \"Video files must have a proper video extension in the file name\"\n      };\n    }\n\n    function isFileFromURI(f) {\n      return f.uri !== undefined;\n    }\n\n    const formData = new FormData();\n\n    if (isFileFromURI(options.attachment)) {\n      formData.append(\"file\", options.attachment);\n      formData.append(\"name\", options.attachment.name);\n    } else {\n      formData.append(\"file\", options.attachment);\n      formData.append(\"name\", options.attachment.name);\n    }\n\n    const customHeaders = {\n      'Eb-upload-type': type,\n      'Eb-column-name': options.columnName,\n      'Eb-record-id': _recordIdMap.get(_frameRecord),\n      'Eb-table-name': options.tableName\n    };\n    const res = await tokenPostAttachment(formData, customHeaders);\n    await sync();\n    return {\n      message: res.data,\n      success: res.success\n    };\n  };\n\n  const c = {\n    /** +++ Will be deprecated */\n    configureFrame,\n    addRecord,\n    deleteRecord,\n    sync,\n    Frame,\n    currentConfiguration,\n\n    /** --- */\n    updateRecordImage,\n    updateRecordVideo,\n    updateRecordFile,\n    fullTableSize,\n    tableTypes,\n    Query,\n    isUserSignedIn,\n    signIn,\n    signOut,\n    signUp,\n    resetUserPassword,\n    setUserAttribute,\n    getUserAttributes,\n    db,\n    dbEventListener,\n    e\n  };\n  return c;\n}\n\nconst generateBareUrl = (type, integrationID) => `https://api.easybase.io/${type}/${integrationID}`;\n\nconst isBadInt = my_int => my_int !== undefined && my_int !== null && Math.floor(my_int) !== my_int;\n\nconst isBadString = my_string => my_string !== undefined && my_string !== null && typeof my_string !== \"string\";\n\nconst isBadIntegrationID = my_string => my_string === undefined || my_string === null || typeof my_string !== \"string\";\n\nconst isBadObject = my_obj => my_obj !== undefined && my_obj !== null && typeof my_obj !== \"object\";\n\nconst isBadBool = my_bool => my_bool !== undefined && my_bool !== null && typeof my_bool !== \"boolean\";\n/**\r\n *\r\n * @param {GetOptions} options GetOptions.\r\n * @returns {Promise<Array>} Array of records.\r\n *\r\n */\n\n\nfunction get(options) {\n  const defaultOptions = {\n    integrationID: \"\",\n    offset: undefined,\n    limit: undefined,\n    authentication: undefined,\n    customQuery: undefined\n  };\n\n  const {\n    integrationID,\n    offset,\n    limit,\n    authentication,\n    customQuery\n  } = _extends({}, defaultOptions, options);\n\n  if (isBadIntegrationID(integrationID)) throw new Error(\"integrationID is required and must be a string\");\n  if (isBadInt(offset)) throw new Error(\"offset must be an integer\");\n  if (isBadInt(limit)) throw new Error(\"limit must be an integer\");\n  if (isBadString(authentication)) throw new Error(\"authentication must be a string or null\");\n  if (isBadObject(customQuery)) throw new Error(\"customQuery must be an object or null\");\n  return new Promise((resolve, reject) => {\n    try {\n      let fetch_body = {};\n      if (typeof customQuery === \"object\") fetch_body = _extends({}, customQuery);\n      if (offset !== undefined) fetch_body.offset = offset;\n      if (limit !== undefined) fetch_body.limit = limit;\n      if (authentication !== undefined) fetch_body.authentication = authentication;\n      fetch(generateBareUrl('get', integrationID), {\n        method: \"POST\",\n        body: JSON.stringify(fetch_body),\n        headers: {\n          'Accept': 'application/json',\n          'Content-Type': 'application/json'\n        }\n      }).then(res => res.json()).then(resData => {\n        if ({}.hasOwnProperty.call(resData, 'ErrorCode')) {\n          console.error(resData.message);\n          resolve([resData.message]);\n        } else resolve(resData);\n      });\n    } catch (err) {\n      reject(err);\n    }\n  });\n}\n/**\r\n *\r\n * @param {PostOptions} options PostOptions\r\n * @returns {Promise<String>} Post status.\r\n *\r\n */\n\n\nfunction post(options) {\n  const defaultValues = {\n    integrationID: \"\",\n    newRecord: undefined,\n    authentication: undefined,\n    insertAtEnd: undefined\n  };\n\n  const {\n    integrationID,\n    newRecord,\n    authentication,\n    insertAtEnd\n  } = _extends({}, defaultValues, options);\n\n  if (isBadIntegrationID(integrationID)) throw new Error(\"integrationID is required and must be a string\");\n  if (isBadObject(newRecord)) throw new Error(\"newRecord is required and must be a string\");\n  if (isBadString(authentication)) throw new Error(\"authentication must be a string or null\");\n  if (isBadBool(insertAtEnd)) throw new Error(\"insertAtEnd must be a boolean or null\");\n  return new Promise((resolve, reject) => {\n    try {\n      const fetch_body = _extends({}, newRecord);\n\n      if (authentication !== undefined) fetch_body.authentication = authentication;\n      if (insertAtEnd !== undefined) fetch_body.insertAtEnd = insertAtEnd;\n      fetch(generateBareUrl('post', integrationID), {\n        method: \"POST\",\n        body: JSON.stringify(fetch_body),\n        headers: {\n          'Accept': 'application/json',\n          'Content-Type': 'application/json'\n        }\n      }).then(res => res.json()).then(resData => {\n        if ({}.hasOwnProperty.call(resData, 'ErrorCode')) console.error(resData.message);\n        resolve(resData);\n      });\n    } catch (err) {\n      reject(err);\n    }\n  });\n}\n/**\r\n *\r\n * @param {UpdateOptions} options UpdateOptions\r\n * @returns {Promise<String>} Update status.\r\n */\n\n\nfunction update(options) {\n  const defaultValues = {\n    integrationID: \"\",\n    updateValues: undefined,\n    authentication: undefined,\n    customQuery: undefined\n  };\n\n  const {\n    integrationID,\n    updateValues,\n    authentication,\n    customQuery\n  } = _extends({}, defaultValues, options);\n\n  if (isBadIntegrationID(integrationID)) throw new Error(\"integrationID is required and must be a string\");\n  if (isBadObject(updateValues) || updateValues === undefined) throw new Error(\"updateValues is required and must be a string\");\n  if (isBadString(authentication)) throw new Error(\"authentication must be a string or null\");\n  if (isBadObject(customQuery)) throw new Error(\"customQuery must be an object or null\");\n  return new Promise((resolve, reject) => {\n    try {\n      const fetch_body = _extends({\n        updateValues\n      }, customQuery);\n\n      if (authentication !== undefined) fetch_body.authentication = authentication;\n      fetch(generateBareUrl('update', integrationID), {\n        method: \"POST\",\n        body: JSON.stringify(fetch_body),\n        headers: {\n          'Accept': 'application/json',\n          'Content-Type': 'application/json'\n        }\n      }).then(res => res.json()).then(resData => {\n        if ({}.hasOwnProperty.call(resData, 'ErrorCode')) console.error(resData.message);\n        resolve(resData.message);\n      });\n    } catch (err) {\n      reject(err);\n    }\n  });\n}\n/**\r\n *\r\n * @param {DeleteOptions} options DeleteOptions\r\n * @return {Promise<String>} Delete status.\r\n */\n\n\nfunction Delete(options) {\n  const defaultValues = {\n    integrationID: \"\",\n    authentication: undefined,\n    customQuery: undefined\n  };\n\n  const {\n    integrationID,\n    authentication,\n    customQuery\n  } = _extends({}, defaultValues, options);\n\n  if (isBadIntegrationID(integrationID)) throw new Error(\"integrationID is required and must be a string\");\n  if (isBadString(authentication)) throw new Error(\"authentication must be a string or null\");\n  if (isBadObject(customQuery)) throw new Error(\"customQuery must be an object or null\");\n  return new Promise((resolve, reject) => {\n    try {\n      const fetch_body = _extends({}, customQuery);\n\n      if (authentication !== undefined) fetch_body.authentication = authentication;\n      fetch(generateBareUrl('delete', integrationID), {\n        method: \"POST\",\n        body: JSON.stringify(fetch_body),\n        headers: {\n          'Accept': 'application/json',\n          'Content-Type': 'application/json'\n        }\n      }).then(res => res.json()).then(resData => {\n        if ({}.hasOwnProperty.call(resData, 'ErrorCode')) console.error(resData.message);\n        resolve(resData.message);\n      });\n    } catch (err) {\n      reject(err);\n    }\n  });\n}\n/**\r\n * @async\r\n * Call a cloud function, created in Easybase interface.\r\n * @param {string} route Route as detailed in Easybase. Found under 'Deploy'. Will be in the form of ####...####-function-name.\r\n * @param {Record<string, any>} postBody Optional object to pass as the body of the POST request. This object will available in your cloud function's event.body.\r\n * @return {Promise<string>} Response from your cloud function. Detailed with a call to 'return context.succeed(\"RESPONSE\")'.\r\n */\n\n\nasync function callFunction(route, postBody) {\n  const res = await fetch(generateBareUrl('function', route.split(\"/\").pop()), {\n    method: \"POST\",\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify(postBody) || \"\"\n  });\n  const rawDataText = await res.text();\n  return rawDataText;\n}\n\nexport { Delete, EasybaseProvider, callFunction, get, post, update };","map":{"version":3,"sources":["../src/EasybaseProvider/types.ts","../src/EasybaseProvider/g.ts","../src/EasybaseProvider/object-observer.js","../src/EasybaseProvider/utils.ts","../src/EasybaseProvider/auth.ts","../src/EasybaseProvider/table.ts","../src/EasybaseProvider/db.ts","../src/EasybaseProvider/EasybaseProvider.ts","../src/index.ts"],"names":["POST_TYPES","DB_STATUS","EXECUTE_COUNT","GlobalNamespace","_g","gFactory","INSERT","UPDATE","DELETE","REVERSE","SHUFFLE","oMetaKey","Symbol","validObservableOptionKeys","async","validObserverOptionKeys","path","pathsOf","pathsFrom","processObserveOptions","result","options","n","invalidOptions","Object","option","observe","observer","oMeta","observers","o","opts","console","unobserve","ol","al","arguments","i","propertiesBluePrint","value","prepareObject","target","getObservedOf","source","prepareArray","l","prepareTypedArray","filterChanges","oPath","changes","change","oPathsOf","oPathsFrom","callObserverSafe","listener","callObserversFromMT","batches","callObservers","currentObservable","relevantChanges","queueMicrotask","rb","b","Array","tmpa","tmp","newPath","type","oldValue","object","ownKey","parent","ArrayBuffer","item","proxiedPop","poppedIndex","popResult","tmpObserved","proxiedPush","pushContent","initialLength","pushResult","Reflect","proxiedShift","shiftResult","proxiedUnshift","unshiftContent","unshiftResult","proxiedReverse","proxiedSort","proxiedFill","tarLen","prev","start","Math","end","tmpTarget","proxiedCopyWithin","dest","len","nItem","oItem","proxiedSplice","splLen","spliceContent","startIndex","removed","inserted","spliceResult","newTarLen","index","proxiedTypedArraySet","souLen","offset","proxiedArrayMethods","pop","push","shift","unshift","reverse","sort","fill","copyWithin","splice","proxiedTypedArrayMethods","set","constructor","targetClone","cloningFunction","Proxy","properties","processOptions","detach","newValue","proxy","deleteProperty","get","from","isObservable","input","utilsFactory","globals","g","generateBareUrl","integrationID","generateAuthBody","stamp","Date","token","token_time","now","log","authFactory","getUserAttributes","attrsRes","tokenPost","setUserAttribute","setAttrsRes","success","message","JSON","error","signUp","signUpRes","userAttributes","data","signIn","t1","integrationType","res","fetch","method","headers","body","version","session","instance","password","resData","validTokenRes","elapsed","resetUserPassword","newPassword","isUserSignedIn","signOut","initAuth","tt","_auth","req_res","refreshToken","tokenPostAttachment","regularAuthbody","attachmentAuth","UPLOAD_ATTACHMENT","formData","tableFactory","Query","defaultOptions","queryName","fullOptions","tableName","tableTypes","dbFactory","_listenerIndex","_listeners","cb","dbEventListener","callback","currKey","allCallback","trx","_runListeners","oneCallback","db","e","easyqb","EasybaseProvider","ebconfig","isIE","document","_isFrameInitialized","_frameConfiguration","limit","_observedChangeStack","_recordIdMap","_observableFrame","_","_frame","isSyncing","_recordIDExists","record","configureFrame","currentConfiguration","deleteRecord","_frameRecord","ele","deepEqual","_id","err","addRecord","defaultValues","insertAtEnd","newRecord","undefined","sync","_realignFrames","newData","isNewDataTheSame","newDataNoId","oldframe","currNewEle","Observable","allChanges","Number","stack","updateRecordImage","_updateRecordAttachment","updateRecordVideo","updateRecordFile","ext","imageExtensions","videoExtensions","f","isFileFromURI","customHeaders","c","isBadInt","my_int","isBadString","my_string","isBadIntegrationID","isBadObject","my_obj","isBadBool","my_bool","authentication","customQuery","fetch_body","resolve","reject","post","update","updateValues","Delete","route","rawDataText"],"mappings":"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","sourcesContent":["import { SQW } from \"EasyQB/types/sq\";\nimport { NewExpression } from \"EasyQB/types/expression\";\n\nexport interface ConfigureFrameOptions {\n    /** Edit starting index from which records will be retrieved from. Useful for paging. */\n    offset?: number;\n    /** Limit the amount of records to be retrieved. Set to -1 or null to return all records. Can be used in combination with offset. */\n    limit?: number | null;\n    /** Table to sync frame with. (Projects only) */\n    tableName?: string;\n}\n\nexport interface EasybaseProviderPropsOptions {\n    /** Custom authentication string. Can be set in integration menu. If it is set, it is required to access integration. This acts as an extra layer of security and extensibility. */\n    authentication?: string;\n    /** Log Easybase react status and events to console. */\n    logging?: boolean;\n}\n\nexport interface EasybaseProviderProps {\n    /** EasyBase ebconfig object. Can be downloaded in the integration drawer next to 'React Token'. This is automatically generated.  */\n    ebconfig: Ebconfig;\n    /** Optional configuration parameters. */\n    options?: EasybaseProviderPropsOptions\n}\n\nexport interface FrameConfiguration {\n    /** Edit starting index from which records will be retrieved from. Useful for paging. */\n    offset: number;\n    /** Limit the amount of records to be retrieved. Set to -1 or null to return all records. Can be used in combination with offset. */\n    limit: number | null;\n    /** Table to sync frame with. (Projects only) */\n    tableName?: string;\n}\n\nexport interface Ebconfig {\n    tt?: string,\n    integration: string,\n    version: string\n}\n\nexport interface AddRecordOptions {\n    /** If true, record will be inserted at the end of the collection rather than the front. Overwrites absoluteIndex. */\n    insertAtEnd?: boolean;\n    /** Values to post to EasyBase collection. Format is { column name: value } */\n    newRecord: Record<string, any>;\n    /** Table to post new record to. (Projects only) */\n    tableName?: string;\n}\n\nexport interface DeleteRecordOptions {\n    record: Record<string, any>;\n    /** Table to delete record from. (Projects only) */\n    tableName?: string;\n}\n\nexport interface QueryOptions {\n    /** Name of the query saved in Easybase's Visual Query Builder */\n    queryName: string;\n    /** If you would like to sort the order of your query by a column. Pass the name of that column here */\n    sortBy?: string;\n    /** By default, columnToSortBy will sort your query by ascending value (1, 2, 3...). To sort by descending set this to true */\n    descending?: boolean;\n    /** Edit starting index from which records will be retrieved from. Useful for paging. */\n    offset?: number;\n    /** Limit the amount of records to be retrieved. Can be used in combination with offset. */\n    limit?: number;\n    /** This object can be set to overwrite the query values as set in the integration menu. If your query is setup to find records where 'age' >= 0, passing in { age: 50 } will query where 'age' >= 50. Read more: https://easybase.io/about/2020/09/15/Customizing-query-values/ */\n    customQuery?: Record<string, any>;\n    /** Table to query. (Projects only) */\n    tableName?: string;\n}\n\nexport interface FileFromURI {\n    /** Path on local device to the attachment. Usually received from react-native-image-picker or react-native-document-picker */\n    uri: string,\n    /** Name of the file with proper extension */\n    name: string,\n    /** File MIME type */\n    type: string\n}\n\nexport interface UpdateRecordAttachmentOptions {\n    /** EasyBase Record to attach this attachment to */\n    record: Record<string, any>;\n    /** The name of the column that is of type file/image/video */\n    columnName: string;\n    /** Either an HTML File element containing the correct type of attachment or a FileFromURI object for React Native instances.\n     * For React Native use libraries such as react-native-image-picker and react-native-document-picker.\n     * The file name must have a proper file extension corresponding to the attachment. \n     */\n    attachment: File | FileFromURI;\n    /** Table to post attachment to. (Projects only) */\n    tableName?: string;\n}\n\nexport interface StatusResponse {\n    /** Returns true if the operation was successful */\n    success: boolean;\n    /** Readable description of the the operation's status */\n    message: string;\n    /** Will represent a corresponding error if an error was thrown during the operation. */\n    error?: Error;\n}\n\nexport enum POST_TYPES {\n    UPLOAD_ATTACHMENT = \"upload_attachment\",\n    HANDSHAKE = \"handshake\",\n    VALID_TOKEN = \"valid_token\",\n    GET_FRAME = \"get_frame\",\n    TABLE_SIZE = \"table_size\",\n    COLUMN_TYPES = \"column_types\",\n    SYNC_STACK = \"sync_stack\",\n    SYNC_DELETE = \"sync_delete\",\n    SYNC_INSERT = \"sync_insert\",\n    GET_QUERY = \"get_query\",\n    USER_ATTRIBUTES = \"user_attributes\",\n    SET_ATTRIBUTE = \"set_attribute\",\n    SIGN_UP = \"sign_up\",\n    REQUEST_TOKEN = \"request_token\",\n    EASY_QB = \"easyqb\",\n    RESET_PASSWORD = \"reset_password\"\n}\n\nexport enum DB_STATUS {\n    ERROR = \"error\",\n    PENDING = \"pending\",\n    SUCCESS = \"success\"\n}\n\nexport enum EXECUTE_COUNT {\n    ALL = \"all\",\n    ONE = \"one\"\n}\n\nexport interface AuthPostResponse {\n    success: boolean;\n    data: any;\n}\n\nexport interface ContextValue {\n    /**\n     * Check if a user is currently signed in.\n     */\n    isUserSignedIn(): boolean;\n    /**\n     * Signs out the current user.\n     */\n    signOut(): void;\n    /**\n     * Retrieve the currently signed in users attribute object.\n     * @async\n     * @return {Promise<Record<string, string>>} Promise<Record<string, string>>\n     */\n    getUserAttributes(): Promise<Record<string, string>>;\n    /**\n     * Set a single attribute of the currently signed in user. Can also be updated visually in the Easybase 'Users' tab.\n     * @async\n     * @abstract\n     * @param key Object key. Can be a new key or existing key.\n     * @param value attribute value.\n     * @return {Promise<StatusResponse>} Promise<StatusResponse>\n     */\n    setUserAttribute(key: string, value: string): Promise<StatusResponse>;\n    /**\n     * Reset the currently signed-in user's password to a new string.\n     * @async\n     * @param {string} newPassword New user password\n     * @return {Promise<StatusResponse>} Promise<StatusResponse>\n     */\n    resetUserPassword(newPassword: string): Promise<StatusResponse>;\n    /**\n     * Sign in a user that already exists for a project.\n     * @abstract\n     * @async\n     * @param userID unique identifier for new user. Usually an email or phone number.\n     * @param password user password.\n     * @return {Promise<StatusResponse>} Promise<StatusResponse>\n     */\n    signIn(userID: string, password: string): Promise<StatusResponse>;\n    /**\n     * Create a new user for your project. You must still call signIn() after signing up.\n     * @abstract\n     * @async\n     * @param newUserID unique identifier for new user. Usually an email or phone number.\n     * @param password user password. Must be at least 8 characters long.\n     * @param userAttributes Optional object to store user attributes. Can also be edited visually in the Easybase 'Users' tab.\n     * @return {Promise<StatusResponse>} Promise<StatusResponse>\n     */\n    signUp(newUserID: string, password: string, userAttributes?: Record<string, string>): Promise<StatusResponse>;\n    /**\n     * Configure the current frame size. Set the offset and amount of records to retreive assume you don't want to receive\n     * your entire collection. This is useful for paging.\n     * @abstract\n     * @param {ConfigureFrameOptions} options ConfigureFrameOptions\n     * @return {StatusResponse} StatusResponse\n     */\n    configureFrame(options: ConfigureFrameOptions): StatusResponse;\n    /**\n     * Manually add a record to your collection regardless of your current frame. You must call sync() after this to see updated response.\n     * @abstract\n     * @async\n     * @param {AddRecordOptions} options AddRecordOptions\n     * @return {Promise<StatusResponse>} Promise<StatusResponse>\n     */\n    addRecord(options: AddRecordOptions): Promise<StatusResponse>;\n    /**\n     * Manually delete a record from your collection regardless of your current frame. You must call sync() after this to see updated response.\n     * @abstract\n     * @async\n     * @param {Record<string, any>} record \n     * @return {Promise<StatusResponse>} Promise<StatusResponse>\n     */\n    deleteRecord(options: DeleteRecordOptions): Promise<StatusResponse>;\n    /**\n     * Call this method to syncronize your current changes with your database. Delections, additions, and changes will all be reflected by your \n     * backend after calling this method. Call Frame() after this to get a normalized array of the freshest data.\n     * @abstract\n     * @async\n     * @return {Promise<StatusResponse>} Promise<StatusResponse>\n     */\n    sync(): Promise<StatusResponse>;\n    /**\n     * Upload an image to your backend and attach it to a specific record. columnName must reference a column of type 'image'.\n     * The file must have an extension of an image. \n     * Call sync() for fresh data with propery attachment links to cloud hosting.\n     * @abstract\n     * @async\n     * @param {UpdateRecordAttachmentOptions} options UpdateRecordAttachmentOptions\n     * @return {Promise<StatusResponse>} Promise<StatusResponse>\n     */\n    updateRecordImage(options: UpdateRecordAttachmentOptions): Promise<StatusResponse>;\n    /**\n     * Upload a video to your backend and attach it to a specific record. columnName must reference a column of type 'video'. \n     * The file must have an extension of a video.\n     * Call sync() for fresh data with propery attachment links to cloud hosting.\n     * @abstract\n     * @async\n     * @param {UpdateRecordAttachmentOptions} options UpdateRecordAttachmentOptions\n     * @return {Promise<StatusResponse>} Promise<StatusResponse>\n     */\n    updateRecordVideo(options: UpdateRecordAttachmentOptions): Promise<StatusResponse>;\n    /**\n     * Upload a file to your backend and attach it to a specific record. columnName must reference a column of type 'file'. \n     * Call sync() for fresh data with propery attachment links to cloud hosting.\n     * @abstract\n     * @async\n     * @param {UpdateRecordAttachmentOptions} options UpdateRecordAttachmentOptions\n     * @return {Promise<StatusResponse>} Promise<StatusResponse>\n     */\n    updateRecordFile(options: UpdateRecordAttachmentOptions): Promise<StatusResponse>;\n    /**\n     * This function is how you access your current frame. This function does not get new data or push changes to EasyBase. If you \n     * want to syncronize your frame and EasyBase, call sync() then Frame().\n     * @abstract\n     * @return {Record<string, any>[]} Array of records corresponding to the current frame. Call sync() to push changes that you have made to this array.\n     * \n     */\n    Frame(): Record<string, any>[];\n    /**\n     * This function is how you access a single object your current frame. This function does not get new data or push changes to EasyBase. If you \n     * want to syncronize your frame and EasyBase, call sync() then Frame().\n     * @abstract\n     * @param {number} [index] Passing an index will only return the object at that index in your Frame, rather than the entire array. This is useful for editing single objects based on an index.\n     * @return {Record<string, any>} Single record corresponding to that object within the current frame. Call sync() to push changes that you have made to this object.\n     * \n     */\n    Frame(index: number): Record<string, any>;\n    /**\n     * Gets the number of records in your table.\n     * @async\n     * @returns {Promise<number>} The the number of records in your table.\n     */\n    fullTableSize(): Promise<number>;\n    /**\n     * Gets the number of records in your table.\n     * @async\n     * @param {string} [tableName] Name of table to get the sizes of. (Projects only)\n     * @returns {Promise<number>} The the number of records in your table.\n     */\n    fullTableSize(tableName: string): Promise<number>;\n    /**\n     * Retrieve an object detailing the columns in your table mapped to their corresponding type.\n     * @async\n     * @returns {Promise<Record<string, any>>} Object detailing the columns in your table mapped to their corresponding type.\n     */\n    tableTypes(): Promise<Record<string, any>>;\n    /**\n     * Retrieve an object detailing the columns in your table mapped to their corresponding type.\n     * @async\n     * @param {string} [tableName] Name of table to get the types of. (Projects only)\n     * @returns {Promise<Record<string, any>>} Object detailing the columns in your table mapped to their corresponding type.\n     */\n    tableTypes(tableName: string): Promise<Record<string, any>>;\n    /**\n     * View your frames current configuration\n     * @returns {Record<string, any>} Object contains the `offset` and `length` of your current frame.\n     */\n    currentConfiguration(): FrameConfiguration;\n    /**\n     * @async\n     * View a query by name. This returns an isolated array that has no effect on your frame or frame configuration. sync() and Frame() have no \n     * relationship with a Query(). An edited Query cannot be synced with your database, use Frame() for realtime \n     * database array features.\n     * @param {QueryOptions} options QueryOptions\n     * @return {Promise<Record<string, any>[]>} Isolated array of records in the same form as Frame(). Editing this array has no effect and cannot be synced with your database. Use Frame() for realtime database features.\n     */\n    Query(options: QueryOptions): Promise<Record<string, any>[]>;\n    /**\n     * Instantiate EasyQB instance for dynamic CRUD query building: https://easybase.github.io/EasyQB/\n     * @param {string} [tableName] Name of your table.\n     * @param {boolean} [userAssociatedRecordsOnly] **PROJECTS ONLY** Operations will only be performed on records already associated to the currently signed-in user. Inserted records will automatically be associate to the user.\n     * @returns {SQW} EasyQB object for dynamic querying: https://easybase.github.io/EasyQB/\n     */\n    db(tableName?: string, userAssociatedRecordsOnly?: boolean): SQW;\n    /**\n     * Subscribe to db events, invoked by calling `.all` or `.one`: https://easybase.github.io/EasyQB/\n     * @param {function(status?: DB_STATUS, queryType?: string, executeCount?: EXECUTE_COUNT, tableName?: string | null, returned?: any):void} [callback] Callback function to execute on db operations.\n     * @returns {function():void} Calling this function unsubscribes your callback function from events.\n     */\n    dbEventListener(callback: (status?: DB_STATUS, queryType?: string, executeCount?: EXECUTE_COUNT, tableName?: string | null, returned?: any) => void): () => void;\n    /**\n     * Expressions and operations builder for `.db()`, used to create complex conditions, aggregators, and clauses. https://easybase.github.io/EasyQB/docs/operations.html\n     */\n    e: NewExpression;\n}\n\nexport interface Globals {\n    ebconfig: Ebconfig;\n    token: string;\n    refreshToken: string;\n    integrationID: string;\n    session: number;\n    options: EasybaseProviderPropsOptions;\n    instance: string;\n    mounted: boolean;\n    newTokenCallback(): void;\n}\n","import { Ebconfig, EasybaseProviderPropsOptions, Globals } from \"./types\";\n\nnamespace GlobalNamespace {\n    export let ebconfig: Ebconfig;\n    export let token: string;\n    export let refreshToken: string;\n    export let integrationID: string;\n    export let session: number;\n    export let options: EasybaseProviderPropsOptions;\n    export let instance: string;\n    export let mounted: boolean;\n    export let newTokenCallback: () => {};\n}\n\nconst _g: Globals = { ...GlobalNamespace };\n\nexport default _g;\n \nexport function gFactory(): Globals {\n    return { ...GlobalNamespace } as Globals;\n}\n","const\n\tINSERT = 'insert',\n\tUPDATE = 'update',\n\tDELETE = 'delete',\n\tREVERSE = 'reverse',\n\tSHUFFLE = 'shuffle',\n\toMetaKey = Symbol('observable-meta-key'),\n\tvalidObservableOptionKeys = { async: 1 },\n\tvalidObserverOptionKeys = { path: 1, pathsOf: 1, pathsFrom: 1 },\n\tprocessObserveOptions = function processObserveOptions(options) {\n\t\tconst result = {};\n\t\tif (options.path !== undefined) {\n\t\t\tif (typeof options.path !== 'string' || options.path === '') {\n\t\t\t\tthrow new Error('\"path\" option, if/when provided, MUST be a non-empty string');\n\t\t\t}\n\t\t\tresult.path = options.path;\n\t\t}\n\t\tif (options.pathsOf !== undefined) {\n\t\t\tif (options.path) {\n\t\t\t\tthrow new Error('\"pathsOf\" option MAY NOT be specified together with \"path\" option');\n\t\t\t}\n\t\t\tif (typeof options.pathsOf !== 'string') {\n\t\t\t\tthrow new Error('\"pathsOf\" option, if/when provided, MUST be a string (MAY be empty)');\n\t\t\t}\n\t\t\tresult.pathsOf = options.pathsOf.split('.').filter(n => n);\n\t\t}\n\t\tif (options.pathsFrom !== undefined) {\n\t\t\tif (options.path || options.pathsOf) {\n\t\t\t\tthrow new Error('\"pathsFrom\" option MAY NOT be specified together with \"path\"/\"pathsOf\"  option/s');\n\t\t\t}\n\t\t\tif (typeof options.pathsFrom !== 'string' || options.pathsFrom === '') {\n\t\t\t\tthrow new Error('\"pathsFrom\" option, if/when provided, MUST be a non-empty string');\n\t\t\t}\n\t\t\tresult.pathsFrom = options.pathsFrom;\n\t\t}\n\t\tconst invalidOptions = Object.keys(options).filter(option => !validObserverOptionKeys.hasOwnProperty(option));\n\t\tif (invalidOptions.length) {\n\t\t\tthrow new Error(`'${invalidOptions.join(', ')}' is/are not a valid observer option/s`);\n\t\t}\n\t\treturn result;\n\t},\n\tobserve = function observe(observer, options) {\n\t\tif (typeof observer !== 'function') {\n\t\t\tthrow new Error(`observer MUST be a function, got '${observer}'`);\n\t\t}\n\n\t\tconst\n\t\t\toMeta = this[oMetaKey],\n\t\t\tobservers = oMeta.observers;\n\t\tif (!observers.some(o => o[0] === observer)) {\n\t\t\tlet opts;\n\t\t\tif (options) {\n\t\t\t\topts = processObserveOptions(options);\n\t\t\t} else {\n\t\t\t\topts = {};\n\t\t\t}\n\t\t\tobservers.push([observer, opts]);\n\t\t} else {\n\t\t\tconsole.warn('observer may be bound to an observable only once; will NOT rebind');\n\t\t}\n\t},\n\tunobserve = function unobserve() {\n\t\tconst oMeta = this[oMetaKey];\n\t\tconst observers = oMeta.observers;\n\t\tlet ol = observers.length;\n\t\tif (ol) {\n\t\t\tlet al = arguments.length;\n\t\t\tif (al) {\n\t\t\t\twhile (al--) {\n\t\t\t\t\tlet i = ol;\n\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\tif (observers[i][0] === arguments[al]) {\n\t\t\t\t\t\t\tobservers.splice(i, 1);\n\t\t\t\t\t\t\tol--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tobservers.splice(0);\n\t\t\t}\n\t\t}\n\t},\n\tpropertiesBluePrint = { [oMetaKey]: { value: null }, observe: { value: observe }, unobserve: { value: unobserve } },\n\tprepareObject = function prepareObject(source, oMeta) {\n\t\tpropertiesBluePrint[oMetaKey].value = oMeta;\n\t\tconst target = Object.defineProperties({}, propertiesBluePrint);\n\t\tfor (const key of Object.keys(source)) {\n\t\t\ttarget[key] = getObservedOf(source[key], key, oMeta);\n\t\t}\n\t\treturn target;\n\t},\n\tprepareArray = function prepareArray(source, oMeta) {\n\t\tlet i = 0, l = source.length;\n\t\tpropertiesBluePrint[oMetaKey].value = oMeta;\n\t\tconst target = Object.defineProperties(new Array(l), propertiesBluePrint);\n\t\tfor (; i < l; i++) {\n\t\t\ttarget[i] = getObservedOf(source[i], i, oMeta);\n\t\t}\n\t\treturn target;\n\t},\n\tprepareTypedArray = function prepareTypedArray(source, oMeta) {\n\t\tpropertiesBluePrint[oMetaKey].value = oMeta;\n\t\tObject.defineProperties(source, propertiesBluePrint);\n\t\treturn source;\n\t},\n\tfilterChanges = function filterChanges(options, changes) {\n\t\tlet result = changes;\n\t\tif (options.path) {\n\t\t\tconst oPath = options.path;\n\t\t\tresult = changes.filter(change =>\n\t\t\t\tchange.path.join('.') === oPath\n\t\t\t);\n\t\t} else if (options.pathsOf) {\n\t\t\tconst oPathsOf = options.pathsOf;\n\t\t\tresult = changes.filter(change =>\n\t\t\t\tchange.path.length === oPathsOf.length + 1 ||\n\t\t\t\t(change.path.length === oPathsOf.length && (change.type === REVERSE || change.type === SHUFFLE))\n\t\t\t);\n\t\t} else if (options.pathsFrom) {\n\t\t\tconst oPathsFrom = options.pathsFrom;\n\t\t\tresult = changes.filter(change =>\n\t\t\t\tchange.path.join('.').startsWith(oPathsFrom)\n\t\t\t);\n\t\t}\n\t\treturn result;\n\t},\n\tcallObserverSafe = function callObserverSafe(listener, changes) {\n\t\ttry {\n\t\t\tlistener(changes);\n\t\t} catch (e) {\n\t\t\tconsole.error(`failed to notify listener ${listener} with ${changes}`, e);\n\t\t}\n\t},\n\tcallObserversFromMT = function callObserversFromMT() {\n\t\tconst batches = this.batches;\n\t\tthis.batches = null;\n\t\tfor (const [listener, options] of batches) {\n\t\t\tcallObserverSafe(listener, options);\n\t\t}\n\t},\n\tcallObservers = function callObservers(oMeta, changes) {\n\t\tlet currentObservable = oMeta;\n\t\tlet observers, target, options, relevantChanges, i, newPath, tmp;\n\t\tconst l = changes.length;\n\t\tdo {\n\t\t\tobservers = currentObservable.observers;\n\t\t\ti = observers.length;\n\t\t\twhile (i--) {\n\t\t\t\t[target, options] = observers[i];\n\t\t\t\trelevantChanges = filterChanges(options, changes);\n\n\t\t\t\tif (relevantChanges.length) {\n\t\t\t\t\tif (currentObservable.options.async) {\n\t\t\t\t\t\t//\tthis is the async dispatch handling\n\t\t\t\t\t\tif (!currentObservable.batches) {\n\t\t\t\t\t\t\tcurrentObservable.batches = [];\n\t\t\t\t\t\t\tqueueMicrotask(callObserversFromMT.bind(currentObservable));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlet rb = currentObservable.batches.find(b => b[0] === target);\n\t\t\t\t\t\tif (!rb) {\n\t\t\t\t\t\t\trb = [target, []];\n\t\t\t\t\t\t\tcurrentObservable.batches.push(rb);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tArray.prototype.push.apply(rb[1], relevantChanges);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//\tthis is the naive straight forward synchronous dispatch\n\t\t\t\t\t\tcallObserverSafe(target, relevantChanges);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet tmpa;\n\t\t\tif (currentObservable.parent) {\n\t\t\t\ttmpa = new Array(l);\n\t\t\t\tfor (let i = 0; i < l; i++) {\n\t\t\t\t\ttmp = changes[i];\n\t\t\t\t\tnewPath = [currentObservable.ownKey, ...tmp.path];\n\t\t\t\t\ttmpa[i] = {\n\t\t\t\t\t\ttype: tmp.type,\n\t\t\t\t\t\tpath: newPath,\n\t\t\t\t\t\tvalue: tmp.value,\n\t\t\t\t\t\toldValue: tmp.oldValue,\n\t\t\t\t\t\tobject: tmp.object\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tchanges = tmpa;\n\t\t\t\tcurrentObservable = currentObservable.parent;\n\t\t\t} else {\n\t\t\t\tcurrentObservable = null;\n\t\t\t}\n\t\t} while (currentObservable);\n\t},\n\tgetObservedOf = function getObservedOf(item, key, parent) {\n\t\tif (!item || typeof item !== 'object') {\n\t\t\treturn item;\n\t\t} else if (Array.isArray(item)) {\n\t\t\treturn new ArrayOMeta({ target: item, ownKey: key, parent: parent }).proxy;\n\t\t} else if (ArrayBuffer.isView(item)) {\n\t\t\treturn new TypedArrayOMeta({ target: item, ownKey: key, parent: parent }).proxy;\n\t\t} else if (item instanceof Date || item instanceof Error) {\n\t\t\treturn item;\n\t\t} else {\n\t\t\treturn new ObjectOMeta({ target: item, ownKey: key, parent: parent }).proxy;\n\t\t}\n\t},\n\tproxiedPop = function proxiedPop() {\n\t\tconst oMeta = this[oMetaKey],\n\t\t\ttarget = oMeta.target,\n\t\t\tpoppedIndex = target.length - 1;\n\n\t\tlet popResult = target.pop();\n\t\tif (popResult && typeof popResult === 'object') {\n\t\t\tconst tmpObserved = popResult[oMetaKey];\n\t\t\tif (tmpObserved) {\n\t\t\t\tpopResult = tmpObserved.detach();\n\t\t\t}\n\t\t}\n\n\t\tconst changes = [{ type: DELETE, path: [poppedIndex], oldValue: popResult, object: this }];\n\t\tcallObservers(oMeta, changes);\n\n\t\treturn popResult;\n\t},\n\tproxiedPush = function proxiedPush() {\n\t\tconst\n\t\t\toMeta = this[oMetaKey],\n\t\t\ttarget = oMeta.target,\n\t\t\tl = arguments.length,\n\t\t\tpushContent = new Array(l),\n\t\t\tinitialLength = target.length;\n\n\t\tfor (let i = 0; i < l; i++) {\n\t\t\tpushContent[i] = getObservedOf(arguments[i], initialLength + i, oMeta);\n\t\t}\n\t\tconst pushResult = Reflect.apply(target.push, target, pushContent);\n\n\t\tconst changes = [];\n\t\tfor (let i = initialLength, l = target.length; i < l; i++) {\n\t\t\tchanges[i - initialLength] = { type: INSERT, path: [i], value: target[i], object: this };\n\t\t}\n\t\tcallObservers(oMeta, changes);\n\n\t\treturn pushResult;\n\t},\n\tproxiedShift = function proxiedShift() {\n\t\tconst\n\t\t\toMeta = this[oMetaKey],\n\t\t\ttarget = oMeta.target;\n\t\tlet shiftResult, i, l, item, tmpObserved;\n\n\t\tshiftResult = target.shift();\n\t\tif (shiftResult && typeof shiftResult === 'object') {\n\t\t\ttmpObserved = shiftResult[oMetaKey];\n\t\t\tif (tmpObserved) {\n\t\t\t\tshiftResult = tmpObserved.detach();\n\t\t\t}\n\t\t}\n\n\t\t//\tupdate indices of the remaining items\n\t\tfor (i = 0, l = target.length; i < l; i++) {\n\t\t\titem = target[i];\n\t\t\tif (item && typeof item === 'object') {\n\t\t\t\ttmpObserved = item[oMetaKey];\n\t\t\t\tif (tmpObserved) {\n\t\t\t\t\ttmpObserved.ownKey = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst changes = [{ type: DELETE, path: [0], oldValue: shiftResult, object: this }];\n\t\tcallObservers(oMeta, changes);\n\n\t\treturn shiftResult;\n\t},\n\tproxiedUnshift = function proxiedUnshift() {\n\t\tconst\n\t\t\toMeta = this[oMetaKey],\n\t\t\ttarget = oMeta.target,\n\t\t\tal = arguments.length,\n\t\t\tunshiftContent = new Array(al);\n\n\t\tfor (let i = 0; i < al; i++) {\n\t\t\tunshiftContent[i] = getObservedOf(arguments[i], i, oMeta);\n\t\t}\n\t\tconst unshiftResult = Reflect.apply(target.unshift, target, unshiftContent);\n\n\t\tfor (let i = 0, l = target.length, item; i < l; i++) {\n\t\t\titem = target[i];\n\t\t\tif (item && typeof item === 'object') {\n\t\t\t\tconst tmpObserved = item[oMetaKey];\n\t\t\t\tif (tmpObserved) {\n\t\t\t\t\ttmpObserved.ownKey = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//\tpublish changes\n\t\tconst l = unshiftContent.length;\n\t\tconst changes = new Array(l);\n\t\tfor (let i = 0; i < l; i++) {\n\t\t\tchanges[i] = { type: INSERT, path: [i], value: target[i], object: this };\n\t\t}\n\t\tcallObservers(oMeta, changes);\n\n\t\treturn unshiftResult;\n\t},\n\tproxiedReverse = function proxiedReverse() {\n\t\tconst\n\t\t\toMeta = this[oMetaKey],\n\t\t\ttarget = oMeta.target;\n\t\tlet i, l, item;\n\n\t\ttarget.reverse();\n\t\tfor (i = 0, l = target.length; i < l; i++) {\n\t\t\titem = target[i];\n\t\t\tif (item && typeof item === 'object') {\n\t\t\t\tconst tmpObserved = item[oMetaKey];\n\t\t\t\tif (tmpObserved) {\n\t\t\t\t\ttmpObserved.ownKey = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst changes = [{ type: REVERSE, path: [], object: this }];\n\t\tcallObservers(oMeta, changes);\n\n\t\treturn this;\n\t},\n\tproxiedSort = function proxiedSort(comparator) {\n\t\tconst\n\t\t\toMeta = this[oMetaKey],\n\t\t\ttarget = oMeta.target;\n\t\tlet i, l, item;\n\n\t\ttarget.sort(comparator);\n\t\tfor (i = 0, l = target.length; i < l; i++) {\n\t\t\titem = target[i];\n\t\t\tif (item && typeof item === 'object') {\n\t\t\t\tconst tmpObserved = item[oMetaKey];\n\t\t\t\tif (tmpObserved) {\n\t\t\t\t\ttmpObserved.ownKey = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst changes = [{ type: SHUFFLE, path: [], object: this }];\n\t\tcallObservers(oMeta, changes);\n\n\t\treturn this;\n\t},\n\tproxiedFill = function proxiedFill(filVal, start, end) {\n\t\tconst\n\t\t\toMeta = this[oMetaKey],\n\t\t\ttarget = oMeta.target,\n\t\t\tchanges = [],\n\t\t\ttarLen = target.length,\n\t\t\tprev = target.slice(0);\n\t\tstart = start === undefined ? 0 : (start < 0 ? Math.max(tarLen + start, 0) : Math.min(start, tarLen));\n\t\tend = end === undefined ? tarLen : (end < 0 ? Math.max(tarLen + end, 0) : Math.min(end, tarLen));\n\n\t\tif (start < tarLen && end > start) {\n\t\t\ttarget.fill(filVal, start, end);\n\n\t\t\tlet tmpObserved;\n\t\t\tfor (let i = start, item, tmpTarget; i < end; i++) {\n\t\t\t\titem = target[i];\n\t\t\t\ttarget[i] = getObservedOf(item, i, oMeta);\n\t\t\t\tif (prev.hasOwnProperty(i)) {\n\t\t\t\t\ttmpTarget = prev[i];\n\t\t\t\t\tif (tmpTarget && typeof tmpTarget === 'object') {\n\t\t\t\t\t\ttmpObserved = tmpTarget[oMetaKey];\n\t\t\t\t\t\tif (tmpObserved) {\n\t\t\t\t\t\t\ttmpTarget = tmpObserved.detach();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tchanges.push({ type: UPDATE, path: [i], value: target[i], oldValue: tmpTarget, object: this });\n\t\t\t\t} else {\n\t\t\t\t\tchanges.push({ type: INSERT, path: [i], value: target[i], object: this });\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcallObservers(oMeta, changes);\n\t\t}\n\n\t\treturn this;\n\t},\n\tproxiedCopyWithin = function proxiedCopyWithin(dest, start, end) {\n\t\tconst\n\t\t\toMeta = this[oMetaKey],\n\t\t\ttarget = oMeta.target,\n\t\t\ttarLen = target.length;\n\t\tdest = dest < 0 ? Math.max(tarLen + dest, 0) : dest;\n\t\tstart = start === undefined ? 0 : (start < 0 ? Math.max(tarLen + start, 0) : Math.min(start, tarLen));\n\t\tend = end === undefined ? tarLen : (end < 0 ? Math.max(tarLen + end, 0) : Math.min(end, tarLen));\n\t\tconst len = Math.min(end - start, tarLen - dest);\n\n\t\tif (dest < tarLen && dest !== start && len > 0) {\n\t\t\tconst\n\t\t\t\tprev = target.slice(0),\n\t\t\t\tchanges = [];\n\n\t\t\ttarget.copyWithin(dest, start, end);\n\n\t\t\tfor (let i = dest, nItem, oItem, tmpObserved; i < dest + len; i++) {\n\t\t\t\t//\tupdate newly placed observables, if any\n\t\t\t\tnItem = target[i];\n\t\t\t\tif (nItem && typeof nItem === 'object') {\n\t\t\t\t\tnItem = getObservedOf(nItem, i, oMeta);\n\t\t\t\t\ttarget[i] = nItem;\n\t\t\t\t}\n\n\t\t\t\t//\tdetach overridden observables, if any\n\t\t\t\toItem = prev[i];\n\t\t\t\tif (oItem && typeof oItem === 'object') {\n\t\t\t\t\ttmpObserved = oItem[oMetaKey];\n\t\t\t\t\tif (tmpObserved) {\n\t\t\t\t\t\toItem = tmpObserved.detach();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (typeof nItem !== 'object' && nItem === oItem) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tchanges.push({ type: UPDATE, path: [i], value: nItem, oldValue: oItem, object: this });\n\t\t\t}\n\n\t\t\tcallObservers(oMeta, changes);\n\t\t}\n\n\t\treturn this;\n\t},\n\tproxiedSplice = function proxiedSplice() {\n\t\tconst\n\t\t\toMeta = this[oMetaKey],\n\t\t\ttarget = oMeta.target,\n\t\t\tsplLen = arguments.length,\n\t\t\tspliceContent = new Array(splLen),\n\t\t\ttarLen = target.length;\n\n\t\t//\tobservify the newcomers\n\t\tfor (let i = 0; i < splLen; i++) {\n\t\t\tspliceContent[i] = getObservedOf(arguments[i], i, oMeta);\n\t\t}\n\n\t\t//\tcalculate pointers\n\t\tconst\n\t\t\tstartIndex = splLen === 0 ? 0 : (spliceContent[0] < 0 ? tarLen + spliceContent[0] : spliceContent[0]),\n\t\t\tremoved = splLen < 2 ? tarLen - startIndex : spliceContent[1],\n\t\t\tinserted = Math.max(splLen - 2, 0),\n\t\t\tspliceResult = Reflect.apply(target.splice, target, spliceContent),\n\t\t\tnewTarLen = target.length;\n\n\t\t//\treindex the paths\n\t\tlet tmpObserved;\n\t\tfor (let i = 0, item; i < newTarLen; i++) {\n\t\t\titem = target[i];\n\t\t\tif (item && typeof item === 'object') {\n\t\t\t\ttmpObserved = item[oMetaKey];\n\t\t\t\tif (tmpObserved) {\n\t\t\t\t\ttmpObserved.ownKey = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//\tdetach removed objects\n\t\tlet i, l, item;\n\t\tfor (i = 0, l = spliceResult.length; i < l; i++) {\n\t\t\titem = spliceResult[i];\n\t\t\tif (item && typeof item === 'object') {\n\t\t\t\ttmpObserved = item[oMetaKey];\n\t\t\t\tif (tmpObserved) {\n\t\t\t\t\tspliceResult[i] = tmpObserved.detach();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst changes = [];\n\t\tlet index;\n\t\tfor (index = 0; index < removed; index++) {\n\t\t\tif (index < inserted) {\n\t\t\t\tchanges.push({ type: UPDATE, path: [startIndex + index], value: target[startIndex + index], oldValue: spliceResult[index], object: this });\n\t\t\t} else {\n\t\t\t\tchanges.push({ type: DELETE, path: [startIndex + index], oldValue: spliceResult[index], object: this });\n\t\t\t}\n\t\t}\n\t\tfor (; index < inserted; index++) {\n\t\t\tchanges.push({ type: INSERT, path: [startIndex + index], value: target[startIndex + index], object: this });\n\t\t}\n\t\tcallObservers(oMeta, changes);\n\n\t\treturn spliceResult;\n\t},\n\tproxiedTypedArraySet = function proxiedTypedArraySet(source, offset) {\n\t\tconst\n\t\t\toMeta = this[oMetaKey],\n\t\t\ttarget = oMeta.target,\n\t\t\tsouLen = source.length,\n\t\t\tprev = target.slice(0);\n\t\toffset = offset || 0;\n\n\t\ttarget.set(source, offset);\n\t\tconst changes = new Array(souLen);\n\t\tfor (let i = offset; i < (souLen + offset); i++) {\n\t\t\tchanges[i - offset] = { type: UPDATE, path: [i], value: target[i], oldValue: prev[i], object: this };\n\t\t}\n\n\t\tcallObservers(oMeta, changes);\n\t},\n\tproxiedArrayMethods = {\n\t\tpop: proxiedPop,\n\t\tpush: proxiedPush,\n\t\tshift: proxiedShift,\n\t\tunshift: proxiedUnshift,\n\t\treverse: proxiedReverse,\n\t\tsort: proxiedSort,\n\t\tfill: proxiedFill,\n\t\tcopyWithin: proxiedCopyWithin,\n\t\tsplice: proxiedSplice\n\t},\n\tproxiedTypedArrayMethods = {\n\t\treverse: proxiedReverse,\n\t\tsort: proxiedSort,\n\t\tfill: proxiedFill,\n\t\tcopyWithin: proxiedCopyWithin,\n\t\tset: proxiedTypedArraySet\n\t};\n\nclass OMetaBase {\n\tconstructor(properties, cloningFunction) {\n\t\tconst { target, parent, ownKey } = properties;\n\t\tif (parent && ownKey !== undefined) {\n\t\t\tthis.parent = parent;\n\t\t\tthis.ownKey = ownKey;\n\t\t} else {\n\t\t\tthis.parent = null;\n\t\t\tthis.ownKey = null;\n\t\t}\n\t\tconst targetClone = cloningFunction(target, this);\n\t\tthis.observers = [];\n\t\tthis.revocable = Proxy.revocable(targetClone, this);\n\t\tthis.proxy = this.revocable.proxy;\n\t\tthis.target = targetClone;\n\t\tthis.options = this.processOptions(properties.options);\n\t}\n\n\tprocessOptions(options) {\n\t\tif (options) {\n\t\t\tif (typeof options !== 'object') {\n\t\t\t\tthrow new Error(`Observable options if/when provided, MAY only be an object, got '${options}'`);\n\t\t\t}\n\t\t\tconst invalidOptions = Object.keys(options).filter(option => !validObservableOptionKeys.hasOwnProperty(option));\n\t\t\tif (invalidOptions.length) {\n\t\t\t\tthrow new Error(`'${invalidOptions.join(', ')}' is/are not a valid Observable option/s`);\n\t\t\t}\n\t\t\treturn Object.assign({}, options);\n\t\t} else {\n\t\t\treturn {};\n\t\t}\n\t}\n\n\tdetach() {\n\t\tthis.parent = null;\n\t\treturn this.target;\n\t}\n\n\tset(target, key, value) {\n\t\tlet oldValue = target[key];\n\n\t\tif (value !== oldValue) {\n\t\t\tconst newValue = getObservedOf(value, key, this);\n\t\t\ttarget[key] = newValue;\n\n\t\t\tif (oldValue && typeof oldValue === 'object') {\n\t\t\t\tconst tmpObserved = oldValue[oMetaKey];\n\t\t\t\tif (tmpObserved) {\n\t\t\t\t\toldValue = tmpObserved.detach();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst changes = oldValue === undefined\n\t\t\t\t? [{ type: INSERT, path: [key], value: newValue, object: this.proxy }]\n\t\t\t\t: [{ type: UPDATE, path: [key], value: newValue, oldValue: oldValue, object: this.proxy }];\n\t\t\tcallObservers(this, changes);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tdeleteProperty(target, key) {\n\t\tlet oldValue = target[key];\n\n\t\tdelete target[key];\n\n\t\tif (oldValue && typeof oldValue === 'object') {\n\t\t\tconst tmpObserved = oldValue[oMetaKey];\n\t\t\tif (tmpObserved) {\n\t\t\t\toldValue = tmpObserved.detach();\n\t\t\t}\n\t\t}\n\n\t\tconst changes = [{ type: DELETE, path: [key], oldValue: oldValue, object: this.proxy }];\n\t\tcallObservers(this, changes);\n\n\t\treturn true;\n\t}\n}\n\nclass ObjectOMeta extends OMetaBase {\n\tconstructor(properties) {\n\t\tsuper(properties, prepareObject);\n\t}\n}\n\nclass ArrayOMeta extends OMetaBase {\n\tconstructor(properties) {\n\t\tsuper(properties, prepareArray);\n\t}\n\n\tget(target, key) {\n\t\tif (proxiedArrayMethods.hasOwnProperty(key)) {\n\t\t\treturn proxiedArrayMethods[key];\n\t\t} else {\n\t\t\treturn target[key];\n\t\t}\n\t}\n}\n\nclass TypedArrayOMeta extends OMetaBase {\n\tconstructor(properties) {\n\t\tsuper(properties, prepareTypedArray);\n\t}\n\n\tget(target, key) {\n\t\tif (proxiedTypedArrayMethods.hasOwnProperty(key)) {\n\t\t\treturn proxiedTypedArrayMethods[key];\n\t\t} else {\n\t\t\treturn target[key];\n\t\t}\n\t}\n}\n\nclass Observable {\n\tconstructor() {\n\t\tthrow new Error('Observable MAY NOT be created via constructor, see \"Observable.from\" API');\n\t}\n\n\tstatic from(target, options) {\n\t\tif (!target || typeof target !== 'object') {\n\t\t\tthrow new Error('observable MAY ONLY be created from a non-null object');\n\t\t} else if (target[oMetaKey]) {\n\t\t\treturn target;\n\t\t} else if (Array.isArray(target)) {\n\t\t\treturn new ArrayOMeta({ target: target, ownKey: null, parent: null, options: options }).proxy;\n\t\t} else if (ArrayBuffer.isView(target)) {\n\t\t\treturn new TypedArrayOMeta({ target: target, ownKey: null, parent: null, options: options }).proxy;\n\t\t} else if (target instanceof Date || target instanceof Error) {\n\t\t\tthrow new Error(`${target} found to be one of a on-observable types`);\n\t\t} else {\n\t\t\treturn new ObjectOMeta({ target: target, ownKey: null, parent: null, options: options }).proxy;\n\t\t}\n\t}\n\n\tstatic isObservable(input) {\n\t\treturn !!(input && input[oMetaKey]);\n\t}\n}\n\nObject.freeze(Observable);\n\nexport { Observable };","import _g from \"./g\";\nimport { Globals } from \"./types\";\n\nexport default function utilsFactory(globals?: Globals): any {\n    const g = globals || _g;\n\n    const generateBareUrl = (type: string, integrationID: string): string => `https://api.easybase.io/${type}/${integrationID}`;\n\n    const generateAuthBody = (): any => {\n        const stamp = Date.now();\n        return {\n            token: g.token,\n            token_time: ~~(g.session / (stamp % 64)),\n            now: stamp\n        }\n    }\n    \n    function log(...params: any): void {\n        if (g.options.logging) {\n            console.log(\"EASYBASE — \", ...params);\n        }\n    }\n\n    return {\n        generateAuthBody,\n        generateBareUrl,\n        log\n    }\n}\n","import { POST_TYPES, AuthPostResponse, Globals, StatusResponse } from \"./types\";\nimport _g from \"./g\";\nimport utilsFactory from \"./utils\";\nimport fetch from 'cross-fetch';\n\nexport default function authFactory(globals?: Globals): any {\n    const g = globals || _g;\n\n    const { generateBareUrl, generateAuthBody, log } = utilsFactory(g);\n\n    const getUserAttributes = async (): Promise<Record<string, string>> => {\n        try {\n            const attrsRes = await tokenPost(POST_TYPES.USER_ATTRIBUTES);\n            return attrsRes.data;   \n        } catch (error) {\n            return error;\n        }\n    }\n\n    const setUserAttribute = async (key: string, value: string): Promise<StatusResponse> => {\n        try {\n            const setAttrsRes = await tokenPost(POST_TYPES.SET_ATTRIBUTE, {\n                key,\n                value\n            });\n\n            return {\n                success: setAttrsRes.success,\n                message: JSON.stringify(setAttrsRes.data)\n            };\n        } catch (error) {\n            return {\n                success: false,\n                message: \"Error\",\n                error\n            };\n        }\n    }\n\n    const signUp = async (newUserID: string, password: string, userAttributes?: Record<string, string>): Promise<StatusResponse> => {\n        try {\n            const signUpRes = await tokenPost(POST_TYPES.SIGN_UP, {\n                newUserID,\n                password,\n                userAttributes\n            });\n            return {\n                success: signUpRes.success,\n                message: signUpRes.data\n            }   \n        } catch (error) {\n            return {\n                success: false,\n                message: \"Error\",\n                error\n            }\n        }\n    }\n\n    const signIn = async (userID: string, password: string): Promise<StatusResponse> => {\n        const t1 = Date.now();\n        g.session = Math.floor(100000000 + Math.random() * 900000000);\n    \n        const integrationType = g.ebconfig.integration.split(\"-\")[0].toUpperCase() === \"PROJECT\" ? \"PROJECT\" : \"REACT\";\n\n        try {\n            const res = await fetch(generateBareUrl(integrationType, g.integrationID), {\n                method: \"POST\",\n                headers: {\n                    'Eb-Post-Req': POST_TYPES.HANDSHAKE,\n                    'Accept': 'application/json',\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                    version: g.ebconfig.version,\n                    session: g.session,\n                    instance: g.instance,\n                    userID,\n                    password\n                })\n            });\n\n            const resData = await res.json();\n    \n            if (resData.token) {\n                g.token = resData.token;\n                g.refreshToken = resData.refreshToken;\n                g.newTokenCallback();\n                g.mounted = true;\n                const validTokenRes = await tokenPost(POST_TYPES.VALID_TOKEN);\n                const elapsed = Date.now() - t1;\n                if (validTokenRes.success) {\n                    log(\"Valid auth initiation in \" + elapsed + \"ms\");\n                    return {\n                        success: true,\n                        message: \"Successfully signed in user\"\n                    };\n                } else {\n                    return {\n                        success: false,\n                        message: \"Could not sign in user\"\n                    };\n                }\n            } else {\n                return {\n                    success: false,\n                    message: \"Could not sign in user\"\n                };\n            }\n        } catch (error) {\n            console.error(error);\n            return {\n                success: false,\n                message: error,\n                error\n            };\n        }\n    }\n\n    const resetUserPassword = async (newPassword: string): Promise<StatusResponse> => {\n        if (typeof newPassword !== \"string\" || newPassword.length < 100) {\n            return {\n                success: false,\n                message: \"newPassword must be of type string\"\n            };\n        }\n        \n        try {\n            const setAttrsRes = await tokenPost(POST_TYPES.RESET_PASSWORD, { newPassword });\n\n            return {\n                success: setAttrsRes.success,\n                message: JSON.stringify(setAttrsRes.data)\n            };\n        } catch (error) {\n            return {\n                success: false,\n                message: \"Error\",\n                error\n            };\n        }\n    }\n    \n    const isUserSignedIn = (): boolean => g.token.length > 0;\n\n    const signOut = (): void => {\n        g.token = \"\";\n        g.newTokenCallback();\n    }\n\n    const initAuth = async (): Promise<boolean> => {\n        const t1 = Date.now();\n        g.session = Math.floor(100000000 + Math.random() * 900000000);\n    \n        log(`Handshaking on${g.instance} instance`);\n    \n        const integrationType = g.ebconfig.integration.split(\"-\")[0].toUpperCase() === \"PROJECT\" ? \"PROJECT\" : \"REACT\";\n\n        try {\n\n            const res = await fetch(generateBareUrl(integrationType, g.integrationID), {\n                method: \"POST\",\n                headers: {\n                    'Eb-Post-Req': POST_TYPES.HANDSHAKE,\n                    'Accept': 'application/json',\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                    version: g.ebconfig.version,\n                    tt: g.ebconfig.tt,\n                    session: g.session,\n                    instance: g.instance\n                })\n            });\n\n            const resData = await res.json();\n    \n            if (resData.token) {\n                g.token = resData.token;\n                g.mounted = true;\n                const validTokenRes = await tokenPost(POST_TYPES.VALID_TOKEN);\n                const elapsed = Date.now() - t1;\n                if (validTokenRes.success) {\n                    log(\"Valid auth initiation in \" + elapsed + \"ms\");\n                    return true;\n                } else {\n                    return false;\n                }\n            } else {\n                return false;\n            }\n        } catch (error) {\n            console.error(error);\n            return false;\n        }\n    }\n    \n    const tokenPost = async (postType: POST_TYPES, body?: {}): Promise<AuthPostResponse> => {\n        if (!g.mounted) {\n            await initAuth();\n        }\n\n        const integrationType = g.ebconfig.integration.split(\"-\")[0].toUpperCase() === \"PROJECT\" ? \"PROJECT\" : \"REACT\";\n\n        try {\n            const res = await fetch(generateBareUrl(integrationType, g.integrationID), {\n                method: \"POST\",\n                headers: {\n                    'Eb-Post-Req': postType,\n                    'Accept': 'application/json',\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                    _auth: generateAuthBody(),\n                    ...body\n                })\n            });\n\n            const resData = await res.json();\n\n            if ({}.hasOwnProperty.call(resData, 'ErrorCode') || {}.hasOwnProperty.call(resData, 'code')) {\n                if (resData.code === \"JWT EXPIRED\") {\n                    if (integrationType === \"PROJECT\") {\n                        const req_res = await tokenPost(POST_TYPES.REQUEST_TOKEN, {\n                            refreshToken: g.refreshToken,\n                            token: g.token\n                        });\n\n                        if (req_res.success) {\n                            g.token = req_res.data.token\n                            g.newTokenCallback();\n                            return tokenPost(postType, body);\n                        } else {\n                            g.token = \"\";\n                            g.refreshToken = \"\";\n                            g.newTokenCallback();\n                            return {\n                                success: false,\n                                data: req_res.data\n                            }\n                        }\n                    } else {\n                        await initAuth();\n                    }\n                    return tokenPost(postType, body);\n                }\n    \n                return {\n                    success: false,\n                    data: resData.body\n                }\n            } else {\n                return {\n                    success: resData.success,\n                    data: resData.body\n                }\n            }\n        } catch (error) {\n            return {\n                success: false,\n                data: error\n            }\n        }\n    }\n    \n    const tokenPostAttachment = async (formData: FormData, customHeaders: {}): Promise<AuthPostResponse> => {\n\n        if (!g.mounted) {\n            await initAuth();\n        }\n\n        const regularAuthbody = generateAuthBody();\n    \n        const attachmentAuth = {\n            'Eb-token': regularAuthbody.token,\n            'Eb-token-time': regularAuthbody.token_time,\n            'Eb-now': regularAuthbody.now\n        };\n    \n        const integrationType = g.ebconfig.integration.split(\"-\")[0].toUpperCase() === \"PROJECT\" ? \"PROJECT\" : \"REACT\";\n\n        try {\n            const res = await fetch(generateBareUrl(integrationType, g.integrationID), {\n                method: \"POST\",\n                headers: {\n                    'Eb-Post-Req': POST_TYPES.UPLOAD_ATTACHMENT,\n                    ...customHeaders,\n                    ...attachmentAuth\n                },\n                body: formData\n            });\n\n            const resData = await res.json();\n\n            if ({}.hasOwnProperty.call(resData, 'ErrorCode') || {}.hasOwnProperty.call(resData, 'code')) {\n                if (resData.code === \"JWT EXPIRED\") {\n                    if (integrationType === \"PROJECT\") {\n                        const req_res = await tokenPost(POST_TYPES.REQUEST_TOKEN, {\n                            refreshToken: g.refreshToken,\n                            token: g.token\n                        });\n\n                        if (req_res.success) {\n                            g.token = req_res.data.token\n                            g.newTokenCallback();\n                            return tokenPostAttachment(formData, customHeaders);\n                        } else {\n                            g.token = \"\";\n                            g.refreshToken = \"\";\n                            g.newTokenCallback();\n                            return {\n                                success: false,\n                                data: req_res.data\n                            }\n                        }\n                    } else {\n                        await initAuth();\n                    }\n                    return tokenPostAttachment(formData, customHeaders);\n                }\n    \n                return {\n                    success: false,\n                    data: resData.body\n                }\n            } else {\n                return {\n                    success: resData.success,\n                    data: resData.body\n                }\n            }\n        } catch (error) {\n            return {\n                success: false,\n                data: error\n            }\n        }\n    }\n    \n    return {\n        initAuth,\n        tokenPost,\n        tokenPostAttachment,\n        signUp,\n        setUserAttribute,\n        getUserAttributes,\n        isUserSignedIn,\n        signIn,\n        signOut,\n        resetUserPassword\n    }\n}\n","import {\n    POST_TYPES,\n    QueryOptions,\n    Globals\n} from \"./types\";\nimport _g from \"./g\";\n\nimport authFactory from \"./auth\";\n\nexport default function tableFactory(globals?: Globals): any {\n\n    const g = globals || _g;\n\n    const { tokenPost } = authFactory(g);\n\n    const Query = async (options: QueryOptions): Promise<Record<string, any>[]> => {\n        const defaultOptions: QueryOptions = {\n            queryName: \"\"\n        }\n    \n        const fullOptions: QueryOptions = { ...defaultOptions, ...options };\n    \n        try {\n            const res = await tokenPost(POST_TYPES.GET_QUERY, fullOptions);\n            return res.data\n        } catch (error) {\n            return [];\n        }\n    }\n\n    async function fullTableSize(): Promise<number>;\n    async function fullTableSize(tableName: string): Promise<number>;\n    async function fullTableSize(tableName?: string): Promise<number> {\n        const res = await tokenPost(POST_TYPES.TABLE_SIZE, tableName ? { tableName } : {});\n        if (res.success) {\n            return res.data;\n        } else {\n            return 0;\n        }\n    }\n\n    async function tableTypes(): Promise<Record<string, any>>;\n    async function tableTypes(tableName: string): Promise<Record<string, any>>\n    async function tableTypes(tableName?: string): Promise<Record<string, any>> {\n        const res = await tokenPost(POST_TYPES.COLUMN_TYPES, tableName ? { tableName } : {});\n        if (res.success) {\n            return res.data;\n        } else {\n            return {};\n        }\n    }\n\n    return {\n        Query,\n        fullTableSize,\n        tableTypes\n    };\n}","import _g from \"./g\";\nimport easyqb from 'EasyQB';\nimport { SQW } from \"EasyQB/types/sq\";\nimport { NewExpression } from \"EasyQB/types/expression\";\nimport authFactory from \"./auth\";\nimport { POST_TYPES, DB_STATUS, Globals, EXECUTE_COUNT } from \"./types\";\n\ninterface IdbFactory {\n    db: (tableName?: string, userAssociatedRecordsOnly?: boolean) => SQW;\n    dbEventListener: (callback: (status?: DB_STATUS, queryType?: string, executeCount?: EXECUTE_COUNT, tableName?: string | null, returned?: any) => void) => () => void;\n    e: NewExpression;\n}\n\nexport default function dbFactory(globals?: Globals): IdbFactory {\n    const g = globals || _g;\n    const { tokenPost } = authFactory(g);\n    let _listenerIndex = 0;\n\n    const _listeners: Record<string, (status?: DB_STATUS, queryType?: string, executeCount?: EXECUTE_COUNT, tableName?: string | null, returned?: any) => void> = {};\n\n    function _runListeners(...params: any[]) {\n        for (const cb of Object.values(_listeners)) {\n            cb(...params)\n        }\n    }\n\n    const dbEventListener = (callback: (status?: DB_STATUS, queryType?: string, executeCount?: EXECUTE_COUNT, tableName?: string | null, returned?: any) => void): () => void => {\n        const currKey = '' + _listenerIndex++;\n        _listeners[currKey] = callback;\n        return () => {\n            delete _listeners[currKey]\n        }\n    }\n\n    const allCallback = async (trx: any, tableName: string, userAssociatedRecordsOnly?: boolean): Promise<Record<string, any>[] | number[]> => {\n        trx.count = \"all\";\n        trx.tableName = tableName;\n        if (userAssociatedRecordsOnly) trx.userAssociatedRecordsOnly = userAssociatedRecordsOnly;\n        _runListeners(DB_STATUS.PENDING, trx.type, EXECUTE_COUNT.ALL, tableName !== \"untable\" ? tableName : null);\n        const res = await tokenPost(POST_TYPES.EASY_QB, trx);\n        if (res.success) {\n            _runListeners(DB_STATUS.SUCCESS, trx.type, EXECUTE_COUNT.ALL, tableName !== \"untable\" ? tableName : null, res.data);\n            return res.data;\n        } else {\n            _runListeners(DB_STATUS.ERROR, trx.type, EXECUTE_COUNT.ALL, tableName !== \"untable\" ? tableName : null);\n            return res;\n        }\n    }\n\n    const oneCallback = async (trx: any, tableName: string, userAssociatedRecordsOnly?: boolean): Promise<Record<string, any> | number> => {\n        trx.count = \"one\";\n        trx.tableName = tableName;\n        if (userAssociatedRecordsOnly) trx.userAssociatedRecordsOnly = userAssociatedRecordsOnly;\n        _runListeners(DB_STATUS.PENDING, trx.type, EXECUTE_COUNT.ONE, tableName !== \"untable\" ? tableName : null);\n        const res = await tokenPost(POST_TYPES.EASY_QB, trx);\n        if (res.success) {\n            _runListeners(DB_STATUS.SUCCESS, trx.type, EXECUTE_COUNT.ONE, tableName !== \"untable\" ? tableName : null, res.data);\n            return res.data;\n        } else {\n            _runListeners(DB_STATUS.ERROR, trx.type, EXECUTE_COUNT.ONE, tableName !== \"untable\" ? tableName : null);\n            return res;\n        }\n    }\n\n    const db = (tableName?: string, userAssociatedRecordsOnly?: boolean) => {\n        if (tableName && typeof tableName === \"string\") {\n            return easyqb({ allCallback, oneCallback, userAssociatedRecordsOnly, tableName: tableName.toUpperCase() })(tableName.replace(/[^0-9a-zA-Z]/g, '_').toUpperCase());\n        } else {\n            return easyqb({ allCallback, oneCallback, userAssociatedRecordsOnly, tableName: \"untable\" })(\"untable\");\n        }\n    }\n    \n    return {\n        db,\n        dbEventListener,\n        e: easyqb().e\n    }\n}\n","import {\n    EasybaseProviderProps,\n    FrameConfiguration,\n    POST_TYPES,\n    FileFromURI,\n    ContextValue,\n    AddRecordOptions,\n    StatusResponse,\n    ConfigureFrameOptions,\n    UpdateRecordAttachmentOptions,\n    DeleteRecordOptions\n} from \"./types\";\nimport { gFactory } from \"./g\";\nimport deepEqual from \"fast-deep-equal\";\nimport { Observable } from \"./object-observer\";\nimport imageExtensions from \"./assets/image-extensions.json\";\nimport videoExtensions from \"./assets/video-extensions.json\";\nimport authFactory from \"./auth\";\nimport utilsFactory from \"./utils\";\nimport tableFactory from \"./table\";\nimport dbFactory from './db';\n\nexport default function EasybaseProvider({ ebconfig, options }: EasybaseProviderProps): ContextValue {\n\n    const g = gFactory();\n\n    const {\n        tokenPost,\n        tokenPostAttachment,\n        signUp,\n        setUserAttribute,\n        getUserAttributes,\n        isUserSignedIn,\n        signIn,\n        signOut,\n        resetUserPassword\n    } = authFactory(g);\n\n    const {\n        Query,\n        fullTableSize,\n        tableTypes\n    } = tableFactory(g);\n\n    const {\n        db,\n        dbEventListener,\n        e\n    } = dbFactory(g);\n\n    const { log } = utilsFactory(g);\n\n    if (typeof ebconfig !== 'object' || ebconfig === null || ebconfig === undefined) {\n        console.error(\"No ebconfig object passed. do `import ebconfig from \\\"ebconfig.js\\\"` and pass it to the Easybase provider\");\n        return;\n    } else if (!ebconfig.integration) {\n        console.error(\"Invalid ebconfig object passed. Download ebconfig.js from Easybase.io and try again.\");\n        return;\n    }\n\n    // eslint-disable-next-line dot-notation\n    const isIE = typeof document !== 'undefined' && !!document['documentMode'];\n\n    if (isIE) {\n        console.error(\"EASYBASE — easybasejs does not support Internet Explorer. Please use a different browser.\");\n    }\n\n    g.options = { ...options };\n    g.integrationID = ebconfig.integration;\n    g.ebconfig = ebconfig;\n    if (g.ebconfig.tt && g.ebconfig.integration.split(\"-\")[0].toUpperCase() !== \"PROJECT\") {\n        g.mounted = false;\n    } else {\n        g.mounted = true;\n    }\n    g.instance = \"Node\";\n\n    let _isFrameInitialized = true;\n    let _frameConfiguration: FrameConfiguration = {\n        offset: 0,\n        limit: 0\n    };\n    const _observedChangeStack: Record<string, any>[] = [];\n    let _recordIdMap: WeakMap<Record<string, any>, \"string\"> = new WeakMap();\n    let _observableFrame = {\n        observe: (_) => { },\n        unobserve: () => { }\n    }\n    let _frame: Record<string, any>[] = [];\n\n    let isSyncing = false;\n\n    function Frame(): Record<string, any>[];\n    function Frame(index: number): Record<string, any>;\n    function Frame(index?: number): Record<string, any>[] | Record<string, any> {\n        if (typeof index === \"number\") {\n            return _observableFrame[index];\n        } else {\n            return _observableFrame;\n        }\n    }\n\n    const _recordIDExists = (record: Record<string, any>): Boolean => !!_recordIdMap.get(record);\n\n    const configureFrame = (options: ConfigureFrameOptions): StatusResponse => {\n        _frameConfiguration = { ..._frameConfiguration };\n\n        if (options.limit !== undefined) _frameConfiguration.limit = options.limit;\n        if (options.offset !== undefined && options.offset >= 0) _frameConfiguration.offset = options.offset;\n        if (options.tableName !== undefined) _frameConfiguration.tableName = options.tableName;\n\n        _isFrameInitialized = false;\n        return {\n            message: \"Successfully configured frame. Run sync() for changes to be shown in frame\",\n            success: true\n        }\n    }\n\n    const currentConfiguration = (): FrameConfiguration => ({ ..._frameConfiguration });\n\n    const deleteRecord = async (options: DeleteRecordOptions): Promise<StatusResponse> => {\n        const _frameRecord = _frame.find(ele => deepEqual(ele, options.record));\n\n        if (_frameRecord && _recordIdMap.get(_frameRecord)) {\n            const res = await tokenPost(POST_TYPES.SYNC_DELETE, {\n                _id: _recordIdMap.get(_frameRecord),\n                tableName: options.tableName\n            });\n            return {\n                success: res.success,\n                message: res.data\n            }\n        } else {\n            try {\n                const res = await tokenPost(POST_TYPES.SYNC_DELETE, {\n                    record: options.record,\n                    tableName: options.tableName\n                });\n                return {\n                    success: res.success,\n                    message: res.data\n                }\n            } catch (err) {\n                console.error(\"Easybase Error: deleteRecord failed \", err);\n                return {\n                    success: false,\n                    message: \"Easybase Error: deleteRecord failed \" + err,\n                    error: err\n                }\n            }\n        }\n    }\n\n    const addRecord = async (options: AddRecordOptions): Promise<StatusResponse> => {\n        const defaultValues: AddRecordOptions = {\n            insertAtEnd: false,\n            newRecord: {},\n            tableName: undefined\n        }\n\n        const fullOptions: AddRecordOptions = { ...defaultValues, ...options };\n\n        try {\n            const res = await tokenPost(POST_TYPES.SYNC_INSERT, fullOptions);\n            return {\n                message: res.data,\n                success: res.success\n            }\n        } catch (err) {\n            console.error(\"Easybase Error: addRecord failed \", err);\n            return {\n                message: \"Easybase Error: addRecord failed \" + err,\n                success: false,\n                error: err\n            }\n        }\n    }\n\n    // Only allow the deletion of one element at a time\n    // First handle shifting of the array size. Then iterate\n    const sync = async (): Promise<StatusResponse> => {\n        const _realignFrames = (newData: Record<string, any>[]) => {\n            let isNewDataTheSame = true;\n\n            if (newData.length !== _frame.length) {\n                isNewDataTheSame = false;\n            } else {\n                for (let i = 0; i < newData.length; i++) {\n                    const newDataNoId = { ...newData[i] };\n                    delete newDataNoId._id;\n                    if (!deepEqual(newDataNoId, _frame[i])) {\n                        isNewDataTheSame = false;\n                        break;\n                    }\n                }\n            }\n\n            if (!isNewDataTheSame) {\n                const oldframe = [..._frame];\n                oldframe.length = newData.length;\n                _recordIdMap = new WeakMap();\n                for (let i = 0; i < newData.length; i++) {\n                    const currNewEle = newData[i];\n                    _recordIdMap.set(currNewEle, currNewEle._id);\n                    delete currNewEle._id;\n                    oldframe[i] = currNewEle;\n                }\n                _frame = oldframe;\n                _observableFrame.unobserve();\n                _observableFrame = Observable.from(_frame);\n\n                _observableFrame.observe((allChanges: any[]) => {\n                    allChanges.forEach((change: any) => {\n                        _observedChangeStack.push({\n                            type: change.type,\n                            path: change.path,\n                            value: change.value,\n                            _id: _recordIdMap.get(_frame[Number(change.path[0])])\n                            // Not bringing change.object or change.oldValue\n                        });\n                        log(JSON.stringify({\n                            type: change.type,\n                            path: change.path,\n                            value: change.value,\n                            _id: _recordIdMap.get(_frame[Number(change.path[0])])\n                            // Not bringing change.object or change.oldValue\n                        }))\n                    });\n                });\n            }\n        }\n\n        if (isSyncing) {\n            return {\n                success: false,\n                message: \"Easybase Error: the provider is currently syncing, use 'await sync()' before calling sync() again\"\n            };\n        }\n\n        isSyncing = true;\n\n        if (_isFrameInitialized) {\n            if (_observedChangeStack.length > 0) {\n                log(\"Stack change: \", _observedChangeStack);\n                const res = await tokenPost(POST_TYPES.SYNC_STACK, {\n                    stack: _observedChangeStack,\n                    ..._frameConfiguration\n                });\n                if (res.success) {\n                    _observedChangeStack.length = 0;\n                }\n            }\n        }\n\n        try {\n            const res = await tokenPost(POST_TYPES.GET_FRAME, _frameConfiguration);\n\n            // Check if the array recieved from db is the same as frame\n            // If not, update it and send useFrameEffect\n\n            if (res.success === false) {\n                console.error(res.data);\n                isSyncing = false;\n                return {\n                    success: false,\n                    message: \"\" + res.data\n                }\n            } else {\n                _isFrameInitialized = true;\n                _realignFrames(res.data);\n                isSyncing = false;\n                return {\n                    message: 'Success. Call frame for data',\n                    success: true\n                }\n            }\n        } catch (err) {\n            console.error(\"Easybase Error: get failed \", err);\n            isSyncing = false;\n            return {\n                success: false,\n                message: \"Easybase Error: get failed \" + err,\n                error: err\n            }\n        }\n    }\n\n    const updateRecordImage = async (options: UpdateRecordAttachmentOptions): Promise<StatusResponse> => {\n        const res = await _updateRecordAttachment(options, \"image\");\n        return res;\n    }\n    const updateRecordVideo = async (options: UpdateRecordAttachmentOptions): Promise<StatusResponse> => {\n        const res = await _updateRecordAttachment(options, \"video\");\n        return res;\n    }\n    const updateRecordFile = async (options: UpdateRecordAttachmentOptions): Promise<StatusResponse> => {\n        const res = await _updateRecordAttachment(options, \"file\");\n        return res;\n    }\n\n    const _updateRecordAttachment = async (options: UpdateRecordAttachmentOptions, type: string): Promise<StatusResponse> => {\n        const _frameRecord: Record<string, any> | undefined = _frame.find(ele => deepEqual(ele, options.record));\n\n        if (_frameRecord === undefined || !_recordIDExists(_frameRecord)) {\n            log(\"Attempting to add attachment to a new record that has not been synced. Please sync() before trying to add attachment.\");\n            return {\n                success: false,\n                message: \"Attempting to add attachment to a new record that has not been synced. Please sync() before trying to add attachment.\"\n            }\n        }\n\n        const ext: string = options.attachment.name.split(\".\").pop()!.toLowerCase();\n\n        log(ext);\n\n        if (type === \"image\" && !imageExtensions.includes(ext)) {\n            return {\n                success: false,\n                message: \"Image files must have a proper image extension in the file name\"\n            };\n        }\n\n        if (type === \"video\" && !videoExtensions.includes(ext)) {\n            return {\n                success: false,\n                message: \"Video files must have a proper video extension in the file name\"\n            };\n        }\n\n        function isFileFromURI(f: File | FileFromURI): f is FileFromURI {\n            return (f as FileFromURI).uri !== undefined;\n        }\n\n        const formData = new FormData();\n\n        if (isFileFromURI(options.attachment)) {\n            formData.append(\"file\", options.attachment as any);\n            formData.append(\"name\", options.attachment.name);\n        } else {\n            formData.append(\"file\", options.attachment);\n            formData.append(\"name\", options.attachment.name);\n        }\n\n        const customHeaders = {\n            'Eb-upload-type': type,\n            'Eb-column-name': options.columnName,\n            'Eb-record-id': _recordIdMap.get(_frameRecord),\n            'Eb-table-name': options.tableName\n        }\n\n        const res = await tokenPostAttachment(formData, customHeaders);\n\n        await sync();\n\n        return {\n            message: res.data,\n            success: res.success\n        };\n    }\n\n    const c: ContextValue = {\n        /** +++ Will be deprecated */\n        configureFrame,\n        addRecord,\n        deleteRecord,\n        sync,\n        Frame,\n        currentConfiguration,\n        /** --- */\n        updateRecordImage,\n        updateRecordVideo,\n        updateRecordFile,\n        fullTableSize,\n        tableTypes,\n        Query,\n        isUserSignedIn,\n        signIn,\n        signOut,\n        signUp,\n        resetUserPassword,\n        setUserAttribute,\n        getUserAttributes,\n        db,\n        dbEventListener,\n        e\n    }\n\n    return c;\n}\n","import fetch from 'cross-fetch';\n\nexport { default as EasybaseProvider } from \"./EasybaseProvider/EasybaseProvider\";\n\nconst generateBareUrl = (type, integrationID) => `https://api.easybase.io/${type}/${integrationID}`;\nconst isBadInt = (my_int) => my_int !== undefined && my_int !== null && Math.floor(my_int) !== my_int;\nconst isBadString = (my_string) => my_string !== undefined && my_string !== null && typeof my_string !== \"string\";\nconst isBadIntegrationID = (my_string) => my_string === undefined || my_string === null || typeof my_string !== \"string\";\nconst isBadObject = (my_obj) => my_obj !== undefined && my_obj !== null && typeof my_obj !== \"object\";\nconst isBadBool = (my_bool) => my_bool !== undefined && my_bool !== null && typeof my_bool !== \"boolean\";\n\ninterface GetOptions {\n    /** EasyBase integration ID. Can be found by expanding the integration menu. This id is automatically generated.  */\n    integrationID: string;\n    /** Edit starting index from which records will be retrieved from. Useful for paging. */\n    offset?: number;\n    /** Limit the amount of records to be retrieved. Can be used in combination with offset. */\n    limit?: number;\n    /** Custom authentication string. Can be set in integration menu. If it is set, it is required to access integration. This acts as an extra layer of security and extensibility. */\n    authentication?: string;\n    /** This object can be set to overwrite the query values as set in the integration menu. If your query is setup to find records where 'age' >= 0, passing in { age: 50 } will query where 'age' >= 50. */\n    customQuery?: Record<string, unknown>;\n}\n\n/**\n * \n * @param {GetOptions} options GetOptions.\n * @returns {Promise<Array>} Array of records.\n * \n */\nexport function get(options: GetOptions): Promise<Array<Record<string, unknown>>> {\n\n    const defaultOptions: GetOptions = {\n        integrationID: \"\",\n        offset: undefined,\n        limit: undefined,\n        authentication: undefined,\n        customQuery: undefined\n    }\n    const { integrationID, offset, limit, authentication, customQuery } = { ...defaultOptions, ...options };\n\n    if (isBadIntegrationID(integrationID)) throw new Error(\"integrationID is required and must be a string\");\n    if (isBadInt(offset)) throw new Error(\"offset must be an integer\");\n    if (isBadInt(limit)) throw new Error(\"limit must be an integer\");\n    if (isBadString(authentication)) throw new Error(\"authentication must be a string or null\");\n    if (isBadObject(customQuery)) throw new Error(\"customQuery must be an object or null\");\n\n    return new Promise((resolve, reject) => {\n        try {\n            let fetch_body: any = {};\n            if (typeof customQuery === \"object\") fetch_body = { ...customQuery };\n            if (offset !== undefined) fetch_body.offset = offset;\n            if (limit !== undefined) fetch_body.limit = limit;\n            if (authentication !== undefined) fetch_body.authentication = authentication;\n\n            fetch(generateBareUrl('get', integrationID), {\n                method: \"POST\",\n                body: JSON.stringify(fetch_body),\n                headers: {\n                    'Accept': 'application/json',\n                    'Content-Type': 'application/json'\n                }\n            })\n                .then(res => res.json())\n                .then(resData => {\n                    if ({}.hasOwnProperty.call(resData, 'ErrorCode')) {\n                        console.error(resData.message);\n                        resolve([resData.message]);\n                    } else resolve(resData);\n                });\n        }\n        catch (err) { reject(err); }\n    });\n}\n\n\n\ninterface PostOptions {\n    /** EasyBase integration ID. Can be found by expanding the integration menu. This id is automatically generated.  */\n    integrationID: string;\n    /** Values to post to EasyBase collection. Format is { column name: value } */\n    newRecord: Record<string, unknown>;\n    /** Custom authentication string. Can be set in integration menu. If it is set, it is required to access integration. This acts as an extra layer of security and extensibility. */\n    authentication?: string;\n    /** If true, record will be inserted at the end of the collection rather than the front. */\n    insertAtEnd?: boolean;\n}\n\n/**\n * \n * @param {PostOptions} options PostOptions\n * @returns {Promise<String>} Post status.\n * \n */\nexport function post(options: PostOptions): Promise<string> {\n\n    const defaultValues: PostOptions = {\n        integrationID: \"\",\n        newRecord: undefined,\n        authentication: undefined,\n        insertAtEnd: undefined\n    }\n\n    const { integrationID, newRecord, authentication, insertAtEnd } = { ...defaultValues, ...options };\n\n    if (isBadIntegrationID(integrationID)) throw new Error(\"integrationID is required and must be a string\");\n    if (isBadObject(newRecord)) throw new Error(\"newRecord is required and must be a string\");\n    if (isBadString(authentication)) throw new Error(\"authentication must be a string or null\");\n    if (isBadBool(insertAtEnd)) throw new Error(\"insertAtEnd must be a boolean or null\");\n\n    return new Promise((resolve, reject) => {\n        try {\n            const fetch_body: any = { ...newRecord };\n            if (authentication !== undefined) fetch_body.authentication = authentication;\n            if (insertAtEnd !== undefined) fetch_body.insertAtEnd = insertAtEnd;\n\n            fetch(generateBareUrl('post', integrationID), {\n                method: \"POST\",\n                body: JSON.stringify(fetch_body),\n                headers: {\n                    'Accept': 'application/json',\n                    'Content-Type': 'application/json'\n                }\n            })\n                .then(res => res.json())\n                .then(resData => {\n                    if ({}.hasOwnProperty.call(resData, 'ErrorCode')) console.error(resData.message);\n                    resolve(resData);\n                });\n        }\n        catch (err) { reject(err); }\n    });\n}\n\n\ninterface UpdateOptions {\n    /** EasyBase integration ID. Can be found by expanding the integration menu. This id is automatically generated.  */\n    integrationID: string;\n    /** Values to update records with. Format is { column_name: new value } */\n    updateValues: Record<string, unknown>;\n    /** Custom authentication string. Can be set in integration menu. If it is set, it is required to access integration. This acts as an extra layer of security and extensibility. */\n    authentication?: string;\n    /** This object can be set to overwrite the query values as set in the integration menu. If your query is setup to find records where 'age' >= 0, passing in { age: 50 } will query where 'age' >= 50. */\n    customQuery?: Record<string, unknown>;\n}\n\n/**\n * \n * @param {UpdateOptions} options UpdateOptions\n * @returns {Promise<String>} Update status.\n */\nexport function update(options: UpdateOptions): Promise<string> {\n    const defaultValues: UpdateOptions = {\n        integrationID: \"\",\n        updateValues: undefined,\n        authentication: undefined,\n        customQuery: undefined\n    }\n\n    const { integrationID, updateValues, authentication, customQuery } = { ...defaultValues, ...options };\n\n    if (isBadIntegrationID(integrationID)) throw new Error(\"integrationID is required and must be a string\");\n    if (isBadObject(updateValues) || updateValues === undefined) throw new Error(\"updateValues is required and must be a string\");\n    if (isBadString(authentication)) throw new Error(\"authentication must be a string or null\");\n    if (isBadObject(customQuery)) throw new Error(\"customQuery must be an object or null\");\n\n    return new Promise((resolve, reject) => {\n        try {\n            const fetch_body: any = { updateValues, ...customQuery };\n            if (authentication !== undefined) fetch_body.authentication = authentication;\n\n            fetch(generateBareUrl('update', integrationID), {\n                method: \"POST\",\n                body: JSON.stringify(fetch_body),\n                headers: {\n                    'Accept': 'application/json',\n                    'Content-Type': 'application/json'\n                }\n            })\n                .then(res => res.json())\n                .then(resData => {\n                    if ({}.hasOwnProperty.call(resData, 'ErrorCode')) console.error(resData.message);\n                    resolve(resData.message);\n                });\n        }\n        catch (err) { reject(err); }\n    });\n}\n\ninterface DeleteOptions {\n    /** EasyBase integration ID. Can be found by expanding the integration menu. This id is automatically generated.  */\n    integrationID: string;\n    /** Custom authentication string. Can be set in integration menu. If it is set, it is required to access integration. This acts as an extra layer of security and extensibility. */\n    authentication?: string;\n    /** This object can be set to overwrite the query values as set in the integration menu. If your query is setup to find records where 'age' >= 0, passing in { age: 50 } will query where 'age' >= 50. */\n    customQuery?: Record<string, unknown>;\n}\n\n\n/**\n * \n * @param {DeleteOptions} options DeleteOptions\n * @return {Promise<String>} Delete status.\n */\nexport function Delete(options: DeleteOptions): Promise<string> {\n\n    const defaultValues: DeleteOptions = {\n        integrationID: \"\",\n        authentication: undefined,\n        customQuery: undefined\n    }\n\n    const { integrationID, authentication, customQuery } = { ...defaultValues, ...options };\n\n    if (isBadIntegrationID(integrationID)) throw new Error(\"integrationID is required and must be a string\");\n    if (isBadString(authentication)) throw new Error(\"authentication must be a string or null\");\n    if (isBadObject(customQuery)) throw new Error(\"customQuery must be an object or null\");\n\n    return new Promise((resolve, reject) => {\n        try {\n            const fetch_body: any = { ...customQuery };\n            if (authentication !== undefined) fetch_body.authentication = authentication;\n\n            fetch(generateBareUrl('delete', integrationID), {\n                method: \"POST\",\n                body: JSON.stringify(fetch_body),\n                headers: {\n                    'Accept': 'application/json',\n                    'Content-Type': 'application/json'\n                }\n            })\n                .then(res => res.json())\n                .then(resData => {\n                    if ({}.hasOwnProperty.call(resData, 'ErrorCode')) console.error(resData.message);\n                    resolve(resData.message);\n                });\n        }\n        catch (err) { reject(err); }\n    });\n}\n\n/**\n * @async\n * Call a cloud function, created in Easybase interface.\n * @param {string} route Route as detailed in Easybase. Found under 'Deploy'. Will be in the form of ####...####-function-name.\n * @param {Record<string, any>} postBody Optional object to pass as the body of the POST request. This object will available in your cloud function's event.body.\n * @return {Promise<string>} Response from your cloud function. Detailed with a call to 'return context.succeed(\"RESPONSE\")'.\n */\nexport async function callFunction(route: string, postBody?: Record<string, any>): Promise<string> {\n\n    const res = await fetch(generateBareUrl('function', route.split(\"/\").pop()), {\n        method: \"POST\",\n        headers: {\n            'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(postBody) || \"\"\n    });\n\n    const rawDataText = await res.text();\n    return rawDataText;\n}"]},"metadata":{},"sourceType":"module"}