{"ast":null,"code":"var _require = require('../../lib-util'),\n    isObject = _require.isObject,\n    buildCall = _require.buildCall,\n    mapJoin = _require.mapJoin,\n    objectMapJoin = _require.objectMapJoin;\n\nvar conditions = require('./conditions');\n\nvar valuesArray = require('./values_array');\n\nmodule.exports = function (ctx, items) {\n  var start = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var end = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : items.length;\n  if (end > items.length) end = items.length;\n  var txt = '';\n\n  for (var i = start; i < end; ++i) {\n    var item = items[i];\n    if (i !== start) txt += item.join;\n    txt += fromItem(ctx, item.args);\n    if (item.on) txt += \" on \".concat(conditions(ctx, item.on));else if (item.using) txt += \" using (\".concat(using(ctx, item.using), \")\");\n  }\n\n  return txt;\n};\n\nvar usingArg = function usingArg(ctx, arg) {\n  if (typeof arg === 'string') return arg;\n  if (typeof arg === 'function') return ctx.build(arg);\n  throw Error('Error: Invalid .using arg');\n};\n\nvar using = mapJoin(buildCall(mapJoin(usingArg)));\n\nvar fromArg = function fromArg(ctx, arg) {\n  if (typeof arg === 'string') return arg;\n  if (typeof arg === 'function') return ctx.build(arg);\n  if (isObject(arg)) return buildObject(ctx, arg);\n  throw Error('Error: Invalid .from argument:', arg);\n};\n\nvar buildProperty = function buildProperty(ctx, key, value) {\n  if (typeof value === 'string') return \"\".concat(value, \" \").concat(ctx.mapKey(key));\n  if (typeof value === 'function') return \"\".concat(ctx.build(value), \" \").concat(ctx.mapKey(key));\n\n  if (Array.isArray(value)) {\n    var _valuesArray = valuesArray(ctx, value),\n        columns = _valuesArray.columns,\n        values = _valuesArray.values;\n\n    return \"(\".concat(values, \") \").concat(ctx.mapKey(key), \"(\").concat(columns, \")\");\n  }\n\n  throw Error('Error: Invalid .from argument');\n};\n\nvar buildObject = objectMapJoin(buildProperty);\nvar fromItem = buildCall(mapJoin(fromArg));","map":{"version":3,"sources":["/Volumes/LaCie/Dev/myProjects/movie-nite/node_modules/EasyQB/src/lib-sq/common/from_items.js"],"names":["require","isObject","buildCall","mapJoin","objectMapJoin","conditions","valuesArray","module","exports","ctx","items","start","end","length","txt","i","item","join","fromItem","args","on","using","usingArg","arg","build","Error","fromArg","buildObject","buildProperty","key","value","mapKey","Array","isArray","columns","values"],"mappings":"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","sourcesContent":["const {\n  isObject,\n  buildCall,\n  mapJoin,\n  objectMapJoin\n} = require('../../lib-util')\nconst conditions = require('./conditions')\nconst valuesArray = require('./values_array')\n\nmodule.exports = (ctx, items, start = 0, end = items.length) => {\n  if (end > items.length) end = items.length\n  let txt = ''\n  for (let i = start; i < end; ++i) {\n    const item = items[i]\n    if (i !== start) txt += item.join\n    txt += fromItem(ctx, item.args)\n    if (item.on) txt += ` on ${conditions(ctx, item.on)}`\n    else if (item.using) txt += ` using (${using(ctx, item.using)})`\n  }\n  return txt\n}\n\nconst usingArg = (ctx, arg) => {\n  if (typeof arg === 'string') return arg\n  if (typeof arg === 'function') return ctx.build(arg)\n  throw Error('Error: Invalid .using arg')\n}\nconst using = mapJoin(buildCall(mapJoin(usingArg)))\n\nconst fromArg = (ctx, arg) => {\n  if (typeof arg === 'string') return arg\n  if (typeof arg === 'function') return ctx.build(arg)\n  if (isObject(arg)) return buildObject(ctx, arg)\n  throw Error('Error: Invalid .from argument:', arg)\n}\n\nconst buildProperty = (ctx, key, value) => {\n  if (typeof value === 'string') return `${value} ${ctx.mapKey(key)}`\n  if (typeof value === 'function')\n    return `${ctx.build(value)} ${ctx.mapKey(key)}`\n  if (Array.isArray(value)) {\n    const { columns, values } = valuesArray(ctx, value)\n    return `(${values}) ${ctx.mapKey(key)}(${columns})`\n  }\n  throw Error('Error: Invalid .from argument')\n}\n\nconst buildObject = objectMapJoin(buildProperty)\nconst fromItem = buildCall(mapJoin(fromArg))\n"]},"metadata":{},"sourceType":"script"}