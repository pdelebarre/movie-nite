{"ast":null,"code":"////////////////////////////////////////////////////////////////////////////\n//\n// Copyright 2016 Realm Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n////////////////////////////////////////////////////////////////////////////\n'use strict';\n\nconst CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nconst CHAR_MAP = {};\nArray.from(CHARS, (char, i) => CHAR_MAP[char] = i);\nexport function decode(base64) {\n  let length = base64.length;\n  let byteCount = length * 0.75;\n\n  if (base64[length - 1] === '=') {\n    byteCount--;\n\n    if (base64[length - 2] === '=') {\n      byteCount--;\n    }\n  }\n\n  let buffer = new ArrayBuffer(byteCount);\n  let bytes = new Uint8Array(buffer);\n\n  for (let i = 0, j = 0; i < length; i += 4) {\n    let index1 = CHAR_MAP[base64[i]];\n    let index2 = CHAR_MAP[base64[i + 1]];\n    let index3 = CHAR_MAP[base64[i + 2]];\n    let index4 = CHAR_MAP[base64[i + 3]];\n    bytes[j++] = (index1 << 2) + ((index2 & 0x30) >> 4);\n    bytes[j++] = ((index2 & 0x0f) << 4) + ((index3 & 0x3c) >> 2);\n    bytes[j++] = ((index3 & 0x03) << 6) + index4;\n  }\n\n  return buffer;\n}\nexport function encode(data) {\n  var byteOffset = 0;\n  var buffer;\n\n  if (data instanceof ArrayBuffer) {\n    buffer = data;\n  } else if (ArrayBuffer.isView(data)) {\n    buffer = data.buffer;\n    byteOffset = data.byteOffset;\n  } else {\n    throw new TypeError('Can only base64 encode ArrayBuffer and ArrayBufferView objects');\n  }\n\n  let byteCount = data.byteLength;\n  let bytes = new Uint8Array(buffer, byteOffset, byteCount);\n  let base64 = '';\n\n  for (let i = 0; i < byteCount; i += 3) {\n    base64 += CHARS[(bytes[i] & 0xfc) >> 2];\n    base64 += CHARS[((bytes[i] & 0x03) << 4) + ((bytes[i + 1] & 0xf0) >> 4)];\n    base64 += CHARS[((bytes[i + 1] & 0x0f) << 2) + ((bytes[i + 2] & 0xc0) >> 6)];\n    base64 += CHARS[bytes[i + 2] & 0x3f];\n  }\n\n  switch (byteCount % 3) {\n    case 1:\n      return base64.slice(0, -2) + '==';\n\n    case 2:\n      return base64.slice(0, -1) + '=';\n\n    default:\n      return base64;\n  }\n}","map":{"version":3,"sources":["/Volumes/LaCie/Dev/myProjects/movie-nite/node_modules/realm/lib/browser/base64.js"],"names":["CHARS","CHAR_MAP","Array","from","char","i","decode","base64","length","byteCount","buffer","ArrayBuffer","bytes","Uint8Array","j","index1","index2","index3","index4","encode","data","byteOffset","isView","TypeError","byteLength","slice"],"mappings":"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","sourcesContent":["////////////////////////////////////////////////////////////////////////////\n//\n// Copyright 2016 Realm Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n////////////////////////////////////////////////////////////////////////////\n\n'use strict';\n\nconst CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nconst CHAR_MAP = {};\n\nArray.from(CHARS, (char, i) => CHAR_MAP[char] = i);\n\nexport function decode(base64) {\n    let length = base64.length;\n    let byteCount = length * 0.75;\n\n    if (base64[length - 1] === '=') {\n        byteCount--;\n        if (base64[length - 2] === '=') {\n            byteCount--;\n        }\n    }\n\n    let buffer = new ArrayBuffer(byteCount);\n    let bytes = new Uint8Array(buffer);\n\n    for (let i = 0, j = 0; i < length; i += 4) {\n        let index1 = CHAR_MAP[base64[i]];\n        let index2 = CHAR_MAP[base64[i + 1]];\n        let index3 = CHAR_MAP[base64[i + 2]];\n        let index4 = CHAR_MAP[base64[i + 3]];\n\n        bytes[j++] = (index1 << 2) + ((index2 & 0x30) >> 4);\n        bytes[j++] = ((index2 & 0x0f) << 4) + ((index3 & 0x3c) >> 2);\n        bytes[j++] = ((index3 & 0x03) << 6) + index4;\n    }\n\n    return buffer;\n}\n\nexport function encode(data) {\n    var byteOffset = 0;\n    var buffer;\n\n    if (data instanceof ArrayBuffer) {\n        buffer = data;\n    } else if (ArrayBuffer.isView(data)) {\n        buffer = data.buffer;\n        byteOffset = data.byteOffset;\n    } else {\n        throw new TypeError('Can only base64 encode ArrayBuffer and ArrayBufferView objects');\n    }\n\n    let byteCount = data.byteLength;\n    let bytes = new Uint8Array(buffer, byteOffset, byteCount);\n    let base64 = '';\n\n    for (let i = 0; i < byteCount; i += 3) {\n        base64 += CHARS[(bytes[i] & 0xfc) >> 2];\n        base64 += CHARS[((bytes[i] & 0x03) << 4) + ((bytes[i + 1] & 0xf0) >> 4)];\n        base64 += CHARS[((bytes[i + 1] & 0x0f) << 2) + ((bytes[i + 2] & 0xc0) >> 6)];\n        base64 += CHARS[bytes[i + 2] & 0x3f];\n    }\n\n    switch (byteCount % 3) {\n        case 1:\n            return base64.slice(0, -2) + '==';\n        case 2:\n            return base64.slice(0, -1) + '=';\n        default:\n            return base64;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}