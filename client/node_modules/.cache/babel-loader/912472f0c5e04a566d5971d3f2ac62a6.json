{"ast":null,"code":"var _require = require('../lib-util'),\n    isTaggedTemplate = _require.isTaggedTemplate;\n\nvar createExpressionCompiler = function createExpressionCompiler(expressionTable) {\n  var callsCompiler = createCallsCompiler(expressionTable);\n  return function (ctx, current) {\n    var calls = buildCalls(current);\n    var text = callsCompiler(ctx, calls);\n    return {\n      text: text,\n      args: ctx.params,\n      type: 'expression'\n    };\n  };\n}; // TODO: Performance optimization:\n// inline expression building with this method so at most only one array\n// is allocated in total, no array of object containing arrays nonsense\n\n\nvar buildCalls = function buildCalls(current) {\n  // get call nodes\n  var calls = [];\n\n  for (; current; current = current.prev) {\n    calls.push(current);\n  }\n\n  if (calls.length === 0) throw Error('Error: Empty expression'); // build expression list\n\n  var expression = {\n    name: 'arg',\n    args: []\n  };\n  var expressions = [expression];\n  var last = calls.length - 1;\n\n  for (var i = last; i >= 0; --i) {\n    var _calls$i = calls[i],\n        name = _calls$i.name,\n        args = _calls$i.args;\n\n    if (i === last) {\n      if (name) expression.name = name;else pushCall(expression.args, args);\n    } else {\n      if (name) expressions.push(expression = {\n        name: name,\n        args: [undefined]\n      });else pushCall(expression.args, args);\n    }\n  }\n\n  return expressions;\n};\n\nvar pushCall = function pushCall(array, args) {\n  if (isTaggedTemplate(args)) {\n    array.push({\n      tag: args\n    });\n  } else {\n    if (args.length === 0) throw Error('Error: Expression call requires at least one argument');\n\n    for (var i = 0; i < args.length; ++i) {\n      array.push({\n        arg: args[i]\n      });\n    }\n  }\n};\n\nvar createCallsCompiler = function createCallsCompiler(expressionTable) {\n  return function (ctx, calls) {\n    var exp;\n\n    for (var i = 0; i < calls.length; ++i) {\n      var _calls$i2 = calls[i],\n          name = _calls$i2.name,\n          args = _calls$i2.args;\n      var _expressionTable$name = expressionTable[name],\n          build = _expressionTable$name.build,\n          minArgs = _expressionTable$name.minArgs,\n          maxArgs = _expressionTable$name.maxArgs;\n      if (i !== 0) args[0] = {\n        exp: exp\n      };\n      var numArgs = args.length;\n      if (numArgs < minArgs) throw Error(\"Error: \".concat(name, \" requires at least \").concat(minArgs, \" arguments\"));\n      if (numArgs > maxArgs) throw Error(\"Error: \".concat(name, \" accepts at most \").concat(maxArgs, \" arguments\"));\n      exp = build(ctx, args);\n    }\n\n    return exp;\n  };\n};\n\nmodule.exports = createExpressionCompiler;","map":{"version":3,"sources":["/Volumes/LaCie/Dev/myProjects/movie-nite/node_modules/EasyQB/src/builder-expression/compile.js"],"names":["require","isTaggedTemplate","createExpressionCompiler","expressionTable","callsCompiler","createCallsCompiler","ctx","current","calls","buildCalls","text","args","params","type","prev","push","length","Error","expression","name","expressions","last","i","pushCall","undefined","array","tag","arg","exp","build","minArgs","maxArgs","numArgs","module","exports"],"mappings":"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","sourcesContent":["const { isTaggedTemplate } = require('../lib-util')\n\nconst createExpressionCompiler = expressionTable => {\n  const callsCompiler = createCallsCompiler(expressionTable)\n  return (ctx, current) => {\n    const calls = buildCalls(current)\n    const text = callsCompiler(ctx, calls)\n    return {\n      text,\n      args: ctx.params,\n      type: 'expression'\n    }\n  }\n}\n\n// TODO: Performance optimization:\n// inline expression building with this method so at most only one array\n// is allocated in total, no array of object containing arrays nonsense\nconst buildCalls = current => {\n  // get call nodes\n  const calls = []\n  for (; current; current = current.prev) calls.push(current)\n  if (calls.length === 0) throw Error('Error: Empty expression')\n\n  // build expression list\n  let expression = { name: 'arg', args: [] }\n  const expressions = [expression]\n  const last = calls.length - 1\n  for (let i = last; i >= 0; --i) {\n    const { name, args } = calls[i]\n    if (i === last) {\n      if (name) expression.name = name\n      else pushCall(expression.args, args)\n    } else {\n      if (name) expressions.push((expression = { name, args: [undefined] }))\n      else pushCall(expression.args, args)\n    }\n  }\n  return expressions\n}\n\nconst pushCall = (array, args) => {\n  if (isTaggedTemplate(args)) {\n    array.push({ tag: args })\n  } else {\n    if (args.length === 0)\n      throw Error('Error: Expression call requires at least one argument')\n    for (let i = 0; i < args.length; ++i) {\n      array.push({ arg: args[i] })\n    }\n  }\n}\n\nconst createCallsCompiler = expressionTable => (ctx, calls) => {\n  let exp\n  for (let i = 0; i < calls.length; ++i) {\n    const { name, args } = calls[i]\n    const { build, minArgs, maxArgs } = expressionTable[name]\n    if (i !== 0) args[0] = { exp }\n    const numArgs = args.length\n    if (numArgs < minArgs)\n      throw Error(`Error: ${name} requires at least ${minArgs} arguments`)\n    if (numArgs > maxArgs)\n      throw Error(`Error: ${name} accepts at most ${maxArgs} arguments`)\n    exp = build(ctx, args)\n  }\n  return exp\n}\n\nmodule.exports = createExpressionCompiler\n"]},"metadata":{},"sourceType":"script"}