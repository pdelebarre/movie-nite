{"ast":null,"code":"////////////////////////////////////////////////////////////////////////////\n//\n// Copyright 2016 Realm Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n////////////////////////////////////////////////////////////////////////////\n'use strict';\n/* global navigator */\n\nconst URL = require('url-parse');\n\nlet getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function (obj) {\n  return Object.getOwnPropertyNames(obj).reduce(function (descriptors, name) {\n    descriptors[name] = Object.getOwnPropertyDescriptor(obj, name);\n    return descriptors;\n  }, {});\n};\n\nfunction setConstructorOnPrototype(klass) {\n  if (klass.prototype.constructor !== klass) {\n    Object.defineProperty(klass.prototype, 'constructor', {\n      value: klass,\n      configurable: true,\n      writable: true\n    });\n  }\n}\n\nfunction openLocalRealm(realmConstructor, config) {\n  let promise = Promise.resolve(new realmConstructor(config));\n\n  promise.progress = callback => {\n    return promise;\n  };\n\n  promise.cancel = () => {};\n\n  return promise;\n}\n\nmodule.exports = function (realmConstructor, environment) {\n  // Add the specified Array methods to the Collection prototype.\n  Object.defineProperties(realmConstructor.Collection.prototype, require('./collection-methods'));\n  setConstructorOnPrototype(realmConstructor.Collection);\n  setConstructorOnPrototype(realmConstructor.List);\n  setConstructorOnPrototype(realmConstructor.Results);\n  setConstructorOnPrototype(realmConstructor.Object);\n  realmConstructor.BSON = require('bson');\n  realmConstructor._Decimal128 = realmConstructor.BSON.Decimal128;\n  realmConstructor._ObjectId = realmConstructor.BSON.ObjectId;\n\n  const {\n    DefaultNetworkTransport\n  } = require('realm-network-transport');\n\n  realmConstructor._networkTransport = new DefaultNetworkTransport();\n  Object.defineProperty(realmConstructor.Collection.prototype, \"toJSON\", {\n    value: function (_, cache = new Map()) {\n      return this.map((item, index) => item instanceof realmConstructor.Object ? item.toJSON(index.toString(), cache) : item);\n    },\n    writable: true,\n    configurable: true,\n    enumerable: false\n  });\n\n  const getInternalCacheId = realmObj => {\n    const {\n      name,\n      primaryKey\n    } = realmObj.objectSchema();\n    const id = primaryKey ? realmObj[primaryKey] : realmObj._objectId();\n    return `${name}#${id}`;\n  };\n\n  Object.defineProperty(realmConstructor.Object.prototype, \"toJSON\", {\n    value: function (_, cache = new Map()) {\n      // Construct a reference-id of table-name & primaryKey if it exists, or fall back to objectId.\n      const id = getInternalCacheId(this); // Check if current objectId has already processed, to keep object references the same.\n\n      const existing = cache.get(id);\n\n      if (existing) {\n        return existing;\n      } // Create new result, and store in cache.\n\n\n      const result = {};\n      cache.set(id, result); // Add the generated reference-id, as a non-enumerable prop '$refId', for later exposure though e.g. Realm.JsonSerializationReplacer.\n\n      Object.defineProperty(result, \"$refId\", {\n        value: id,\n        configurable: true\n      }); // Move all enumerable keys to result, triggering any specific toJSON implementation in the process.\n\n      Object.keys(this).concat(Object.keys(Object.getPrototypeOf(this))).forEach(key => {\n        const value = this[key]; // skip any functions & constructors (in case of class models).\n\n        if (typeof value === \"function\") {\n          return; // continue\n        } // recursively trigger `toJSON` for Realm instances with the same cache.\n\n\n        result[key] = value instanceof realmConstructor.Object || value instanceof realmConstructor.Collection ? value.toJSON(key, cache) : value;\n      });\n      return result;\n    },\n    writable: true,\n    configurable: true,\n    enumerable: false\n  });\n  Object.defineProperty(realmConstructor.Object.prototype, \"keys\", {\n    value: function () {\n      return Object.keys(this).concat(Object.keys(Object.getPrototypeOf(this)));\n    },\n    writable: true,\n    configurable: true,\n    enumerable: false\n  });\n  Object.defineProperty(realmConstructor.Object.prototype, \"entries\", {\n    value: function () {\n      let result = {};\n\n      for (const key in this) {\n        result[key] = this[key];\n      }\n\n      return Object.entries(result);\n    },\n    writable: true,\n    configurable: true,\n    enumerable: false\n  }); //Add static methods to the Realm object\n\n  Object.defineProperties(realmConstructor, getOwnPropertyDescriptors({\n    open(config) {\n      // If no config is defined, we should just open the default realm\n      if (config === undefined) {\n        config = {};\n      } // For local Realms we open the Realm and return it in a resolved Promise.\n\n\n      if (!(\"sync\" in config)) {\n        return openLocalRealm(realmConstructor, config);\n      } // Determine if we are opening an existing Realm or not.\n\n\n      let behavior = realmConstructor.exists(config) ? \"existingRealmFileBehavior\" : \"newRealmFileBehavior\"; // Define how the Realm file is opened\n\n      let openLocalRealmImmediately = false; // Default is downloadBeforeOpen\n\n      if (config.sync[behavior] !== undefined) {\n        const type = config.sync[behavior].type;\n\n        switch (type) {\n          case 'downloadBeforeOpen':\n            openLocalRealmImmediately = false;\n            break;\n\n          case 'openImmediately':\n            openLocalRealmImmediately = true;\n            break;\n\n          default:\n            throw Error(`Invalid type: '${type}'. Only 'downloadBeforeOpen' and 'openImmediately' is allowed.`);\n        }\n      } // If configured to do so, the synchronized Realm will be opened locally immediately.\n      // If this is the first time the Realm is created, the schema will be created locally as well.\n\n\n      if (openLocalRealmImmediately) {\n        return openLocalRealm(realmConstructor, config);\n      } // Otherwise attempt to synchronize the Realm state from the server before opening it.\n      // First configure any timeOut and corresponding behavior.\n\n\n      let openPromises = [];\n\n      if (config.sync[behavior] !== undefined && config.sync[behavior].timeOut !== undefined) {\n        let timeOut = config.sync[behavior].timeOut;\n\n        if (typeof timeOut !== 'number') {\n          throw new Error(`'timeOut' must be a number: '${timeOut}'`);\n        } // Define the behavior in case of a timeout\n\n\n        let throwOnTimeOut = true; // Default is to throw\n\n        if (config.sync[behavior] !== undefined && config.sync[behavior].timeOutBehavior) {\n          const timeOutBehavior = config.sync[behavior].timeOutBehavior;\n\n          switch (timeOutBehavior) {\n            case 'throwException':\n              throwOnTimeOut = true;\n              break;\n\n            case 'openLocal':\n              throwOnTimeOut = false;\n              break;\n\n            default:\n              throw Error(`Invalid 'timeOutBehavior': '${timeOutBehavior}'. Only 'throwException' and 'openLocal' is allowed.`);\n          }\n        }\n\n        openPromises.push(new Promise((resolve, reject) => {\n          setTimeout(() => {\n            if (asyncOpenTask) {\n              asyncOpenTask.cancel();\n              asyncOpenTask = null;\n            }\n\n            if (throwOnTimeOut) {\n              reject(new Error(`${config.sync.url} could not be downloaded in the allocated time: ${timeOut} ms.`));\n            } else {\n              return resolve(openLocalRealm(realmConstructor, config));\n            }\n          }, timeOut);\n        }));\n      } // Configure promise responsible for downloading the Realm from the server\n\n\n      let asyncOpenTask;\n      let cancelled = false;\n      openPromises.push(new Promise((resolve, reject) => {\n        asyncOpenTask = realmConstructor._asyncOpen(config, (realm, error) => {\n          setTimeout(() => {\n            asyncOpenTask = null; // The user may have cancelled the open between when\n            // the download completed and when we managed to\n            // actually invoke this, so recheck here.\n\n            if (cancelled) {\n              return;\n            }\n\n            if (error) {\n              reject(error);\n            } else {\n              resolve(realm);\n            }\n          }, 0);\n        });\n      })); // Return wrapped promises, allowing the users to control them.\n\n      let openPromise = Promise.race(openPromises);\n\n      openPromise.cancel = () => {\n        if (asyncOpenTask) {\n          asyncOpenTask.cancel();\n          cancelled = true;\n        }\n      };\n\n      openPromise.progress = callback => {\n        if (asyncOpenTask) {\n          asyncOpenTask.addDownloadNotification(callback);\n        }\n\n        return openPromise;\n      };\n\n      return openPromise;\n    },\n\n    createTemplateObject(objectSchema) {\n      let obj = {};\n\n      for (let key in objectSchema.properties) {\n        let type;\n\n        if (typeof objectSchema.properties[key] === 'string' || objectSchema.properties[key] instanceof String) {\n          // Simple declaration of the type\n          type = objectSchema.properties[key];\n        } else {\n          // Advanced property setup\n          const property = objectSchema.properties[key]; // if optional is set, it wil take precedence over any `?` set on the type parameter\n\n          if (property.optional === true) {\n            continue;\n          } // If a default value is explicitly set, always set the property\n\n\n          if (property.default !== undefined) {\n            obj[key] = property.default;\n            continue;\n          }\n\n          type = property.type;\n        } // Set the default value for all required primitive types.\n        // Lists are always treated as empty if not specified and references to objects are always optional\n\n\n        switch (type) {\n          case 'bool':\n            obj[key] = false;\n            break;\n\n          case 'int':\n            obj[key] = 0;\n            break;\n\n          case 'float':\n            obj[key] = 0.0;\n            break;\n\n          case 'double':\n            obj[key] = 0.0;\n            break;\n\n          case 'string':\n            obj[key] = \"\";\n            break;\n\n          case 'data':\n            obj[key] = new ArrayBuffer(0);\n            break;\n\n          case 'date':\n            obj[key] = new Date(0);\n            break;\n        }\n      }\n\n      return obj;\n    }\n\n  })); // Add static properties to Realm Object\n\n  const updateModeType = {\n    All: 'all',\n    Modified: 'modified',\n    Never: 'never'\n  };\n\n  if (!realmConstructor.UpdateMode) {\n    Object.defineProperty(realmConstructor, 'UpdateMode', {\n      value: updateModeType,\n      configurable: false\n    });\n  } // Add sync methods\n\n\n  if (realmConstructor.App.Sync) {\n    let appMethods = require(\"./app\");\n\n    Object.defineProperties(realmConstructor.App, getOwnPropertyDescriptors(appMethods.static));\n    Object.defineProperties(realmConstructor.App.prototype, getOwnPropertyDescriptors(appMethods.instance));\n\n    let userMethods = require(\"./user\");\n\n    Object.defineProperties(realmConstructor.User, getOwnPropertyDescriptors(userMethods.static));\n    Object.defineProperties(realmConstructor.User.prototype, getOwnPropertyDescriptors(userMethods.instance));\n\n    let sessionMethods = require(\"./session\");\n\n    Object.defineProperties(realmConstructor.App.Sync.Session, getOwnPropertyDescriptors(sessionMethods.static));\n    Object.defineProperties(realmConstructor.App.Sync.Session.prototype, getOwnPropertyDescriptors(sessionMethods.instance));\n\n    let credentialMethods = require(\"./credentials\");\n\n    Object.defineProperties(realmConstructor.Credentials, getOwnPropertyDescriptors(credentialMethods.static));\n\n    let emailPasswordAuthMethods = require(\"./email-password-auth-methods\");\n\n    Object.defineProperties(realmConstructor.Auth.EmailPasswordAuth.prototype, getOwnPropertyDescriptors(emailPasswordAuthMethods.instance));\n\n    let apiKeyAuthMethods = require(\"./api-key-auth-methods\");\n\n    Object.defineProperties(realmConstructor.Auth.ApiKeyAuth.prototype, getOwnPropertyDescriptors(apiKeyAuthMethods.instance));\n    realmConstructor.App.Sync.AuthError = require(\"./errors\").AuthError;\n\n    if (realmConstructor.App.Sync.removeAllListeners) {\n      process.on(\"exit\", realmConstructor.App.Sync.removeAllListeners);\n      process.on(\"SIGINT\", function () {\n        realmConstructor.App.Sync.removeAllListeners();\n        process.exit(2);\n      });\n      process.on(\"uncaughtException\", function (e) {\n        realmConstructor.App.Sync.removeAllListeners();\n        /* eslint-disable no-console */\n\n        console.log(e.stack);\n        process.exit(99);\n      });\n    }\n\n    setConstructorOnPrototype(realmConstructor.User);\n    setConstructorOnPrototype(realmConstructor.App.Sync.Session);\n    setConstructorOnPrototype(realmConstructor.App);\n    setConstructorOnPrototype(realmConstructor.Credentials);\n    realmConstructor.App.Sync.openLocalRealmBehavior = {\n      type: 'openImmediately'\n    };\n    realmConstructor.App.Sync.downloadBeforeOpenBehavior = {\n      type: 'downloadBeforeOpen',\n      timeOut: 30 * 1000,\n      timeOutBehavior: 'throwException'\n    };\n    realmConstructor.App.Sync.ConnectionState = {\n      Disconnected: \"disconnected\",\n      Connecting: \"connecting\",\n      Connected: \"connected\"\n    };\n    realmConstructor.App.Sync.ClientResyncMode = {\n      Discard: 'discard',\n      Manual: 'manual',\n      Recover: 'recover'\n    };\n  } // TODO: Remove this now useless object.\n\n\n  var types = Object.freeze({\n    'BOOL': 'bool',\n    'INT': 'int',\n    'FLOAT': 'float',\n    'DOUBLE': 'double',\n    'STRING': 'string',\n    'DATE': 'date',\n    'DATA': 'data',\n    'OBJECT': 'object',\n    'LIST': 'list'\n  });\n  Object.defineProperty(realmConstructor, 'Types', {\n    get: function () {\n      if (typeof console != 'undefined') {\n        /* global console */\n\n        /* eslint-disable no-console */\n        var stack = new Error().stack.split(\"\\n\").slice(2).join(\"\\n\");\n        var msg = '`Realm.Types` is deprecated! Please specify the type name as lowercase string instead!\\n' + stack;\n\n        if (console.warn != undefined) {\n          console.warn(msg);\n        } else {\n          console.log(msg);\n        }\n        /* eslint-enable no-console */\n\n      }\n\n      return types;\n    },\n    configurable: true\n  });\n\n  if (!realmConstructor.JsonSerializationReplacer) {\n    Object.defineProperty(realmConstructor, \"JsonSerializationReplacer\", {\n      get: function () {\n        const seen = [];\n        return function (_, value) {\n          // Only check for circular references when dealing with objects & arrays.\n          if (value === null || typeof value !== \"object\") {\n            return value;\n          } // 'this' refers to the object or array containing the the current key/value.\n\n\n          const parent = this;\n\n          if (value.$refId) {\n            // Expose the non-enumerable prop $refId for circular serialization, if it exists.\n            Object.defineProperty(value, \"$refId\", {\n              enumerable: true\n            });\n          }\n\n          if (!seen.length) {\n            // If we haven't seen anything yet, we only push the current value (root element/array).\n            seen.push(value);\n            return value;\n          }\n\n          const pos = seen.indexOf(parent);\n\n          if (pos !== -1) {\n            // If we have seen the parent before, we have already traversed a sibling in the array.\n            // We then discard information gathered for the sibling (zero back to the current array).\n            seen.splice(pos + 1);\n          } else {\n            // If we haven't seen the parent before, we add it to the seen-path.\n            // Note that this is done both for objects & arrays, to detect when we go to the next item in an array (see above).\n            seen.push(parent);\n          }\n\n          if (seen.includes(value)) {\n            // If we have seen the current value before, return a reference-structure if possible.\n            if (value.$refId) {\n              return {\n                $ref: value.$refId\n              };\n            }\n\n            return \"[Circular reference]\";\n          }\n\n          return value;\n        };\n      }\n    });\n  }\n};","map":{"version":3,"sources":["/Volumes/LaCie/Dev/myProjects/movie-nite/node_modules/realm/lib/extensions.js"],"names":["URL","require","getOwnPropertyDescriptors","Object","obj","getOwnPropertyNames","reduce","descriptors","name","getOwnPropertyDescriptor","setConstructorOnPrototype","klass","prototype","constructor","defineProperty","value","configurable","writable","openLocalRealm","realmConstructor","config","promise","Promise","resolve","progress","callback","cancel","module","exports","environment","defineProperties","Collection","List","Results","BSON","_Decimal128","Decimal128","_ObjectId","ObjectId","DefaultNetworkTransport","_networkTransport","_","cache","Map","map","item","index","toJSON","toString","enumerable","getInternalCacheId","realmObj","primaryKey","objectSchema","id","_objectId","existing","get","result","set","keys","concat","getPrototypeOf","forEach","key","entries","open","undefined","behavior","exists","openLocalRealmImmediately","sync","type","Error","openPromises","timeOut","throwOnTimeOut","timeOutBehavior","push","reject","setTimeout","asyncOpenTask","url","cancelled","_asyncOpen","realm","error","openPromise","race","addDownloadNotification","createTemplateObject","properties","String","property","optional","default","ArrayBuffer","Date","updateModeType","All","Modified","Never","UpdateMode","App","Sync","appMethods","static","instance","userMethods","User","sessionMethods","Session","credentialMethods","Credentials","emailPasswordAuthMethods","Auth","EmailPasswordAuth","apiKeyAuthMethods","ApiKeyAuth","AuthError","removeAllListeners","process","on","exit","e","console","log","stack","openLocalRealmBehavior","downloadBeforeOpenBehavior","ConnectionState","Disconnected","Connecting","Connected","ClientResyncMode","Discard","Manual","Recover","types","freeze","split","slice","join","msg","warn","JsonSerializationReplacer","seen","parent","$refId","length","pos","indexOf","splice","includes","$ref"],"mappings":"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","sourcesContent":["////////////////////////////////////////////////////////////////////////////\n//\n// Copyright 2016 Realm Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n////////////////////////////////////////////////////////////////////////////\n\n'use strict';\n\n/* global navigator */\n\nconst URL = require('url-parse');\n\nlet getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function(obj) {\n    return Object.getOwnPropertyNames(obj).reduce(function (descriptors, name) {\n        descriptors[name] = Object.getOwnPropertyDescriptor(obj, name);\n        return descriptors;\n    }, {});\n};\n\nfunction setConstructorOnPrototype(klass) {\n    if (klass.prototype.constructor !== klass) {\n        Object.defineProperty(klass.prototype, 'constructor', { value: klass, configurable: true, writable: true });\n    }\n}\n\nfunction openLocalRealm(realmConstructor, config) {\n    let promise = Promise.resolve(new realmConstructor(config));\n    promise.progress = (callback) => { return promise; };\n    promise.cancel = () => { };\n    return promise;\n}\n\nmodule.exports = function(realmConstructor, environment) {\n    // Add the specified Array methods to the Collection prototype.\n    Object.defineProperties(realmConstructor.Collection.prototype, require('./collection-methods'));\n\n    setConstructorOnPrototype(realmConstructor.Collection);\n    setConstructorOnPrototype(realmConstructor.List);\n    setConstructorOnPrototype(realmConstructor.Results);\n    setConstructorOnPrototype(realmConstructor.Object);\n\n    realmConstructor.BSON = require('bson');\n    realmConstructor._Decimal128 = realmConstructor.BSON.Decimal128;\n    realmConstructor._ObjectId = realmConstructor.BSON.ObjectId;\n    \n    const { DefaultNetworkTransport } = require('realm-network-transport');\n    realmConstructor._networkTransport = new DefaultNetworkTransport();\n\n    Object.defineProperty(realmConstructor.Collection.prototype, \"toJSON\", {\n        value: function (_, cache = new Map()) {\n            return this.map((item, index) =>\n                item instanceof realmConstructor.Object ? item.toJSON(index.toString(), cache) : item);\n        },\n\n        writable: true,\n        configurable: true,\n        enumerable: false\n    });\n\n    const getInternalCacheId = (realmObj) => {\n        const { name, primaryKey } = realmObj.objectSchema();\n        const id = primaryKey ? realmObj[primaryKey] : realmObj._objectId();\n        return `${name}#${id}`;\n    }\n\n    Object.defineProperty(realmConstructor.Object.prototype, \"toJSON\", {\n        value: function (_, cache = new Map()) {\n            // Construct a reference-id of table-name & primaryKey if it exists, or fall back to objectId.\n            const id = getInternalCacheId(this);\n\n            // Check if current objectId has already processed, to keep object references the same.\n            const existing = cache.get(id);\n            if (existing) {\n                return existing;\n            }\n\n            // Create new result, and store in cache.\n            const result = {};\n            cache.set(id, result);\n\n            // Add the generated reference-id, as a non-enumerable prop '$refId', for later exposure though e.g. Realm.JsonSerializationReplacer.\n            Object.defineProperty(result, \"$refId\", { value: id, configurable: true });\n\n            // Move all enumerable keys to result, triggering any specific toJSON implementation in the process.\n            Object.keys(this)\n                .concat(Object.keys(Object.getPrototypeOf(this)))\n                .forEach(key => {\n                    const value = this[key];\n\n                    // skip any functions & constructors (in case of class models).\n                    if (typeof value === \"function\") {\n                        return; // continue\n                    }\n\n                    // recursively trigger `toJSON` for Realm instances with the same cache.\n                    result[key] = (value instanceof realmConstructor.Object || value instanceof realmConstructor.Collection)\n                        ? value.toJSON(key, cache)\n                        : value;\n                });\n\n            return result;\n        },\n\n        writable: true,\n        configurable: true,\n        enumerable: false\n    });\n\n    Object.defineProperty(realmConstructor.Object.prototype, \"keys\", {\n        value: function () {\n            return Object.keys(this).concat(Object.keys(Object.getPrototypeOf(this)));\n        },\n\n        writable: true,\n        configurable: true,\n        enumerable: false\n    });\n\n    Object.defineProperty(realmConstructor.Object.prototype, \"entries\", {\n        value: function () {\n            let result = {};\n            for (const key in this) {\n                result[key] = this[key];\n            }\n\n            return Object.entries(result);\n        },\n\n        writable: true,\n        configurable: true,\n        enumerable: false\n    });\n\n    //Add static methods to the Realm object\n    Object.defineProperties(realmConstructor, getOwnPropertyDescriptors({\n        open(config) {\n            // If no config is defined, we should just open the default realm\n            if (config === undefined) {\n                config = {};\n            }\n\n            // For local Realms we open the Realm and return it in a resolved Promise.\n            if (!(\"sync\" in config)) {\n                return openLocalRealm(realmConstructor, config);\n            }\n\n            // Determine if we are opening an existing Realm or not.\n            let behavior = realmConstructor.exists(config) ? \"existingRealmFileBehavior\" : \"newRealmFileBehavior\";\n\n            // Define how the Realm file is opened\n            let openLocalRealmImmediately = false; // Default is downloadBeforeOpen\n            if (config.sync[behavior] !== undefined) {\n                const type = config.sync[behavior].type;\n                switch (type) {\n                    case 'downloadBeforeOpen':\n                        openLocalRealmImmediately = false;\n                        break;\n                    case 'openImmediately':\n                        openLocalRealmImmediately = true;\n                        break;\n                    default:\n                        throw Error(`Invalid type: '${type}'. Only 'downloadBeforeOpen' and 'openImmediately' is allowed.`);\n                }\n            }\n\n            // If configured to do so, the synchronized Realm will be opened locally immediately.\n            // If this is the first time the Realm is created, the schema will be created locally as well.\n            if (openLocalRealmImmediately) {\n                return openLocalRealm(realmConstructor, config);\n            }\n\n            // Otherwise attempt to synchronize the Realm state from the server before opening it.\n\n            // First configure any timeOut and corresponding behavior.\n            let openPromises = [];\n            if (config.sync[behavior] !== undefined && config.sync[behavior].timeOut !== undefined) {\n                let timeOut = config.sync[behavior].timeOut;\n                if (typeof timeOut !== 'number') {\n                    throw new Error(`'timeOut' must be a number: '${timeOut}'`);\n                }\n\n                // Define the behavior in case of a timeout\n                let throwOnTimeOut = true; // Default is to throw\n                if (config.sync[behavior] !== undefined && config.sync[behavior].timeOutBehavior) {\n                    const timeOutBehavior = config.sync[behavior].timeOutBehavior;\n                    switch (timeOutBehavior) {\n                        case 'throwException':\n                            throwOnTimeOut = true;\n                            break;\n                        case 'openLocal':\n                            throwOnTimeOut = false;\n                            break;\n                        default:\n                            throw Error(`Invalid 'timeOutBehavior': '${timeOutBehavior}'. Only 'throwException' and 'openLocal' is allowed.`);\n                    }\n                }\n\n                openPromises.push(new Promise((resolve, reject) => {\n                    setTimeout(() => {\n                        if (asyncOpenTask) {\n                            asyncOpenTask.cancel();\n                            asyncOpenTask = null;\n                        }\n                        if (throwOnTimeOut) {\n                            reject(new Error(`${config.sync.url} could not be downloaded in the allocated time: ${timeOut} ms.`));\n                        } else {\n                            return resolve(openLocalRealm(realmConstructor, config));\n                        }\n                    }, timeOut);\n                }));\n            }\n\n            // Configure promise responsible for downloading the Realm from the server\n            let asyncOpenTask;\n            let cancelled = false;\n            openPromises.push(new Promise((resolve, reject) => {\n                asyncOpenTask = realmConstructor._asyncOpen(config, (realm, error) => {\n                    setTimeout(() => {\n                        asyncOpenTask = null;\n                        // The user may have cancelled the open between when\n                        // the download completed and when we managed to\n                        // actually invoke this, so recheck here.\n                        if (cancelled) {\n                            return;\n                        }\n                        if (error) {\n                            reject(error);\n                        } else {\n                            resolve(realm);\n                        }\n                    }, 0);\n                });\n            }));\n\n            // Return wrapped promises, allowing the users to control them.\n            let openPromise = Promise.race(openPromises);\n            openPromise.cancel = () => {\n                if (asyncOpenTask) {\n                    asyncOpenTask.cancel();\n                    cancelled = true;\n                }\n            };\n            openPromise.progress = (callback) => {\n                if (asyncOpenTask) {\n                    asyncOpenTask.addDownloadNotification(callback);\n                }\n                return openPromise;\n            };\n            return openPromise;\n        },\n\n        createTemplateObject(objectSchema) {\n            let obj = {};\n            for (let key in objectSchema.properties) {\n\n                let type;\n                if (typeof objectSchema.properties[key] === 'string' || objectSchema.properties[key] instanceof String) {\n                    // Simple declaration of the type\n                    type = objectSchema.properties[key];\n                } else {\n                    // Advanced property setup\n                    const property = objectSchema.properties[key];\n\n                    // if optional is set, it wil take precedence over any `?` set on the type parameter\n                    if (property.optional === true) {\n                        continue;\n                    }\n\n                    // If a default value is explicitly set, always set the property\n                    if (property.default !== undefined) {\n                        obj[key] = property.default;\n                        continue;\n                    }\n\n                    type = property.type;\n                }\n\n                // Set the default value for all required primitive types.\n                // Lists are always treated as empty if not specified and references to objects are always optional\n                switch (type) {\n                    case 'bool': obj[key] = false; break;\n                    case 'int': obj[key] = 0; break;\n                    case 'float': obj[key] = 0.0; break;\n                    case 'double': obj[key] = 0.0; break;\n                    case 'string': obj[key] = \"\"; break;\n                    case 'data': obj[key] = new ArrayBuffer(0); break;\n                    case 'date': obj[key] = new Date(0); break;\n                }\n            }\n            return obj;\n        },\n    }));\n\n    // Add static properties to Realm Object\n    const updateModeType = {\n      All: 'all',\n      Modified: 'modified',\n      Never: 'never',\n    };\n\n    if (!realmConstructor.UpdateMode) {\n      Object.defineProperty(realmConstructor, 'UpdateMode', {\n        value: updateModeType,\n        configurable: false,\n      });\n    }\n\n    // Add sync methods\n    if (realmConstructor.App.Sync) {\n        let appMethods = require(\"./app\");\n        Object.defineProperties(realmConstructor.App, getOwnPropertyDescriptors(appMethods.static));\n        Object.defineProperties(realmConstructor.App.prototype, getOwnPropertyDescriptors(appMethods.instance));\n\n        let userMethods = require(\"./user\");\n        Object.defineProperties(realmConstructor.User, getOwnPropertyDescriptors(userMethods.static));\n        Object.defineProperties(realmConstructor.User.prototype, getOwnPropertyDescriptors(userMethods.instance));\n\n        let sessionMethods = require(\"./session\");\n        Object.defineProperties(realmConstructor.App.Sync.Session, getOwnPropertyDescriptors(sessionMethods.static));\n        Object.defineProperties(realmConstructor.App.Sync.Session.prototype, getOwnPropertyDescriptors(sessionMethods.instance));\n\n        let credentialMethods = require(\"./credentials\");\n        Object.defineProperties(realmConstructor.Credentials, getOwnPropertyDescriptors(credentialMethods.static))\n\n        let emailPasswordAuthMethods = require(\"./email-password-auth-methods\");\n        Object.defineProperties(realmConstructor.Auth.EmailPasswordAuth.prototype, getOwnPropertyDescriptors(emailPasswordAuthMethods.instance));\n\n        let apiKeyAuthMethods = require(\"./api-key-auth-methods\");\n        Object.defineProperties(realmConstructor.Auth.ApiKeyAuth.prototype, getOwnPropertyDescriptors(apiKeyAuthMethods.instance));\n\n\n        realmConstructor.App.Sync.AuthError = require(\"./errors\").AuthError;\n\n        if (realmConstructor.App.Sync.removeAllListeners) {\n            process.on(\"exit\", realmConstructor.App.Sync.removeAllListeners);\n            process.on(\"SIGINT\", function () {\n                realmConstructor.App.Sync.removeAllListeners();\n                process.exit(2);\n            });\n            process.on(\"uncaughtException\", function(e) {\n                realmConstructor.App.Sync.removeAllListeners();\n                /* eslint-disable no-console */\n                console.log(e.stack);\n                process.exit(99);\n            });\n        }\n\n        setConstructorOnPrototype(realmConstructor.User);\n        setConstructorOnPrototype(realmConstructor.App.Sync.Session);\n        setConstructorOnPrototype(realmConstructor.App);\n        setConstructorOnPrototype(realmConstructor.Credentials);\n\n\n        realmConstructor.App.Sync.openLocalRealmBehavior = {\n            type: 'openImmediately'\n        };\n\n        realmConstructor.App.Sync.downloadBeforeOpenBehavior = {\n            type: 'downloadBeforeOpen',\n            timeOut: 30 * 1000,\n            timeOutBehavior: 'throwException'\n        };\n\n        realmConstructor.App.Sync.ConnectionState = {\n            Disconnected: \"disconnected\",\n            Connecting: \"connecting\",\n            Connected: \"connected\",\n        };\n\n        realmConstructor.App.Sync.ClientResyncMode = {\n            Discard: 'discard',\n            Manual: 'manual',\n            Recover: 'recover'\n        };\n    }\n\n    // TODO: Remove this now useless object.\n    var types = Object.freeze({\n        'BOOL': 'bool',\n        'INT': 'int',\n        'FLOAT': 'float',\n        'DOUBLE': 'double',\n        'STRING': 'string',\n        'DATE': 'date',\n        'DATA': 'data',\n        'OBJECT': 'object',\n        'LIST': 'list',\n    });\n    Object.defineProperty(realmConstructor, 'Types', {\n        get: function() {\n            if (typeof console != 'undefined') {\n                /* global console */\n                /* eslint-disable no-console */\n                var stack = new Error().stack.split(\"\\n\").slice(2).join(\"\\n\");\n                var msg = '`Realm.Types` is deprecated! Please specify the type name as lowercase string instead!\\n'+stack;\n                if (console.warn != undefined) {\n                    console.warn(msg);\n                }\n                else {\n                    console.log(msg);\n                }\n                /* eslint-enable no-console */\n            }\n            return types;\n        },\n        configurable: true\n    });\n\n    if (!realmConstructor.JsonSerializationReplacer) {\n        Object.defineProperty(realmConstructor, \"JsonSerializationReplacer\", {\n            get: function () {\n                const seen = [];\n\n                return function(_, value) {\n                    // Only check for circular references when dealing with objects & arrays.\n                    if (value === null || typeof value !== \"object\") {\n                        return value;\n                    }\n\n                    // 'this' refers to the object or array containing the the current key/value.\n                    const parent = this;\n\n                    if (value.$refId) {\n                        // Expose the non-enumerable prop $refId for circular serialization, if it exists.\n                        Object.defineProperty(value, \"$refId\", { enumerable: true })\n                    }\n\n                    if (!seen.length) {\n                        // If we haven't seen anything yet, we only push the current value (root element/array).\n                        seen.push(value);\n                        return value;\n                    }\n\n                    const pos = seen.indexOf(parent);\n                    if (pos !== -1) {\n                        // If we have seen the parent before, we have already traversed a sibling in the array.\n                        // We then discard information gathered for the sibling (zero back to the current array).\n                        seen.splice(pos + 1);\n                    } else {\n                        // If we haven't seen the parent before, we add it to the seen-path.\n                        // Note that this is done both for objects & arrays, to detect when we go to the next item in an array (see above).\n                        seen.push(parent);\n                    }\n\n                    if (seen.includes(value)) {\n                        // If we have seen the current value before, return a reference-structure if possible.\n                        if (value.$refId) {\n                            return { $ref: value.$refId };\n                        }\n                        return \"[Circular reference]\";\n                    }\n\n                    return value;\n                };\n            }\n        });\n    }\n};\n"]},"metadata":{},"sourceType":"script"}