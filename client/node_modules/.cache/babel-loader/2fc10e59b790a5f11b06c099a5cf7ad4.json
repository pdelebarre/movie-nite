{"ast":null,"code":"var _require = require('../../lib-util'),\n    isObject = _require.isObject,\n    buildCall = _require.buildCall,\n    mapJoin = _require.mapJoin,\n    mapJoinWrap = _require.mapJoinWrap;\n\nmodule.exports = function (ctx) {\n  if (ctx.grp.length === 0) return;\n  var txt = calls(ctx, ctx.grp);\n  return txt && \"group by \".concat(txt);\n};\n\nvar buildArg = function buildArg(ctx, arg) {\n  if (typeof arg === 'string') return arg;\n  if (typeof arg === 'function') return ctx.build(arg);\n  if (Array.isArray(arg)) return buildArrayArg(ctx, arg);\n  if (isObject(arg)) return buildObject(ctx, arg);\n  throw Error('Invalid order by argument:', arg);\n};\n\nvar buildArrayArg = mapJoinWrap(buildArg); // postgres only\n// clone of buildArg() without support for object args\n\nvar buildCubeOrRollupArg = function buildCubeOrRollupArg(ctx, arg) {\n  if (typeof arg === 'string') return arg;\n  if (typeof arg === 'function') return ctx.build(arg);\n  if (Array.isArray(arg)) return buildCubeOrRollupArrayArg(ctx, arg);\n  throw Error('Invalid cube/rollup argument');\n}; // postgres only\n// clone of buildArrayArg() without support for object args\n\n\nvar buildCubeOrRollupArrayArg = mapJoinWrap(buildCubeOrRollupArg); // postgres only\n\nvar buildObject = function buildObject(ctx, obj) {\n  var type = obj.type,\n      args = obj.args;\n\n  if (type === 'rollup') {\n    return \"rollup \".concat(buildCubeOrRollupArg(ctx, args));\n  }\n\n  if (type === 'cube') {\n    return \"cube \".concat(buildCubeOrRollupArg(ctx, args));\n  }\n\n  if (type === 'grouping sets') {\n    return \"grouping sets \".concat(buildArg(ctx, args));\n  }\n\n  throw Error('Invalid group by argument');\n};\n\nvar calls = mapJoin(buildCall(mapJoin(buildArg)));","map":{"version":3,"sources":["/Volumes/LaCie/Dev/myProjects/movie-nite/node_modules/EasyQB/src/lib-sq/clauses/group.js"],"names":["require","isObject","buildCall","mapJoin","mapJoinWrap","module","exports","ctx","grp","length","txt","calls","buildArg","arg","build","Array","isArray","buildArrayArg","buildObject","Error","buildCubeOrRollupArg","buildCubeOrRollupArrayArg","obj","type","args"],"mappings":"eAAsDA,OAAO,CAAC,gBAAD,C;IAArDC,Q,YAAAA,Q;IAAUC,S,YAAAA,S;IAAWC,O,YAAAA,O;IAASC,W,YAAAA,W;;AAEtCC,MAAM,CAACC,OAAP,GAAiB,UAAAC,GAAG,EAAI;AACtB,MAAIA,GAAG,CAACC,GAAJ,CAAQC,MAAR,KAAmB,CAAvB,EAA0B;AAC1B,MAAMC,GAAG,GAAGC,KAAK,CAACJ,GAAD,EAAMA,GAAG,CAACC,GAAV,CAAjB;AACA,SAAOE,GAAG,uBAAgBA,GAAhB,CAAV;AACD,CAJD;;AAMA,IAAME,QAAQ,GAAG,SAAXA,QAAW,CAACL,GAAD,EAAMM,GAAN,EAAc;AAC7B,MAAI,OAAOA,GAAP,KAAe,QAAnB,EAA6B,OAAOA,GAAP;AAC7B,MAAI,OAAOA,GAAP,KAAe,UAAnB,EAA+B,OAAON,GAAG,CAACO,KAAJ,CAAUD,GAAV,CAAP;AAC/B,MAAIE,KAAK,CAACC,OAAN,CAAcH,GAAd,CAAJ,EAAwB,OAAOI,aAAa,CAACV,GAAD,EAAMM,GAAN,CAApB;AACxB,MAAIZ,QAAQ,CAACY,GAAD,CAAZ,EAAmB,OAAOK,WAAW,CAACX,GAAD,EAAMM,GAAN,CAAlB;AACnB,QAAMM,KAAK,CAAC,4BAAD,EAA+BN,GAA/B,CAAX;AACD,CAND;;AAQA,IAAMI,aAAa,GAAGb,WAAW,CAACQ,QAAD,CAAjC,C,CAEA;AACA;;AACA,IAAMQ,oBAAoB,GAAG,SAAvBA,oBAAuB,CAACb,GAAD,EAAMM,GAAN,EAAc;AACzC,MAAI,OAAOA,GAAP,KAAe,QAAnB,EAA6B,OAAOA,GAAP;AAC7B,MAAI,OAAOA,GAAP,KAAe,UAAnB,EAA+B,OAAON,GAAG,CAACO,KAAJ,CAAUD,GAAV,CAAP;AAC/B,MAAIE,KAAK,CAACC,OAAN,CAAcH,GAAd,CAAJ,EAAwB,OAAOQ,yBAAyB,CAACd,GAAD,EAAMM,GAAN,CAAhC;AACxB,QAAMM,KAAK,CAAC,8BAAD,CAAX;AACD,CALD,C,CAOA;AACA;;;AACA,IAAME,yBAAyB,GAAGjB,WAAW,CAACgB,oBAAD,CAA7C,C,CAEA;;AACA,IAAMF,WAAW,GAAG,SAAdA,WAAc,CAACX,GAAD,EAAMe,GAAN,EAAc;AAAA,MACxBC,IADwB,GACTD,GADS,CACxBC,IADwB;AAAA,MAClBC,IADkB,GACTF,GADS,CAClBE,IADkB;;AAEhC,MAAID,IAAI,KAAK,QAAb,EAAuB;AACrB,4BAAiBH,oBAAoB,CAACb,GAAD,EAAMiB,IAAN,CAArC;AACD;;AACD,MAAID,IAAI,KAAK,MAAb,EAAqB;AACnB,0BAAeH,oBAAoB,CAACb,GAAD,EAAMiB,IAAN,CAAnC;AACD;;AACD,MAAID,IAAI,KAAK,eAAb,EAA8B;AAC5B,mCAAwBX,QAAQ,CAACL,GAAD,EAAMiB,IAAN,CAAhC;AACD;;AACD,QAAML,KAAK,CAAC,2BAAD,CAAX;AACD,CAZD;;AAcA,IAAMR,KAAK,GAAGR,OAAO,CAACD,SAAS,CAACC,OAAO,CAACS,QAAD,CAAR,CAAV,CAArB","sourcesContent":["const { isObject, buildCall, mapJoin, mapJoinWrap } = require('../../lib-util')\n\nmodule.exports = ctx => {\n  if (ctx.grp.length === 0) return\n  const txt = calls(ctx, ctx.grp)\n  return txt && `group by ${txt}`\n}\n\nconst buildArg = (ctx, arg) => {\n  if (typeof arg === 'string') return arg\n  if (typeof arg === 'function') return ctx.build(arg)\n  if (Array.isArray(arg)) return buildArrayArg(ctx, arg)\n  if (isObject(arg)) return buildObject(ctx, arg)\n  throw Error('Invalid order by argument:', arg)\n}\n\nconst buildArrayArg = mapJoinWrap(buildArg)\n\n// postgres only\n// clone of buildArg() without support for object args\nconst buildCubeOrRollupArg = (ctx, arg) => {\n  if (typeof arg === 'string') return arg\n  if (typeof arg === 'function') return ctx.build(arg)\n  if (Array.isArray(arg)) return buildCubeOrRollupArrayArg(ctx, arg)\n  throw Error('Invalid cube/rollup argument')\n}\n\n// postgres only\n// clone of buildArrayArg() without support for object args\nconst buildCubeOrRollupArrayArg = mapJoinWrap(buildCubeOrRollupArg)\n\n// postgres only\nconst buildObject = (ctx, obj) => {\n  const { type, args } = obj\n  if (type === 'rollup') {\n    return `rollup ${buildCubeOrRollupArg(ctx, args)}`\n  }\n  if (type === 'cube') {\n    return `cube ${buildCubeOrRollupArg(ctx, args)}`\n  }\n  if (type === 'grouping sets') {\n    return `grouping sets ${buildArg(ctx, args)}`\n  }\n  throw Error('Invalid group by argument')\n}\n\nconst calls = mapJoin(buildCall(mapJoin(buildArg)))\n"]},"metadata":{},"sourceType":"script"}