{"ast":null,"code":"const {\n  methods,\n  queries,\n  query,\n  clauses,\n  common\n} = require('../lib-sq');\n\nconst {\n  fromItems,\n  expressions\n} = common;\nconst {\n  wth,\n  from,\n  where,\n  group,\n  having,\n  setop,\n  order,\n  limit,\n  offset,\n  returning,\n  set\n} = clauses;\nconst postgresMethods = {\n  distinctOn: {\n    updateContext: (ctx, args) => {\n      if (ctx.distinct) {\n        ctx.distinct.push(args);\n      } else {\n        ctx.distinct = [args];\n      }\n    }\n  }\n}; // SELECT supports .distinctOn(...expressions)\n\nconst select = ctx => {\n  let txt = 'select ';\n\n  if (ctx.distinct) {\n    txt += 'distinct ';\n\n    if (ctx.distinct.length) {\n      txt += `on (${expressions(ctx, ctx.distinct)}) `;\n    }\n  }\n\n  txt += expressions(ctx, ctx.ret) || '*';\n  return txt;\n}; // DELETE: first .from call is used in the DELETE clause\n// subsequent .from calls are used in the USING clause\n\n\nconst del = ctx => {\n  const txt = fromItems(ctx, ctx.frm, 0, 1);\n  return txt && `delete from ${txt}`;\n};\n\nconst using = ctx => {\n  const txt = fromItems(ctx, ctx.frm, 1);\n  return txt && `using ${txt}`;\n}; // UPDATE: first .from call is used in the UPDATE clause\n// subsequent .from calls are used in the FROM clause\n\n\nconst update = ctx => {\n  const txt = fromItems(ctx, ctx.frm, 0, 1);\n  return txt && `update ${txt}`;\n};\n\nconst updateFrom = ctx => {\n  const txt = fromItems(ctx, ctx.frm, 1);\n  return txt && `from ${txt}`;\n};\n\nmodule.exports = {\n  methods: { ...methods,\n    ...postgresMethods\n  },\n  queries: { ...queries,\n    select: query(wth, select, from, where, group, having, setop, order, limit, offset),\n    delete: query(wth, del, using, where, returning),\n    update: query(wth, update, set, updateFrom, where, returning)\n  },\n  properties: {\n    rollup: {\n      value: (...args) => {\n        return {\n          type: 'rollup',\n          args\n        };\n      }\n    },\n    cube: {\n      value: (...args) => {\n        return {\n          type: 'cube',\n          args\n        };\n      }\n    },\n    groupingSets: {\n      value: (...args) => {\n        return {\n          type: 'grouping sets',\n          args\n        };\n      }\n    }\n  }\n};","map":{"version":3,"sources":["/Volumes/LaCie/Dev/myProjects/movie-nite/node_modules/EasyQB/src/dialect-postgres/query.js"],"names":["methods","queries","query","clauses","common","require","fromItems","expressions","wth","from","where","group","having","setop","order","limit","offset","returning","set","postgresMethods","distinctOn","updateContext","ctx","args","distinct","push","select","txt","length","ret","del","frm","using","update","updateFrom","module","exports","delete","properties","rollup","value","type","cube","groupingSets"],"mappings":"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","sourcesContent":["const { methods, queries, query, clauses, common } = require('../lib-sq')\n\nconst { fromItems, expressions } = common\nconst {\n  wth,\n  from,\n  where,\n  group,\n  having,\n  setop,\n  order,\n  limit,\n  offset,\n  returning,\n  set\n} = clauses\n\nconst postgresMethods = {\n  distinctOn: {\n    updateContext: (ctx, args) => {\n      if (ctx.distinct) {\n        ctx.distinct.push(args)\n      } else {\n        ctx.distinct = [args]\n      }\n    }\n  }\n}\n\n// SELECT supports .distinctOn(...expressions)\nconst select = ctx => {\n  let txt = 'select '\n  if (ctx.distinct) {\n    txt += 'distinct '\n    if (ctx.distinct.length) {\n      txt += `on (${expressions(ctx, ctx.distinct)}) `\n    }\n  }\n  txt += expressions(ctx, ctx.ret) || '*'\n  return txt\n}\n// DELETE: first .from call is used in the DELETE clause\n// subsequent .from calls are used in the USING clause\nconst del = ctx => {\n  const txt = fromItems(ctx, ctx.frm, 0, 1)\n  return txt && `delete from ${txt}`\n}\nconst using = ctx => {\n  const txt = fromItems(ctx, ctx.frm, 1)\n  return txt && `using ${txt}`\n}\n// UPDATE: first .from call is used in the UPDATE clause\n// subsequent .from calls are used in the FROM clause\nconst update = ctx => {\n  const txt = fromItems(ctx, ctx.frm, 0, 1)\n  return txt && `update ${txt}`\n}\nconst updateFrom = ctx => {\n  const txt = fromItems(ctx, ctx.frm, 1)\n  return txt && `from ${txt}`\n}\n\nmodule.exports = {\n  methods: { ...methods, ...postgresMethods },\n  queries: {\n    ...queries,\n    select: query(\n      wth,\n      select,\n      from,\n      where,\n      group,\n      having,\n      setop,\n      order,\n      limit,\n      offset\n    ),\n    delete: query(wth, del, using, where, returning),\n    update: query(wth, update, set, updateFrom, where, returning)\n  },\n  properties: {\n    rollup: {\n      value: (...args) => {\n        return {\n          type: 'rollup',\n          args\n        }\n      }\n    },\n    cube: {\n      value: (...args) => {\n        return {\n          type: 'cube',\n          args\n        }\n      }\n    },\n    groupingSets: {\n      value: (...args) => {\n        return {\n          type: 'grouping sets',\n          args\n        }\n      }\n    }\n  }\n}"]},"metadata":{},"sourceType":"script"}